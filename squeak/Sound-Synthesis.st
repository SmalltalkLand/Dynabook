Object subclass: #AbstractSound	instanceVariableNames: 'envelopes mSecsSinceStart samplesUntilNextControl scaledVol scaledVolIncr scaledVolLimit'	classVariableNames: 'FloatScaleFactor MaxScaledValue PitchesForBottomOctave ScaleFactor Sounds TopOfBottomOctave UnloadedSnd'	poolDictionaries: ''	category: 'Sound-Synthesis'!!AbstractSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 22:34'!isStereo	"Answer true if this sound has distinct left and right channels. (Every sound plays into a stereo sample buffer, but most sounds, which produce exactly the same samples on both channels, are not stereo.)"	^ false! !!AbstractSound methodsFor: 'composition'!+ aSound	"Return the mix of the receiver and the argument sound."	^ MixedSound new		add: self;		add: aSound! !!AbstractSound methodsFor: 'composition'!, aSound	"Return the concatenation of the receiver and the argument sound."	^ SequentialSound new		add: self;		add: aSound! !!AbstractSound methodsFor: 'composition' stamp: 'jm 2/2/1999 15:53'!asSound	^ self! !!AbstractSound methodsFor: 'composition' stamp: 'jm 12/17/97 18:00'!delayedBy: seconds	"Return a composite sound consisting of a rest for the given amount of time followed by the receiver."	^ (RestSound dur: seconds), self! !!AbstractSound methodsFor: 'conversion' stamp: 'jm 12/16/2001 13:26'!asSampledSound	"Answer a SampledSound containing my samples. If the receiver is some kind of sampled sound, the resulting SampledSound will have the same original sampling rate as the receiver."	^ SampledSound samples: self samples samplingRate: self originalSamplingRate! !!AbstractSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:15'!copy	"A sound should copy all of the state needed to play itself, allowing two copies of a sound to play at the same time. These semantics require a recursive copy but only down to the level of immutable data. For example, a SampledSound need not copy its sample buffer. Subclasses overriding this method should include a resend to super."	^ self clone copyEnvelopes! !!AbstractSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:40'!copyEnvelopes	"Private!! Support for copying. Copy my envelopes."	envelopes := envelopes collect: [:e | e copy target: self].! !!AbstractSound methodsFor: 'copying' stamp: 'di 3/4/1999 21:29'!sounds	"Allows simple sounds to behave as, eg, sequential sounds"	^ Array with: self! !!AbstractSound methodsFor: 'envelopes' stamp: 'stephaneducasse 2/4/2006 20:40'!addEnvelope: anEnvelope	"Add the given envelope to my envelopes list."	anEnvelope target: self.	envelopes := envelopes copyWith: anEnvelope.! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 12/15/97 17:02'!envelopes	"Return my collection of envelopes."	^ envelopes! !!AbstractSound methodsFor: 'envelopes' stamp: 'stephaneducasse 2/4/2006 20:40'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes := #().! !!AbstractSound methodsFor: 'envelopes' stamp: 'stephaneducasse 2/4/2006 20:40'!removeEnvelope: anEnvelope	"Remove the given envelope from my envelopes list."	envelopes := envelopes copyWithout: anEnvelope.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeAIFFOnFileNamed: fileName	"Store this sound as a AIFF file of the given name."	| f |	f := (FileStream fileNamed: fileName) binary.	self storeAIFFSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeAIFFSamplesOn: aBinaryStream	"Store this sound as a 16-bit AIFF file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount |	samplesToStore := (self duration * self samplingRate) ceiling.	channelCount := self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount := samplesToStore * channelCount * 2.	"write AIFF file header:"	aBinaryStream nextPutAll: 'FORM' asByteArray.	aBinaryStream nextInt32Put: ((7 * 4) + 18) + dataByteCount.	aBinaryStream nextPutAll: 'AIFF' asByteArray.	aBinaryStream nextPutAll: 'COMM' asByteArray.	aBinaryStream nextInt32Put: 18.	aBinaryStream nextNumber: 2 put: channelCount.	aBinaryStream nextInt32Put: samplesToStore.	aBinaryStream nextNumber: 2 put: 16.  "bits/sample"	self storeExtendedFloat: self samplingRate on: aBinaryStream.	aBinaryStream nextPutAll: 'SSND' asByteArray.	aBinaryStream nextInt32Put: dataByteCount + 8.	aBinaryStream nextInt32Put: 0.	aBinaryStream nextInt32Put: 0.	"write data:"	self storeSampleCount: samplesToStore bigEndian: true on: aBinaryStream.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeExtendedFloat: aNumber on: aBinaryStream	"Store an Apple extended-precision 80-bit floating point number on the given stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| n isNeg exp mantissa |	n := aNumber asFloat.	isNeg := false.	n < 0.0 ifTrue: [		n := 0.0 - n.		isNeg := true].	exp := (n log: 2.0) ceiling.	mantissa := (n * (2 raisedTo: 64 - exp)) truncated.	exp := exp + 16r4000 - 2.  "not sure why the -2 is needed..."	isNeg ifTrue: [exp := exp bitOr: 16r8000].  "set sign bit"	aBinaryStream nextPut: ((exp bitShift: -8) bitAnd: 16rFF).	aBinaryStream nextPut: (exp bitAnd: 16rFF).	8 to: 1 by: -1 do: [:i | aBinaryStream nextPut: (mantissa digitAt: i)].! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."	| bufSize stereoBuffer reverseBytes remaining out |	self reset.	bufSize := (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"	stereoBuffer := SoundBuffer newStereoSampleCount: bufSize.	reverseBytes := bigEndianFlag ~= (SmalltalkImage current isBigEndian).	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: samplesToStore during: [:bar |			remaining := samplesToStore.			[remaining > 0] whileTrue: [				bar value: samplesToStore - remaining.				stereoBuffer primFill: 0.  "clear the buffer"				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.				self isStereo					ifTrue: [out := stereoBuffer]					ifFalse: [out := stereoBuffer extractLeftChannel].				reverseBytes ifTrue: [out reverseEndianness].				(aBinaryStream isKindOf: StandardFileStream)					ifTrue: [  "optimization for files: write sound buffer directly to file"						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"					ifFalse: [  "for non-file streams:"						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].				remaining := remaining - bufSize]].! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeSunAudioOnFileNamed: fileName	"Store this sound as an uncompressed Sun audio file of the given name."	| f |	f := (FileStream fileNamed: fileName) binary.	self storeSunAudioSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeSunAudioSamplesOn: aBinaryStream	"Store this sound as a 16-bit Sun audio file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount |	samplesToStore := (self duration * self samplingRate) ceiling.	channelCount := self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount := samplesToStore * channelCount * 2.	"write Sun audio file header"	channelCount := self isStereo ifTrue: [2] ifFalse: [1].	aBinaryStream nextPutAll: '.snd' asByteArray.	aBinaryStream uint32: 24.	"header size in bytes"	aBinaryStream uint32: dataByteCount.	aBinaryStream uint32: 3.	"format: 16-bit linear"	aBinaryStream uint32: self samplingRate truncated.	aBinaryStream uint32: channelCount.	"write data:"	self storeSampleCount: samplesToStore bigEndian: true on: aBinaryStream.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeWAVOnFileNamed: fileName	"Store this sound as a 16-bit Windows WAV file of the given name."	| f |	f := (FileStream fileNamed: fileName) binary.	self storeWAVSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:40'!storeWAVSamplesOn: aBinaryStream	"Store this sound as a 16-bit Windows WAV file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount samplesPerSec bytesPerSec |	samplesToStore := (self duration * self samplingRate) ceiling.	channelCount := self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount := samplesToStore * channelCount * 2.	samplesPerSec := self samplingRate rounded.	bytesPerSec := samplesPerSec * channelCount * 2.	"file header"	aBinaryStream		nextPutAll: 'RIFF' asByteArray;		nextLittleEndianNumber: 4 put: dataByteCount + 36;	"total length of all chunks"		nextPutAll: 'WAVE' asByteArray.	"format chunk"	aBinaryStream		nextPutAll: 'fmt ' asByteArray;		nextLittleEndianNumber: 4 put: 16;	"length of this chunk"		nextLittleEndianNumber: 2 put: 1;	"format tag"		nextLittleEndianNumber: 2 put: channelCount;		nextLittleEndianNumber: 4 put: samplesPerSec;		nextLittleEndianNumber: 4 put: bytesPerSec;		nextLittleEndianNumber: 2 put: 4;	"alignment"		nextLittleEndianNumber: 2 put: 16.	"bits per sample"	"data chunk"	aBinaryStream		nextPutAll: 'data' asByteArray;		nextLittleEndianNumber: 4 put: dataByteCount.  "length of this chunk"	self storeSampleCount: samplesToStore bigEndian: false on: aBinaryStream.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 12/9/97 11:31'!duration: seconds	"Scale my envelopes to the given duration. Subclasses overriding this method should include a resend to super."	envelopes do: [:e | e duration: seconds].! !!AbstractSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:40'!initialize	envelopes := #().	mSecsSinceStart := 0.	samplesUntilNextControl := 0.	scaledVol := (1.0 * ScaleFactor) rounded.	scaledVolIncr := 0.	scaledVolLimit := scaledVol.! !!AbstractSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:40'!loudness: aNumber	"Initialize my volume envelopes and initial volume. Subclasses overriding this method should include a resend to super."	| vol |	vol := (aNumber asFloat max: 0.0) min: 1.0.	envelopes do: [:e |		(e isKindOf: VolumeEnvelope) ifTrue: [e scale: vol]].	self initialVolume: vol.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:40'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p := self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:40'!computeSamplesForSeconds: seconds	"Compute the samples of this sound without outputting them, and return the resulting buffer of samples."	| buf |	self reset.	buf := SoundBuffer newStereoSampleCount: (self samplingRate * seconds) asInteger.	self playSampleCount: buf stereoSampleCount into: buf startingAt: 1.	^ buf! !!AbstractSound methodsFor: 'playing' stamp: 'ar 12/5/1998 22:20'!isPlaying	"Return true if the receiver is currently playing"	^ SoundPlayer isPlaying: self! !!AbstractSound methodsFor: 'playing' stamp: 'di 5/30/1999 12:46'!millisecondsSinceStart	^ mSecsSinceStart! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/24/97 20:48'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	SoundPlayer pauseSound: self.! !!AbstractSound methodsFor: 'playing' stamp: 'gk 2/24/2004 22:23'!play	"Play this sound to the sound output port in real time."	SoundPlayer playSound: self.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:40'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol := AbstractSound scaleFactor.	samplesBetweenControlUpdates := self samplingRate // self controlRate.	pastEnd := startIndex + n.  "index just after the last sample"	i := startIndex.	[i < pastEnd] whileTrue: [		remainingSamples := self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count := pastEnd - i.		samplesUntilNextControl < count ifTrue: [count := samplesUntilNextControl].		remainingSamples < count ifTrue: [count := remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl := samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl := samplesBetweenControlUpdates].		i := i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:40'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize := self samplingRate // 10.	buf := SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:40'!playSilentlyUntil: startTime	"Compute the samples of this sound without outputting them. Used to fast foward to a particular starting time. The start time is given in seconds."	| buf startSample nextSample samplesRemaining n |	self reset.	buf := SoundBuffer newStereoSampleCount: (self samplingRate // 10).	startSample := (startTime * self samplingRate) asInteger.	nextSample := 1.	[self samplesRemaining > 0] whileTrue: [		nextSample >= startSample ifTrue: [^ self].		samplesRemaining := startSample - nextSample.		samplesRemaining > buf stereoSampleCount			ifTrue: [n := buf stereoSampleCount]			ifFalse: [n := samplesRemaining].		self playSampleCount: n into: buf startingAt: 1.		nextSample := nextSample + n].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 3/4/98 13:16'!resumePlaying	"Resume playing this sound from where it last stopped."	SoundPlayer resumePlaying: self.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 12/16/2001 13:22'!samples	"Answer a monophonic sample buffer containing my samples. The left and write channels are merged."	"Warning: This may require a lot of memory!!"	^ (self computeSamplesForSeconds: self duration) mergeStereo! !!AbstractSound methodsFor: 'playing' stamp: 'jm 12/16/2001 13:24'!viewSamples	"Open a WaveEditor on my samples."	WaveEditor openOn: self samples.! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/15/97 14:15'!controlRate	"Answer the number of control changes per second."	^ 100! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/16/2001 13:14'!originalSamplingRate	"For sampled sounds, answer the sampling rate used to record the stored samples. For other sounds, this is the same as the playback sampling rate."	^ SoundPlayer samplingRate! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/17/97 18:00'!samplingRate	"Answer the sampling rate in samples per second."	^ SoundPlayer samplingRate! !!AbstractSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:40'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange := false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange := true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart := mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 2/4/98 08:56'!internalizeModulationAndRatio	"Overridden by FMSound. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:40'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart := 0.	samplesUntilNextControl := 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 17:57'!samplesRemaining	"Answer the number of samples remaining until the end of this sound. A sound with an indefinite ending time should answer some large integer such as 1000000."	^ 1000000! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:40'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs := 10]		ifFalse: [			env := envelopes first.			decayInMs := env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!AbstractSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:40'!storeSample: sample in: aSoundBuffer at: sliceIndex leftVol: leftVol rightVol: rightVol	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, this method is hand-inlined into all sound generation methods that use it."	| i s |		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].! !!AbstractSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:40'!updateVolume	"Increment the volume envelope of this sound. To avoid clicks, the volume envelope must be interpolated at the sampling rate, rather than just at the control rate like other envelopes. At the control rate, the volume envelope computes the slope and next target volume volume for the current segment of the envelope (i.e., it sets the rate of change for the volume parameter). When that target volume is reached, incrementing is stopped until a new increment is set."	"This method is provided for documentation. To gain 10% more speed when running sound generation in Smalltalk, it is hand-inlined into all sound generation methods that use it."		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].! !!AbstractSound methodsFor: 'volume' stamp: 'stephaneducasse 2/4/2006 20:40'!adjustVolumeTo: vol overMSecs: mSecs	"Adjust the volume of this sound to the given volume, a number in the range [0.0..1.0], over the given number of milliseconds. The volume will be changed a little bit on each sample until the desired volume is reached."	| newScaledVol |	self flag: #bob.		"I removed the upper limit to allow making sounds louder. hmm..."	newScaledVol := (32768.0 * vol) truncated.	newScaledVol = scaledVol ifTrue: [^ self].	scaledVolLimit := newScaledVol.	"scaledVolLimit > ScaleFactor ifTrue: [scaledVolLimit := ScaleFactor]."	scaledVolLimit < 0 ifTrue: [scaledVolLimit := 0].	mSecs = 0		ifTrue: [  "change immediately"			scaledVol := scaledVolLimit.			scaledVolIncr := 0]		ifFalse: [			scaledVolIncr :=				((scaledVolLimit - scaledVol) * 1000) // (self samplingRate * mSecs)].! !!AbstractSound methodsFor: 'volume' stamp: 'stephaneducasse 2/4/2006 20:40'!initialVolume: vol	"Set the initial volume of this sound to the given volume, a number in the range [0.0..1.0]."	scaledVol := (((vol asFloat min: 1.0) max: 0.0) * ScaleFactor) rounded.	scaledVolLimit := scaledVol.	scaledVolIncr := 0.! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AbstractSound class	instanceVariableNames: ''!!AbstractSound class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor := 2 raisedTo: 15.	FloatScaleFactor := ScaleFactor asFloat.	MaxScaledValue := ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC := (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave := (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave := PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 1/5/98 13:51'!scaleFactor	^ ScaleFactor! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep := 2.0 raisedTo: (1.0 / 12.0).	pitch := aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch := pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch := pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale := SequentialSound new.	halfStep := 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd := endPitch asFloat]		ifFalse: [pEnd := AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p := startPitch asFloat]		ifFalse: [p := AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p := p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:35'!chromaticScale	"PluckedSound chromaticScale play"	^ self chromaticScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/31/98 16:14'!chromaticScaleOn: aSound	"PluckedSound chromaticScale play"	^ self noteSequenceOn: aSound		from: (((self chromaticPitchesFrom: #c4) copyFrom: 1 to: 13)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!hiMajorScale	"FMSound hiMajorScale play"	^ self hiMajorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:00'!hiMajorScaleOn: aSound	"FMSound hiMajorScale play"	^ self majorScaleOn: aSound from: #c6! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:36'!lowMajorScale	"PluckedSound lowMajorScale play"	^ self lowMajorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:01'!lowMajorScaleOn: aSound	"PluckedSound lowMajorScale play"	^ self majorScaleOn: aSound from: #c3! !!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:04'!majorChord	"FMSound majorChord play"	^ self majorChordOn: self default from: #c4! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale := self majorPitchesFrom: aPitch.	score := MixedSound new.	leadingRest := pan := 0.	#(1 3 5 8) do: [:noteIndex |		note := aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest := leadingRest + 0.2.		pan := pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!majorPitchesFrom: aPitch	| chromatic |	chromatic := self chromaticPitchesFrom: aPitch.	^ #(1 3 5 6 8 10 12 13 15 13 12 10 8 6 5 3 1) collect: [:i | chromatic at: i].! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:34'!majorScale	"FMSound majorScale play"	^ self majorScaleOn: self default! !!AbstractSound class methodsFor: 'examples' stamp: 'di 1/30/98 16:00'!majorScaleOn: aSound	"FMSound majorScale play"	^ self majorScaleOn: aSound from: #c5! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!majorScaleOn: aSound from: aPitch octaves: octaveCount	"(AbstractSound majorScaleOn: FMSound oboe1 from: #c2 octaves: 5) play"	| startingPitch pitches chromatic |	startingPitch := aPitch isNumber		ifTrue: [aPitch]		ifFalse: [self pitchForName: aPitch].	pitches := OrderedCollection new.	0 to: octaveCount - 1 do: [:i |		chromatic := self chromaticPitchesFrom: startingPitch * (2 raisedTo: i).		#(1 3 5 6 8 10 12) do: [:j | pitches addLast: (chromatic at: j)]].	pitches addLast: startingPitch * (2 raisedTo: octaveCount).	^ self noteSequenceOn: aSound		from: (pitches collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/5/98 17:32'!scaleTest	"AbstractSound scaleTest play"	^ MixedSound new		add: FMSound majorScale pan: 0;		add: (PluckedSound lowMajorScale delayedBy: 0.5) pan: 1.0.! !!AbstractSound class methodsFor: 'examples' stamp: 'stephaneducasse 2/4/2006 20:41'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod ratio |	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.	s := FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal := nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt := Sensor cursorPoint.		mousePt ~= lastVal ifTrue: [			mod := mousePt x asFloat / 20.0.			ratio := mousePt y asFloat / 20.0.			s modulation: mod ratio: ratio.			lastVal := mousePt.			status :='mod: ', mod printString, 'ratio: ', ratio printString.			status displayOn: Display at: 10@10]].	SoundPlayer shutDown.! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:38'!bachFugue	"Play a fugue by J. S. Bach using and instance of me as the sound for all four voices."	"PluckedSound bachFugue play"	^ self bachFugueOn: self default! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 18:27'!bachFugueOn: aSound	"Play a fugue by J. S. Bach using the given sound as the sound for all four voices."	"PluckedSound bachFugue play"	^ MixedSound new		add: (self bachFugueVoice1On: aSound) pan: 1.0;		add: (self bachFugueVoice2On: aSound) pan: 0.0;		add: (self bachFugueVoice3On: aSound) pan: 1.0;		add: (self bachFugueVoice4On: aSound) pan: 0.0.! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:51'!bachFugueVoice1On: aSound	"Voice one of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(784  0.30 268)		(831  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(1175 0.30 268)		(784  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(1175 0.30 268)		(698  0.15 268)		(784  0.15 268)		(831  0.60 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(1047 0.15 268)		(988  0.15 268)		(880  0.15 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(587  0.15 268)		(523  0.30 268)		(1245 0.30 268)		(1175 0.30 268)		(1047 0.30 268)		(932  0.30 268)		(880  0.30 268)		(932  0.30 268)		(1047 0.30 268)		(740  0.30 268)		(784  0.30 268)		(880  0.30 268)		(740  0.30 268)		(784  0.60 268)		(rest 0.15)		(523  0.15 268)		(587  0.15 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(831  0.45 268)		(587  0.15 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(880  0.15 268)		(932  0.45 268)		(622  0.15 268)		(698  0.15 268)		(784  0.15 268)		(831  0.15 268)		(784  0.15 268)		(698  0.15 268)		(622  0.15 268)		(587  0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.60 268)		(rest 0.9)		(1397 0.30 268)		(1245 0.30 268)		(1175 0.30 268)		(rest 0.3)		(831  0.30 268)		(784  0.30 268)		(698  0.30 268)		(784  0.30 268)		(698  0.15 268)		(622  0.15 268)		(698  0.30 268)		(587  0.30 268)		(784  0.60 268)		(rest 0.3)		(988  0.30 268)		(1047 0.30 268)		(1047 0.15 268)		(988  0.15 268)		(1047 0.30 268)		(784  0.30 268)		(831  0.60 268)		(rest 0.3)		(880  0.30 268)		(932  0.30 268)		(932  0.15 268)		(880  0.15 268)		(932  0.30 268)		(698  0.30 268)		(784  0.60 268)		(rest 0.3)		(784  0.30 268)		(831  0.30 268)		(831  0.30 268)		(784  0.30 268)		(698  0.30 268)		(rest 0.3)		(415  0.30 268)		(466  0.30 268)		(523  0.30 268)		(rest 0.3)		(415  0.15 268)		(392  0.15 268)		(415  0.30 268)		(349  0.30 268)		(466  0.30 268)		(523  0.30 268)		(466  0.30 268)		(415  0.30 268)		(466  0.30 268)		(392  0.30 268)		(349  0.30 268)		(311  0.30 268)		(349  0.30 268)		(554  0.30 268)		(523  0.30 268)		(466  0.30 268)		(523  0.30 268)		(415  0.30 268)		(392  0.30 268)		(349  0.30 268)		(392  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(523  0.30 268)		(622  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(880  0.30 268)		(587  0.30 268)		(784  0.15 268)		(740  0.15 268)		(784  0.30 268)		(880  0.30 268)		(523  0.15 268)		(587  0.15 268)		(622  0.60 268)		(587  0.15 268)		(523  0.15 268)		(466  0.30 346)		(rest 0.45)		(587  0.15 346)		(659  0.15 346)		(740  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.45 346)		(659  0.15 346)		(698  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.15 346)		(1047 0.45 346)		(740  0.15 346)		(784  0.15 346)		(880  0.15 346)		(932  0.30 346)		(622  0.15 346)		(587  0.15 346)		(622  0.30 346)		(392  0.30 346)		(415  0.30 346)		(698  0.15 346)		(622  0.15 346)		(698  0.30 346)		(440  0.30 346)		(466  0.30 346)		(784  0.15 346)		(698  0.15 346)		(784  0.30 346)		(494  0.30 346)		(523  0.15 346)		(698  0.15 346)		(622  0.15 346)		(587  0.15 346)		(523  0.15 346)		(466  0.15 346)		(440  0.15 346)		(392  0.15 346)		(349  0.30 346)		(831  0.30 346)		(784  0.30 346)		(698  0.30 346)		(622  0.30 346)		(587  0.30 346)		(622  0.30 346)		(698  0.30 346)		(494  0.30 346)		(523  0.30 346)		(587  0.30 346)		(494  0.30 346)		(523  0.60 346)		(rest 0.3)		(659  0.30 346)		(698  0.30 346)		(698  0.15 346)		(659  0.15 346)		(698  0.30 346)		(523  0.30 346)		(587  0.60 346)		(rest 0.3)		(587  0.30 346)		(622  0.30 346)		(622  0.15 346)		(587  0.15 346)		(622  0.30 346)		(466  0.30 346)		(523  1.20 346)		(523  0.30 346)		(587  0.15 346)		(622  0.15 346)		(698  0.15 346)		(622  0.15 346)		(698  0.15 346)		(587  0.15 346)		(494  0.30 457)		(rest 0.6)		(494  0.30 457)		(523  0.30 457)		(rest 0.6)		(622  0.30 457)		(587  0.30 457)		(rest 0.6)		(698  0.60 457)		(rest 0.6)		(698  0.30 457)		(622  0.30 457)		(831  0.30 457)		(784  0.30 457)		(698  0.30 457)		(622  0.30 457)		(587  0.30 457)		(622  0.30 457)		(698  0.30 457)		(494  0.30 457)		(523  0.30 457)		(587  0.30 457)		(494  0.30 457)		(494  0.30 457)		(523  0.30 457)		(rest 0.3)		(523  0.30 457)		(698  0.15 457)		(587  0.15 457)		(622  0.15 457)		(523  0.45 457)		(494  0.30 457)		(523  0.60 457)		(rest 0.3)		(659  0.30 268)		(698  0.60 268)		(rest 0.3)		(698  0.30 268)		(698  0.30 268)		(622  0.15 268)		(587  0.15 268)		(622  0.30 268)		(698  0.30 268)		(587  0.40 268)		(rest 0.4)		(587  0.40 268)		(rest 0.4)		(523  1.60 268)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice2On: aSound	"Voice two of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 4.8)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1047 0.30 346)		(1245 0.30 346)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1760 0.30 346)		(1175 0.30 346)		(1568 0.15 346)		(1480 0.15 346)		(1568 0.30 346)		(1760 0.30 346)		(1047 0.15 346)		(1175 0.15 346)		(1245 0.60 346)		(1175 0.15 346)		(1047 0.15 346)		(932  0.30 346)		(1245 0.15 346)		(1175 0.15 346)		(1245 0.30 346)		(784  0.30 346)		(831  0.30 346)		(1397 0.15 346)		(1245 0.15 346)		(1397 0.30 346)		(880  0.30 346)		(932  0.30 346)		(1568 0.15 346)		(1397 0.15 346)		(1568 0.30 346)		(988  0.30 346)		(1047 0.30 346)		(1175 0.15 346)		(1245 0.15 346)		(1397 0.90 346)		(1245 0.15 346)		(1175 0.15 346)		(1047 0.15 346)		(932  0.15 346)		(831  0.15 346)		(784  0.15 346)		(698  0.30 346)		(1661 0.30 346)		(1568 0.30 346)		(1397 0.30 346)		(1245 0.30 346)		(1175 0.30 346)		(1245 0.30 346)		(1397 0.30 346)		(988  0.30 346)		(1047 0.30 346)		(1175 0.30 346)		(988  0.30 346)		(1047 0.30 457)		(1568 0.15 457)		(1480 0.15 457)		(1568 0.30 457)		(1175 0.30 457)		(1245 0.60 457)		(rest 0.3)		(1319 0.30 457)		(1397 0.30 457)		(1397 0.15 457)		(1319 0.15 457)		(1397 0.30 457)		(1047 0.30 457)		(1175 0.60 457)		(rest 0.3)		(1175 0.30 457)		(1245 0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(932  0.30 457)		(1047 0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(1397 0.30 457)		(932  0.30 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.30 457)		(1397 0.30 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.60 457)		(932  0.15 457)		(831  0.15 457)		(784  0.15 457)		(622  0.15 457)		(698  0.15 457)		(784  0.15 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1397 0.15 457)		(1568 0.15 457)		(1760 0.15 457)		(1865 0.15 457)		(698  0.15 457)		(784  0.15 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(1175 0.15 457)		(1319 0.15 457)		(1397 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1245 0.15 457)		(1397 0.15 457)		(1568 0.15 457)		(1760 0.15 457)		(1976 0.15 457)		(2093 0.30 457)		(1976 0.15 457)		(1760 0.15 457)		(1568 0.15 457)		(1397 0.15 457)		(1245 0.15 457)		(1175 0.15 457)		(1047 0.30 457)		(1245 0.30 457)		(1175 0.30 457)		(1047 0.30 457)		(932  0.30 457)		(880  0.30 457)		(932  0.30 457)		(1047 0.30 457)		(740  0.30 457)		(784  0.30 457)		(880  0.30 457)		(740  0.30 457)		(784  0.30 457)		(1175 0.15 457)		(1047 0.15 457)		(1175 0.30 457)		(rest 0.6)		(1319 0.15 457)		(1175 0.15 457)		(1319 0.30 457)		(rest 0.6)		(1480 0.15 457)		(1319 0.15 457)		(1480 0.30 457)		(rest 0.6)		(784  0.15 457)		(698  0.15 457)		(784  0.30 457)		(rest 0.6)		(880  0.15 457)		(784  0.15 457)		(880  0.30 457)		(rest 0.6)		(988  0.15 457)		(880  0.15 457)		(988  0.30 457)		(rest 0.6)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(784  0.30 457)		(831  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(1175 0.30 457)		(784  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(1175 0.30 457)		(698  0.15 457)		(784  0.15 457)		(831  0.60 457)		(784  0.15 457)		(698  0.15 457)		(622  0.30 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.30 457)		(784  0.30 457)		(831  0.60 457)		(rest 0.3)		(880  0.30 457)		(932  0.30 457)		(932  0.15 457)		(880  0.15 457)		(932  0.30 457)		(698  0.30 457)		(784  0.60 457)		(rest 0.3)		(784  0.60 457)		(831  0.15 457)		(932  0.15 457)		(1047 0.15 457)		(988  0.15 457)		(1047 0.15 457)		(831  0.15 457)		(698  1.20 457)		(698  0.30 591)		(1175 0.15 591)		(1047 0.15 591)		(1175 0.30 591)		(698  0.30 591)		(622  0.30 591)		(1245 0.15 591)		(1175 0.15 591)		(1245 0.30 591)		(784  0.30 591)		(698  0.30 591)		(1397 0.15 591)		(1245 0.15 591)		(1397 0.30 591)		(831  0.30 591)		(784  0.15 591)		(1397 0.15 591)		(1245 0.15 591)		(1175 0.15 591)		(1047 0.15 591)		(988  0.15 591)		(880  0.15 591)		(784  0.15 591)		(1047 0.30 591)		(1397 0.30 591)		(1245 0.30 591)		(1175 0.30 591)		(rest 0.3)		(831  0.30 591)		(784  0.30 591)		(698  0.30 591)		(784  0.30 591)		(698  0.15 591)		(622  0.15 591)		(698  0.30 591)		(587  0.30 591)		(831  0.30 591)		(784  0.30 591)		(rest 0.3)		(880  0.30 591)		(988  0.30 591)		(1047 0.30 591)		(698  0.15 591)		(622  0.15 591)		(587  0.15 591)		(523  0.15 591)		(523  0.30 591)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(784  0.30 346)		(831  0.30 346)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(1175 0.30 346)		(784  0.30 346)		(1047 0.15 346)		(988  0.15 346)		(1047 0.30 346)		(1175 0.30 346)		(698  0.20 346)		(784  0.20 346)		(831  0.80 346)		(784  0.20 346)		(698  0.20 346)		(659  1.60 346)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice3On: aSound	"Voice three of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 14.4)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(392  0.30 457)		(415  0.30 457)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(587  0.30 457)		(392  0.30 457)		(523  0.15 457)		(494  0.15 457)		(523  0.30 457)		(587  0.30 457)		(349  0.15 457)		(392  0.15 457)		(415  0.60 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(523  0.15 457)		(494  0.15 457)		(440  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(294  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.15 457)		(196  0.15 457)		(175  0.15 457)		(466  0.15 457)		(415  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(262  0.15 457)		(294  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.15 457)		(196  0.15 457)		(175  0.15 457)		(156  0.15 457)		(415  0.15 457)		(392  0.15 457)		(349  0.15 457)		(311  0.15 457)		(277  0.15 457)		(262  0.15 457)		(233  0.15 457)		(208  0.30 457)		(523  0.30 457)		(466  0.30 457)		(415  0.30 457)		(392  0.30 457)		(349  0.30 457)		(392  0.30 457)		(415  0.30 457)		(294  0.30 457)		(311  0.30 457)		(349  0.30 457)		(294  0.30 457)		(311  0.30 457)		(415  0.30 457)		(392  0.30 457)		(349  0.30 457)		(392  0.30 457)		(311  0.30 457)		(294  0.30 457)		(262  0.30 457)		(294  0.30 457)		(466  0.30 457)		(415  0.30 457)		(392  0.30 457)		(415  0.30 457)		(349  0.30 457)		(311  0.30 457)		(294  0.30 457)		(311  0.30 457)		(rest 1.2)		(262  0.30 457)		(233  0.30 457)		(220  0.30 457)		(rest 0.3)		(311  0.30 457)		(294  0.30 457)		(262  0.30 457)		(294  0.30 457)		(262  0.15 457)		(233  0.15 457)		(262  0.30 457)		(294  0.30 457)		(196  0.30 591)		(466  0.15 591)		(440  0.15 591)		(466  0.30 591)		(294  0.30 591)		(311  0.30 591)		(523  0.15 591)		(466  0.15 591)		(523  0.30 591)		(330  0.30 591)		(349  0.30 591)		(587  0.15 591)		(523  0.15 591)		(587  0.30 591)		(370  0.30 591)		(392  0.60 591)		(rest 0.15)		(196  0.15 591)		(220  0.15 591)		(247  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.45 591)		(220  0.15 591)		(233  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.15 591)		(349  0.45 591)		(247  0.15 591)		(262  0.15 591)		(294  0.15 591)		(311  0.30 591)		(rest 0.6)		(330  0.30 591)		(349  0.30 591)		(175  0.30 591)		(156  0.30 591)		(147  0.30 591)		(rest 0.3)		(208  0.30 591)		(196  0.30 591)		(175  0.30 591)		(196  0.30 591)		(175  0.15 591)		(156  0.15 591)		(175  0.30 591)		(196  0.30 591)		(262  0.15 591)		(294  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(466  0.15 591)		(415  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(262  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(156  0.15 591)		(415  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(233  0.15 591)		(262  0.15 591)		(233  0.15 591)		(208  0.15 591)		(196  0.15 591)		(175  0.15 591)		(156  0.15 591)		(147  0.15 591)		(392  0.15 591)		(349  0.15 591)		(311  0.15 591)		(294  0.15 591)		(262  0.15 591)		(247  0.15 591)		(220  0.15 591)		(196  0.60 772)		(196  0.60 772)		(rest 0.15)		(196  0.15 772)		(220  0.15 772)		(247  0.15 772)		(262  0.15 772)		(294  0.15 772)		(311  0.15 772)		(349  0.15 772)		(392  0.15 772)		(349  0.15 772)		(415  0.15 772)		(392  0.15 772)		(349  0.15 772)		(311  0.15 772)		(294  0.15 772)		(262  0.15 772)		(247  0.30 772)		(262  0.15 772)		(494  0.15 772)		(262  0.30 772)		(196  0.30 772)		(208  0.30 772)		(262  0.15 772)		(247  0.15 772)		(262  0.30 772)		(294  0.30 772)		(196  0.30 772)		(262  0.15 772)		(247  0.15 772)		(262  0.30 772)		(294  0.30 772)		(175  0.15 772)		(196  0.15 772)		(208  0.60 772)		(196  0.15 772)		(175  0.15 772)		(156  0.60 772)		(rest 0.3)		(311  0.30 772)		(294  0.30 772)		(262  0.30 772)		(392  0.30 772)		(196  0.30 772)		(262  3.60 268)		(494  0.40 268)		(rest 0.4)		(494  0.40 268)		(rest 0.4)		(392  1.60 268)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 12/17/97 16:52'!bachFugueVoice4On: aSound	"Voice four of a fugue by J. S. Bach."	^ self noteSequenceOn: aSound from: #(		(rest 61.2)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(98   0.30 500)		(104  0.30 500)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(147  0.30 500)		(98   0.30 500)		(131  0.15 500)		(123  0.15 500)		(131  0.30 500)		(147  0.30 500)		(87   0.15 500)		(98   0.15 500)		(104  0.60 500)		(98   0.15 500)		(87   0.15 500)		(78   0.60 500)		(rest 0.3)		(156  0.30 500)		(147  0.30 500)		(131  0.30 500)		(196  0.30 500)		(98   0.30 500)		(131  3.60 268)		(131  3.20 205)).! !!AbstractSound class methodsFor: 'examples-bach fugue' stamp: 'jm 1/5/98 17:45'!stereoBachFugue	"Play fugue by J. S. Bach in stereo using different timbres."	"AbstractSound stereoBachFugue play"	"(AbstractSound bachFugueVoice1On: FMSound flute1) play"	"(AbstractSound bachFugueVoice1On: PluckedSound default) play"	^ MixedSound new		add: (self bachFugueVoice1On: FMSound oboe1) pan: 0.2;		add: (self bachFugueVoice2On: FMSound organ1) pan: 0.8;		add: (self bachFugueVoice3On: PluckedSound default) pan: 0.4;		add: (self bachFugueVoice4On: FMSound brass1) pan: 0.6.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 1/5/98 17:40'!default	"Return a default sound prototype for this class, with envelopes if appropriate. (This is in contrast to new, which returns a raw instance without envelopes.)"	^ self new! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:26'!dur: d	"Return a rest of the given duration."	^ self basicNew setDur: d! !!AbstractSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score := SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch := el at: 1.				pitch isNumber ifFalse: [pitch := self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 12/17/97 17:27'!pitch: p dur: d loudness: l	"Return a new sound object for a note with the given parameters."	^ self new setPitch: p dur: d loudness: l! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'ar 2/3/2001 15:30'!translatedPrimitives	^#(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(ReverbSound applyReverbTo:startingAt:count:)	).! !!AbstractSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!initSounds	"AbstractSound initSounds"	Sounds := Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 3/4/98 10:29'!soundNamed: soundName ifAbsent: aBlock	^ Sounds at: soundName ifAbsent: aBlock! !!AbstractSound class methodsFor: 'sound library' stamp: 'di 11/7/2000 12:12'!soundNamed: soundName put: aSound	Sounds at: soundName put: aSound.	AbstractSound updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 13:00'!updateFMSounds	"AbstractSound updateFMSounds"	Sounds keys do: [:k |		((Sounds at: k) isKindOf: FMSound) ifTrue: [			Sounds removeKey: k ifAbsent: []]].	(FMSound class organization listAtCategoryNamed: #instruments) do:		[:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'stephaneducasse 2/4/2006 20:41'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName := UIManager default request: 'Sound library file name?'.	fileName isEmptyOrNil ifTrue: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName := fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'stephaneducasse 2/4/2006 20:41'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s := FileStream oldFileNamed: fileName.	newSounds := s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	AbstractSound updateScorePlayers.	Smalltalk garbageCollect.  "Large objects may have been released"! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'rbb 3/1/2005 10:21'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName refStream |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName := UIManager default request: 'Sound library file name?'.	fileName isEmptyOrNil ifTrue: [^ self].	refStream := SmartRefStream fileNamed: fileName, '.sounds'.	refStream nextPut: aDictionary.	refStream close.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'stephaneducasse 2/4/2006 20:41'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu := SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice := menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i := 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i := i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'stephaneducasse 2/4/2006 20:41'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd := UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'stephaneducasse 2/4/2006 20:41'!updateScorePlayers	| soundsBeingEdited |	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allSubInstancesDo:		[:p | p pause].	SoundPlayer shutDown.	soundsBeingEdited := EnvelopeEditorMorph allSubInstances collect: [:ed | ed soundBeingEdited].	ScorePlayerMorph allSubInstancesDo:		[:p | p updateInstrumentsFromLibraryExcept: soundsBeingEdited].! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!busySignal: count	"AbstractSound busySignal: 3"	| m s |	s := SequentialSound new.	m := MixedSound new.	m	add: (FMSound new setPitch: 480 dur: 0.5 loudness: 0.5);		add: (FMSound new setPitch: 620 dur: 0.5 loudness: 0.5).	s add: m.	s add: (FMSound new setPitch: 1 dur: 0.5 loudness: 0).	^ (RepeatingSound repeat: s count: count) play.! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!dial: aString	| index lo hi m s |	"AbstractSound dial: '867-5309'" "ask for Jenny"	s := SequentialSound new.	aString do: [ :c |		c = $,			ifTrue: [ s add: (FMSound new setPitch: 1 dur: 1 loudness: 0) ]			ifFalse: [				(index := ('123A456B789C*0#D' indexOf: c)) > 0					ifTrue: [						lo := #(697 770 852 941) at: (index - 1 // 4 + 1).						hi := #(1209 1336 1477 1633) at: (index - 1 \\ 4 + 1).						m := MixedSound new.						m add: (FMSound new setPitch: lo dur: 0.15 loudness: 0.5).						m add: (FMSound new setPitch: hi dur: 0.15 loudness: 0.5).						s add: m.						s add: (FMSound new setPitch: 1 dur: 0.05 loudness: 0)]]].	^ s play.! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!dialTone: duration	"AbstractSound dialTone: 2"	| m |	m := MixedSound new.	m add: (FMSound new setPitch: 350 dur: duration loudness: 0.5).	m add: (FMSound new setPitch: 440 dur: duration loudness: 0.5).	m play.	^ m! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!hangUpWarning: count	"AbstractSound hangUpWarning: 20"	| m s |	s := SequentialSound new.	m := MixedSound new.	m	add: (FMSound new setPitch: 1400 dur: 0.1 loudness: 0.5);		add: (FMSound new setPitch: 2060 dur: 0.1 loudness: 0.5).	s add: m; add: (FMSound new setPitch: 1 dur: 0.1 loudness: 0).	^ (RepeatingSound repeat: s count: count) play! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p := pitchNameOrNumber asFloat]		ifFalse: [p := AbstractSound pitchForName: pitchNameOrNumber].	octave := -1.	[p >= TopOfBottomOctave] whileTrue: [		octave := octave + 1.		p := p / 2.0].	i := self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i := i - 1]].	midiKey := ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey := 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave := (midiKey \\ 12) + 1.	octave := (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!pitchForName: aString	"AbstractSound pitchForName: 'c2'"	"#(c 'c#' d eb e f fs g 'g#' a bf b) collect: [ :s | AbstractSound pitchForName: s, '4']"	| s modifier octave i j noteName p |	s := ReadStream on: aString.	modifier := $n.	noteName := s next.	(s atEnd not and: [s peek isDigit]) ifFalse: [ modifier := s next ].	s atEnd		ifTrue: [ octave := 4 ]		ifFalse: [ octave := Integer readFrom: s ].	octave < 0 ifTrue: [ self error: 'cannot use negative octave number' ].	i := 'cdefgab' indexOf: noteName.	i = 0 ifTrue: [ self error: 'bad note name: ', noteName asString ].	i := #(2 4 6 7 9 11 13) at: i.	j := 's#fb' indexOf: modifier.	j = 0 ifFalse: [ i := i + (#(1 1 -1 -1) at: j) ].  "i is now in range: [1..14]"	"Table generator: (1 to: 14) collect: [ :i | 16.3516 * (2.0 raisedTo: (i - 2) asFloat / 12.0)]"	p := #(15.4339 16.3516 17.3239 18.354 19.4454 20.6017 21.8268 23.1247 24.4997 25.9565 27.5 29.1352 30.8677 32.7032) at: i.	octave timesRepeat: [ p := 2.0 * p ].	^ p! !!AbstractSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!pitchTable	"AbstractSound pitchTable"	| out note i |	out := WriteStream on: (String new: 1000).	i := 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note := noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i := i + 1]].	^ out contents! !Object subclass: #AIFFFileReader	instanceVariableNames: 'in fileType channelCount frameCount bitsPerSample samplingRate channelData channelDataOffset markers pitch gain isLooped skipDataChunk mergeIfStereo'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!AIFFFileReader commentStamp: '<historical>' prior: 0!I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 10/20/2001 15:07'!channelDataOffset	^ channelDataOffset! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:40'!edit	| ed |	ed := WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:40'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave := (midiKey \\ 12) + 1.	octave := (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p := #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:40'!sound	"Answer the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd := SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd := SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd := MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	^ snd! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'stephaneducasse 2/4/2006 20:40'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. See comment in readFromStream:mergeIfStereo:skipDataChunk:."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	f := (FileStream readOnlyFileNamed: fileName) binary.	self readFromStream: f mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag.	f close.! !!AIFFFileReader methodsFor: 'reading' stamp: 'stephaneducasse 2/4/2006 20:40'!readFromStream: aBinaryStream mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read an AIFF file from the given binary stream. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	mergeIfStereo := mergeFlag.	skipDataChunk := skipDataFlag.	isLooped := false.	gain := 1.0.	self readFrom: aBinaryStream.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."	| compressionType |	channelCount := in nextNumber: 2.	frameCount := in nextNumber: 4.	bitsPerSample := in nextNumber: 2.	samplingRate := self readExtendedFloat.	chunkSize > 18 ifTrue: [		fileType = 'AIFF'			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].		compressionType := (in next: 4) asString.		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp := in nextNumber: 2.	mantissa := in nextNumber: 8.  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign := 1.0]		ifFalse: [sign := -1.0].	exp := (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in := aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz := in nextNumber: 4.	end := in position + sz.	fileType := (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType := (in next: 4) asString.		chunkSize := in nextNumber: 4.		p := in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey := in next.	detune := in next.	lowNote := in next.	highNote := in next.	lowVelocity := in next.	highVelocity := in next.	gain := in nextNumber: 2.	sustainMode := in nextNumber: 2.	sustainStartID := in nextNumber: 2.	sustainEndID := in nextNumber: 2.	releaseMode := in nextNumber: 2.	releaseStartID := in nextNumber: 2.	releaseEndID := in nextNumber: 2.	isLooped := sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped := false]].	pitch := self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount := in nextNumber: 2.	markers := Array new: markerCount.	1 to: markerCount do: [:i |		id := in nextNumber: 2.		position := in nextNumber: 4.		labelBytes := in next.		label := (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readMergedStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."	| buf w1 w2 |	buf := channelData at: 1.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w1 := s next.				w1 > 127 ifTrue: [w1 := w1 - 256].				w2 := s next.				w2 > 127 ifTrue: [w2 := w2 - 256].				buf at: i put: ((w1 + w2) bitShift: 7)]]		ifFalse: [			1 to: frameCount do: [:i |				w1 := (s next bitShift: 8) + s next.				w1 > 32767 ifTrue: [w1 := w1 - 65536].				w2 := (s next bitShift: 8) + s next.				w2 > 32767 ifTrue: [w2 := w2 - 65536].				buf at: i put: ((w1 + w2) bitShift: -1)]].! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readMonoChannelDataFrom: s	"Read monophonic channel data from the given stream. Each frame contains a single sample."	| buf w |	buf := channelData at: 1.  "the only buffer"	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w := s next.				w > 127 ifTrue: [w := w - 256].				buf at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w := (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w := w - 65536].				buf at: i put: w]].! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readMultiChannelDataFrom: s	"Read multi-channel data from the given stream. Each frame contains channelCount samples."	| w |	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w := s next.					w > 127 ifTrue: [w := w - 256].					(channelData at: ch) at: i put: (w bitShift: 8)]]]		ifFalse: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w := (s next bitShift: 8) + s next.					w > 32767 ifTrue: [w := w - 65536].					(channelData at: ch) at: i put: w]]].! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples s |	offset := in nextNumber: 4.	blockSize := in nextNumber: 4.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples := chunkSize - 8.	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))		ifFalse: [self error: 'actual sample count does not match COMM chunk'].	channelDataOffset := in position.  "record stream position for start of data"	skipDataChunk ifTrue: [in skip: (chunkSize - 8). ^ self].  "if skipDataChunk, skip sample data"	(mergeIfStereo and: [channelCount = 2])		ifTrue: [			channelData := Array with: (SoundBuffer newMonoSampleCount: frameCount)]		ifFalse: [			channelData :=				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))		ifTrue: [s := ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"		ifFalse: [s := in].  "not enough space to buffer; read directly from file"	"mono and stereo are special-cased for better performance"	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].	channelCount = 2 ifTrue: [		mergeIfStereo			ifTrue: [channelCount := 1. ^ self readMergedStereoChannelDataFrom: s]			ifFalse: [^ self readStereoChannelDataFrom: s]].	self readMultiChannelDataFrom: s.! !!AIFFFileReader methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!readStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream. Each frame contains two samples."	| left right w |	left := channelData at: 1.	right := channelData at: 2.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w := s next.				w > 127 ifTrue: [w := w - 256].				left at: i put: (w bitShift: 8).				w := s next.				w > 127 ifTrue: [w := w - 256].				right at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w := (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w := w - 65536].				left at: i put: w.				w := (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w := w - 65536].				right at: i put: w]].! !AbstractSoundSystem subclass: #BaseSoundSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!BaseSoundSystem commentStamp: 'gk 2/24/2004 08:35' prior: 0!This is the normal sound system in Squeak and is registered in SoundService - an AppRegistry - so that a small highlevel protocol for playing sounds can be used in a pluggable fashion.More information available in superclass.!!BaseSoundSystem methodsFor: 'misc' stamp: 'stephaneducasse 2/4/2006 20:40'!randomBitsFromSoundInput: bitCount	"Answer a positive integer with the given number of random bits of 'noise' from a sound input source. Typically, one would use a microphone or line input as the sound source, although many sound cards have enough thermal noise that you get random low-order sample bits even with no microphone connected. Only the least signficant bit of the samples is used. Since not all sound cards support 16-bits of sample resolution, we use the lowest bit that changes."	"(1 to: 10) collect: [:i | BaseSoundSystem new randomBitsFromSoundInput: 512]"	| recorder buf mid samples bitMask randomBits bit |	"collect some sound data"	recorder := SoundRecorder new clearRecordedSound.	recorder resumeRecording.	(Delay forSeconds: 1) wait.	recorder stopRecording.	buf := recorder condensedSamples.	"grab bitCount samples from the middle"	mid := buf monoSampleCount // 2.	samples := buf copyFrom: mid to: mid + bitCount - 1.	"find the least significant bit that varies"	bitMask := 1.	[bitMask < 16r10000 and:	 [(samples collect: [:s | s bitAnd: bitMask]) asSet size < 2]]		whileTrue: [bitMask := bitMask bitShift: 1].	bitMask = 16r10000 ifTrue: [^ self error: 'sound samples do not vary'].	"pack the random bits into a positive integer"	randomBits := 0.	1 to: samples size do: [:i |		bit := ((samples at: i) bitAnd: bitMask) = 0 ifTrue: [0] ifFalse: [1].		randomBits := (randomBits bitShift: 1) + bit].	^ randomBits	! !!BaseSoundSystem methodsFor: 'misc' stamp: 'ads 7/30/2003 22:18'!sampledSoundChoices	^ SampledSound soundNames! !!BaseSoundSystem methodsFor: 'misc' stamp: 'gk 2/23/2004 19:53'!shutDown	SoundPlayer shutDown! !!BaseSoundSystem methodsFor: 'misc' stamp: 'ads 7/30/2003 23:17'!soundNamed: soundName	^ SampledSound soundNamed: soundName! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:20'!beep	"There is sound support, so we use the default	sampled sound for a beep."	Preferences soundsEnabled ifTrue: [		SampledSound beep]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:20'!playSampledSound: samples rate: rate	Preferences soundsEnabled ifTrue: [		(SampledSound samples: samples samplingRate: rate) play]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:23'!playSoundNamed: soundName	"There is sound support, so we play the given sound."	Preferences soundsEnabled ifTrue: [		SampledSound playSoundNamed: soundName asString]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:22'!playSoundNamed: soundName ifAbsentReadFrom: aifFileName	Preferences soundsEnabled ifTrue: [		(SampledSound soundNames includes: soundName) ifFalse: [			(FileDirectory default fileExists: aifFileName) ifTrue: [				SampledSound					addLibrarySoundNamed: soundName					fromAIFFfileNamed: aifFileName]].		(SampledSound soundNames includes: soundName) ifTrue: [			SampledSound playSoundNamed: soundName]]! !!BaseSoundSystem methodsFor: 'playing' stamp: 'gk 2/23/2004 19:23'!playSoundNamedOrBeep: soundName	"There is sound support, so we play the given sound	instead of beeping."	Preferences soundsEnabled ifTrue: [		^self playSoundNamed: soundName]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BaseSoundSystem class	instanceVariableNames: ''!!BaseSoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!initialize	SoundService register: self new.! !!BaseSoundSystem class methodsFor: 'class initialization' stamp: 'gk 2/23/2004 21:08'!unload	SoundService registeredClasses do: [:ss |		(ss isKindOf: self) ifTrue: [SoundService unregister: ss]].! !Object subclass: #CompressedSoundData	instanceVariableNames: 'channels soundClassName codecName loopEnd loopLength perceivedPitch samplingRate gain firstSample cachedSound'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!CompressedSoundData commentStamp: '<historical>' prior: 0!Instances of this class hold the data resulting from compressing a sound.  Each carries a reference to the codec class that created it, so that it can reconstruct a sound similar to the original in response to the message asSound.In order to facilitate integration with existing sounds, a CompressedSoundData instance can masquerade as a sound by caching a copy of its original sound and delegating the essential sound-playing protocol to that cached copy.  It should probably be made a subclass of AbstractSound to complete the illusion.!!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:10'!channels	"Answer an array of ByteArrays containing the compressed sound data for each channel."	^ channels! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!channels: anArray	channels := anArray.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!codecName	"Answer the name of the sound codec used to compress this sound. Typically, this is the name of a class that can be used to decode the sound, but it is possible that the codec has not yet been implemented or is not filed into this image."	^ codecName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!codecName: aStringOrSymbol	codecName := aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!firstSample	"Answer the firstSample of the original sound."	^ firstSample! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:40'!firstSample: anInteger	firstSample := anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:55'!gain	"Answer the gain of the original sound."	^ gain! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!gain: aNumber	gain := aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopEnd	"Answer index of the last sample of the loop, or nil if the original sound was not looped."	^ loopEnd! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:40'!loopEnd: anInteger	loopEnd := anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopLength	"Answer length of the loop, or nil if the original sound was not looped."	^ loopLength! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!loopLength: anInteger	loopLength := anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!perceivedPitch	"Answer the perceived pitch of the original sound. By convention, unpitched sounds (like drum hits) are given an arbitrary pitch of 100.0."	^ perceivedPitch! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:40'!perceivedPitch: aNumber	perceivedPitch := aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:13'!samplingRate	"Answer the samplingRate of the original sound."	^ samplingRate! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!samplingRate: aNumber	samplingRate := aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!soundClassName	"Answer the class name of the uncompressed sound."	^ soundClassName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:40'!soundClassName: aStringOrSymbol	soundClassName := aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 09:50'!compressWith: codecClass	codecName == codecClass name asSymbol ifTrue: [^self].	^self asSound compressWith: codecClass! !!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'RAA 12/24/2000 08:53'!compressWith: codecClass atRate: aSamplingRate	(codecName == codecClass name asSymbol and: [samplingRate = aSamplingRate]) ifTrue: [^self].	^self asSound compressWith: codecClass atRate: aSamplingRate! !!CompressedSoundData methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:40'!withEToySound: aByteArray samplingRate: anInteger	soundClassName := #SampledSound.	channels := {aByteArray}.	codecName := #GSMCodec.	loopEnd := nil.	"???"	loopLength :=  nil.	perceivedPitch := 100.0.	samplingRate  := anInteger.	gain  := 1.0.	"???"	firstSample := 1.	cachedSound  := nil.	"???"! !!CompressedSoundData methodsFor: 'asSound' stamp: 'stephaneducasse 2/4/2006 20:41'!asSound	"Answer the result of decompressing the receiver."	| codecClass |	codecClass := Smalltalk at: codecName		ifAbsent: [^ self error: 'The codec for decompressing this sound is not available'].	^ (codecClass new decompressSound: self) reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!doControl	cachedSound doControl! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	cachedSound mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol! !!CompressedSoundData methodsFor: 'asSound' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"This message is the cue to start behaving like a real sound in order to be played.	We do this by caching a decompressed version of this sound.	See also samplesRemaining."	cachedSound == nil ifTrue: [cachedSound := self asSound].	cachedSound reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:44'!samples	^ self asSound samples! !!CompressedSoundData methodsFor: 'asSound' stamp: 'stephaneducasse 2/4/2006 20:40'!samplesRemaining	"This message is the cue that the cached sound may no longer be needed.	We know it is done playing when samplesRemaining=0."	| samplesRemaining |	samplesRemaining := cachedSound samplesRemaining.	samplesRemaining <= 0 ifTrue: [cachedSound := nil].	^ samplesRemaining! !Object subclass: #Envelope	instanceVariableNames: 'points loopStartIndex loopEndIndex loopStartMSecs loopMSecs target updateSelector loopEndMSecs endMSecs scale decayScale lastValue currValue valueIncr nextRecomputeTime noChangesDuringLoop'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!Envelope commentStamp: '<historical>' prior: 0!An envelope models a three-stage progression for a musical note: attack, sustain, decay. Envelopes can either return the envelope value at a given time or can update some target object using a client-specified message selector.The points instance variable holds an array of (time, value) points, where the times are in milliseconds. The points array must contain at least two points. The time coordinate of the first point must be zero and the time coordinates of subsequent points must be in ascending order, although the spacing between them is arbitrary. Envelope values between points are computed by linear interpolation.The scale slot is initially set so that the peak of envelope matches some note attribute, such as its loudness. When entering the decay phase, the scale is adjusted so that the decay begins from the envelope's current value. This avoids a potential sharp transient when entering the decay phase.The loopStartIndex and loopEndIndex slots contain the indices of points in the points array; if they are equal, then the envelope holds a constant value for the sustain phase of the note. Otherwise, envelope values are computed by repeatedly looping between these two points.The loopEndMSecs slot can be set in advance (as when playing a score) or dynamically (as when responding to interactive inputs from a MIDI keyboard). In the latter case, the value of scale is adjusted to start the decay phase with the current envelope value. Thus, if a note ends before its attack is complete, the decay phase is started immediately (i.e., the attack phase is never completed).For best results, amplitude envelopes should start and end with zero values. Otherwise, the sharp transient at the beginning or end of the note may cause audible clicks or static. For envelopes on other parameters, this may not be necessary.!!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 10:21'!decayEndIndex	^ points size! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 08:53'!decayTime	"Return the time taken by the decay phase."	^ points last x - (points at: loopEndIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'di 1/20/98 21:35'!duration	"Return the time of the final point."	loopEndMSecs == nil		ifTrue: [^ points last x]		ifFalse: [^ loopEndMSecs + self decayTime].! !!Envelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs := (seconds * 1000.0) asInteger - 19.	attack := self attackTime.	decay := self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime := endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime := attack]				ifFalse: [endTime := endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!loopEndIndex	^ loopEndIndex! !!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!loopStartIndex	^ loopStartIndex! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 2/4/98 17:24'!points	^ points! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:36'!scale	^ scale! !!Envelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!scale: aNumber	scale := aNumber asFloat.! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/26/97 09:25'!target	^ target! !!Envelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!target: anObject	target := anObject.! !!Envelope methodsFor: 'accessing' stamp: 'jm 11/24/97 14:34'!updateSelector	^ updateSelector! !!Envelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!updateSelector: aSymbol	updateSelector := aSymbol.! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!computeValueAtMSecs: mSecs	"Return the value of this envelope at the given number of milliseconds from its onset. Return zero for times outside the time range of this envelope."	"Note: Unlike the private method incrementalComputeValueAtMSecs:, this method does is not increment. Thus it is slower, but it doesn't depend on being called sequentially at fixed time intervals."	| t i |	mSecs < 0 ifTrue: [^ 0.0].	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t := (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i := self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [^ 0.0].  "past end"		^ (self interpolate: t between: (points at: i - 1) and: (points at: i)) * decayScale].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i := self indexOfPointAfterMSecs: mSecs startingAt: 1.		i = 1 ifTrue: [^ (points at: 1) y * scale].		^ self interpolate: mSecs between: (points at: i - 1) and: (points at: i)].	"sustain phase"	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y * scale].  "looping on a single point"	t := loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i := self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	^ self interpolate: t between: (points at: i - 1) and: (points at: i)! !!Envelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"Reset the state for this envelope."	lastValue := -100000.0.  "impossible value"	nextRecomputeTime := 0.	self updateTargetAt: 0.! !!Envelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!sustainEnd: mSecs	"Set the ending time of the sustain phase of this envelope; the decay phase will start this point. Typically derived from a note's duration."	"Details: to avoid a sharp transient, the decay phase is scaled so that the beginning of the decay matches the envelope's instantaneous value when the decay phase starts."	| vIfSustaining firstVOfDecay |	loopEndMSecs := nil. "pretend to be sustaining"	decayScale := 1.0.	nextRecomputeTime := 0.	vIfSustaining := self computeValueAtMSecs: mSecs.  "get value at end of sustain phase"	loopEndMSecs := mSecs.	firstVOfDecay := (points at: loopEndIndex) y * scale.	firstVOfDecay = 0.0		ifTrue: [decayScale := 1.0]		ifFalse: [decayScale := vIfSustaining / firstVOfDecay].! !!Envelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| newValue |	newValue := self valueAtMSecs: mSecs.	newValue = lastValue ifTrue: [^ false].	target		perform: updateSelector		with: newValue.	lastValue := newValue.	^ true! !!Envelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!valueAtMSecs: mSecs	"Return the value of this envelope at the given number of milliseconds from its onset. Return zero for times outside the time range of this envelope."	mSecs < 0 ifTrue: [^ 0.0].	mSecs < nextRecomputeTime		ifTrue: [currValue := currValue + valueIncr]		ifFalse: [currValue := self incrementalComputeValueAtMSecs: mSecs].	^ currValue! !!Envelope methodsFor: 'storing' stamp: 'di 2/1/98 15:45'!storeOn: strm	strm nextPutAll: '((' , self class name;		nextPutAll: ' points: '; store: (points collect: [:p | p x @ (p y roundTo: 0.00001)]);		nextPutAll: ' loopStart: '; print: loopStartIndex;		nextPutAll: ' loopEnd: '; print: loopEndIndex; nextPutAll: ')';		nextPutAll: ' updateSelector: '; store: self updateSelector; nextPutAll: ';';		nextPutAll: ' scale: '; print: scale; nextPutAll: ')'.! !!Envelope methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!checkParameters	"Verify that the point array, loopStartIndex, and loopStopIndex obey the rules."	| lastT t |	points size > 1		ifFalse: [^ self error: 'the point list must contain at least two points'].	points first x = 0		ifFalse: [^ self error: 'the time of the first point must be zero'].	lastT := points first x.	2 to: points size do: [:i |		t := (points at: i) x.		t >= lastT			ifFalse: [^ self error: 'the points must be in ascending time order']].	(loopStartIndex isInteger and:	 [(loopStartIndex > 0) and: [loopStartIndex <= points size]])		ifFalse: [^ self error: 'loopStartIndex is not a valid point index'].	(loopEndIndex isInteger and:	 [(loopEndIndex > 0) and: [loopEndIndex <= points size]])		ifFalse: [^ self error: 'loopEndIndex is not a valid point index'].	 loopStartIndex <= loopEndIndex		ifFalse: [^ self error: 'loopEndIndex must not precede loopStartIndex'].! !!Envelope methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!computeIncrementAt: mSecs between: p1 and: p2 scale: combinedScale	"Compute the current and increment values for the given time between the given inflection points."	"Assume: p1 x <= mSecs <= p2 x"	| valueRange timeRange |	valueRange := (p2 y - p1 y) asFloat.	timeRange := (p2 x - p1 x) asFloat.	currValue := (p1 y + (((mSecs - p1 x) asFloat / timeRange) * valueRange)) * combinedScale.	valueIncr := (((p2 y * combinedScale) - currValue) / (p2 x - mSecs)) * 10.0.	^ currValue! !!Envelope methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!incrementalComputeValueAtMSecs: mSecs	"Compute the current value, per-step increment, and the time of the next inflection point."	"Note: This method is part of faster, but less general, way of computing envelope values. It depends on a known, fixed control updating rate."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t := (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i := self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			currValue := points last y * scale * decayScale.			valueIncr := 0.0.			nextRecomputeTime := mSecs + 1000000.			^ currValue].		nextRecomputeTime := mSecs + ((points at: i) x - t).		^ self computeIncrementAt: t			between: (points at: i - 1)			and: (points at: i)			scale: scale * decayScale].	mSecs < loopStartMSecs		ifTrue: [  "attack phase"			t := mSecs.			i := self indexOfPointAfterMSecs: t startingAt: 1.			nextRecomputeTime := mSecs + ((points at: i) x - t)]		ifFalse: [  "sustain (looping) phase"			noChangesDuringLoop ifTrue: [				currValue := (points at: loopEndIndex) y * scale.				valueIncr := 0.0.				loopEndMSecs == nil					ifTrue: [nextRecomputeTime := mSecs + 10]  "unknown end time"					ifFalse: [nextRecomputeTime := loopEndMSecs].				^ currValue].			t := loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).			i := self indexOfPointAfterMSecs: t startingAt: loopStartIndex.			nextRecomputeTime := (mSecs + ((points at: i) x - t)) min: loopEndMSecs].	^ self computeIncrementAt: t		between: (points at: i - 1)		and: (points at: i)		scale: scale.! !!Envelope methodsFor: 'private' stamp: 'jm 12/16/97 16:51'!indexOfPointAfterMSecs: mSecs startingAt: startIndex	"Return the index of the first point whose time is greater that mSecs, starting with the given index. Return nil if mSecs is after the last point's time."	startIndex to: points size do:		[:i | (points at: i) x > mSecs ifTrue: [^ i]].	^ nil! !!Envelope methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!interpolate: mSecs between: p1 and: p2	"Return the scaled, interpolated value for the given time between the given time points."	"Assume: p1 x <= mSecs <= p2 x"	| valueRange timeRange |	valueRange := (p2 y - p1 y) asFloat.	valueRange = 0.0 ifTrue: [^ p1 y * scale].	timeRange := (p2 x - p1 x) asFloat.	^ (p1 y + (((mSecs - p1 x) asFloat / timeRange) * valueRange)) * scale.! !!Envelope methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!setPoints: pointList loopStart: startIndex loopEnd: endIndex	| lastVal |	points := pointList asArray collect: [:p | p x asInteger @ p y asFloat].	loopStartIndex := startIndex.	loopEndIndex := endIndex.	self checkParameters.	loopStartMSecs := (points at: loopStartIndex) x.	loopMSecs := (points at: loopEndIndex) x - (points at: loopStartIndex) x.	loopEndMSecs := nil.  "unknown end time; sustain until end time is known"	scale ifNil: [scale := 1.0].	decayScale ifNil: [decayScale := 1.0].	"note if there are no changes during the loop phase"	noChangesDuringLoop := true.	lastVal := (points at: loopStartIndex) y.	loopStartIndex to: loopEndIndex do: [:i | 		(points at: i) y ~= lastVal ifTrue: [			noChangesDuringLoop := false.			^ self]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Envelope class	instanceVariableNames: ''!!Envelope class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!example	"Envelope example"	| p |	p := Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	^ (self points: p loopStart: 2 loopEnd: 4) sustainEnd: 1200.! !!Envelope class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!exponentialDecay: multiplier	"(Envelope exponentialDecay: 0.95) "	| mSecsPerStep pList t v last |	mSecsPerStep := 10.	((multiplier > 0.0) and: [multiplier < 1.0])		ifFalse: [self error: 'multiplier must be greater than 0.0 and less than 1.0'].	pList := OrderedCollection new.	pList add: 0@0.0.	last := 0.0.	v := 1.0.	t := 10.	[v > 0.01] whileTrue: [		(v - last) abs > 0.02 ifTrue: [			"only record substatial changes"			pList add: t@v.			last := v].		t := t + mSecsPerStep.		v := v * multiplier].	pList add: (t + mSecsPerStep)@0.0.	^ self points: pList asArray		loopStart: pList size 		loopEnd: pList size! !!Envelope class methodsFor: 'instance creation' stamp: 'jm 11/26/97 08:49'!points: pList loopStart: loopStart loopEnd: loopEnd	^ self new setPoints: pList asArray		loopStart: loopStart		loopEnd: loopEnd! !Object subclass: #FFT	instanceVariableNames: 'nu n sinTable permTable realData imagData window'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!FFT commentStamp: '<historical>' prior: 0!This class implements the Fast Fourier Transform roughly as described on page 367of "Theory and Application of Digital Signal Processing" by Rabiner and Gold.Each instance caches tables used for transforming a given size (n = 2^nu samples) of data.It would have been cleaner using complex numbers, but often the data is all real.!!FFT methodsFor: 'bulk processing' stamp: 'stephaneducasse 2/4/2006 20:41'!initializeHammingWindow: alpha	"Initialize the windowing function to the generalized Hamming window. See F. Richard Moore, Elements of Computer Music, p. 100. An alpha of 0.54 gives the Hamming window, 0.5 gives the hanning window."	| v midPoint |	window := FloatArray new: n.	midPoint := (n + 1) / 2.0.	1 to: n do: [:i |		v := alpha + ((1.0 - alpha) * (2.0 * Float pi * ((i - midPoint) / n)) cos).		window at: i put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'stephaneducasse 2/4/2006 20:41'!initializeTriangularWindow	"Initialize the windowing function to the triangular, or Parzen, window. See F. Richard Moore, Elements of Computer Music, p. 100."	| v |	window := FloatArray new: n.	0 to: (n // 2) - 1 do: [:i |		v := i / ((n // 2) - 1).		window at: (i + 1) put: v.		window at: (n - i) put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'stephaneducasse 2/4/2006 20:41'!setSize: anIntegerPowerOfTwo	"Initialize variables and tables for performing an FFT on the given number of samples. The number of samples must be an integral power of two (e.g. 1024). Prepare data for use with the fast primitive."	self nu: (anIntegerPowerOfTwo log: 2) asInteger.	n = anIntegerPowerOfTwo ifFalse: [self error: 'size must be a power of two'].	sinTable := sinTable asFloatArray.	permTable := permTable asWordArray.	realData := FloatArray new: n.	imagData := FloatArray new: n.	self initializeHammingWindow: 0.54.  "0.54 for Hamming, 0.5 for hanning"! !!FFT methodsFor: 'bulk processing' stamp: 'stephaneducasse 2/4/2006 20:41'!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j := 0.	index to: index + n - 1 do: [:i |		realData at: (j := j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData := FloatArray new: n.	self pluginTransformData: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real := realData copyFrom: 1 to: (n / 2).	imag := imagData copyFrom: 1 to: (n / 2).	out := (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT methodsFor: 'initialization' stamp: 'jm 8/25/1999 21:59'!n	^ n! !!FFT methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!nu: order	"Initialize variables and tables for transforming 2^nu points"	|  j perms k |	nu := order.	n := 2 bitShift: nu-1.	"Initialize permutation table (bit-reversed indices)"	j:=0.	perms := WriteStream on: (Array new: n).	0 to: n-2 do:		[:i |		i < j ifTrue: [perms nextPut: i+1; nextPut: j+1].		k := n // 2.		[k <= j] whileTrue: [j := j-k.  k := k//2].		j := j + k].	permTable := perms contents.	"Initialize sin table 0..pi/2 in n/4 steps."	sinTable := (0 to: n/4) collect: [:i | (i asFloat / (n//4) * Float pi / 2.0) sin]! !!FFT methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!realData: real	realData := real.	imagData := real collect: [:i | 0.0]  "imaginary component all zero"! !!FFT methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!realData: real imagData: imag	realData := real.	imagData := imag! !!FFT methodsFor: 'plugin-testing' stamp: 'stephaneducasse 2/4/2006 20:41'!pluginPrepareData	"The FFT plugin requires data to be represented in WordArrays or FloatArrays"	sinTable := sinTable asFloatArray.	permTable := permTable asWordArray.	realData := realData asFloatArray.	imagData := imagData asFloatArray.! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginTest  "Display restoreAfter: [(FFT new nu: 12) pluginTest]."	"Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self pluginPrepareData.	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: true]); endEntry.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: false]); endEntry.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 2/13/2001 21:10'!pluginTransformData: forward	"Plugin testing -- if the primitive is not implemented 	or cannot be found run the simulation. See also: FFTPlugin"	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	^(Smalltalk at: #FFTPlugin ifAbsent:[^self primitiveFailed])		doPrimitive: 'primitiveFFTTransformData'.! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:41'!plot: samples in: rect	"Throw-away code just to check out a couple of examples"	| min max x dx pen y |	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	min := 1.0e30.  max := -1.0e30.	samples do:		[:v |		min := min min: v.		max := max max: v].	pen := Pen new.  pen up.	x := rect left.	dx := rect width asFloat / samples size.	samples do:		[:v |		y := (max-v) / (max-min) * rect height asFloat.		pen goto: x asInteger @ (rect top + y asInteger).		pen down.		x := x + dx].	max printString displayOn: Display at: (x+2) @ (rect top-9).	min printString displayOn: Display at: (x+2) @ (rect bottom - 9)! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:41'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize := 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FFT methodsFor: 'testing' stamp: 'di 6/17/97 07:47'!test  "Display restoreAfter: [(FFT new nu: 8) test].  --  Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self transformForward: true.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	self transformForward: false.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'transforming' stamp: 'stephaneducasse 2/4/2006 20:41'!permuteData	| i end a b |	i := 1.	end := permTable size.	[i <= end] whileTrue:		[a := permTable at: i.		b := permTable at: i+1.		realData swap: a with: b.		imagData swap: a with: b.		i := i + 2]! !!FFT methodsFor: 'transforming' stamp: 'stephaneducasse 2/4/2006 20:41'!scaleData	"Scale all elements by 1/n when doing inverse"	| realN |	realN := n asFloat.	1 to: n do:		[:i |		realData at: i put: (realData at: i) / realN.		imagData at: i put: (imagData at: i) / realN]! !!FFT methodsFor: 'transforming' stamp: 'stephaneducasse 2/4/2006 20:41'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	self permuteData.	1 to: nu do:		[:level |		lev := 1 bitShift: level.		lev1 := lev // 2.		1 to: lev1 do:			[:j |			theta := j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU := sinTable at: sinTable size - theta.					imagU := sinTable at: theta + 1]				ifFalse:					[realU := (sinTable at: theta - (n//4) + 1) negated.					imagU := sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU := imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i := j.			[i <= n] whileTrue:				[ip := i + lev1.				realT := ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT := ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i := i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FFT class	instanceVariableNames: ''!!FFT class methodsFor: 'instance creation' stamp: 'jm 8/25/1999 12:49'!new: anIntegerPowerOfTwo	"Answer a new FFT instance for transforming data packets of the given size."	^ self new setSize: anIntegerPowerOfTwo! !AbstractSound subclass: #FMSound	instanceVariableNames: 'initialCount count waveTable scaledWaveTableSize scaledIndex scaledIndexIncr modulation multiplier normalizedModulation scaledOffsetIndex scaledOffsetIndexIncr'	classVariableNames: 'SineTable'	poolDictionaries: ''	category: 'Sound-Synthesis'!!FMSound methodsFor: 'accessing' stamp: 'jm 3/26/98 10:45'!duration	^ initialCount asFloat / self samplingRate asFloat! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	super duration: seconds.	count := initialCount := (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!internalizeModulationAndRatio	"Recompute the internal state for the modulation index and frequency ratio relative to the current pitch."	modulation < 0.0 ifTrue: [modulation := modulation negated].	multiplier < 0.0 ifTrue: [multiplier := multiplier negated].	normalizedModulation :=		((modulation * scaledIndexIncr)  / ScaleFactor) asInteger.	scaledOffsetIndexIncr := (multiplier * scaledIndexIncr) asInteger.	"clip to maximum values if necessary"	normalizedModulation > MaxScaledValue ifTrue: [		normalizedModulation := MaxScaledValue.		modulation := (normalizedModulation * ScaleFactor) asFloat / scaledIndexIncr].	scaledOffsetIndexIncr > (scaledWaveTableSize // 2) ifTrue: [		scaledOffsetIndexIncr := scaledWaveTableSize // 2.		multiplier := scaledOffsetIndexIncr asFloat / scaledIndexIncr].! !!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:15'!modulation	"Return the FM modulation index."	^ modulation! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!modulation: mod	"Set the FM modulation index. Typical values range from 0 (no modulation) to 5, although values up to about 10 are sometimes useful."	"Warning: This method is intended primarily for use by envelopes. For efficiency during envelope processing, this change will not take effect until internalizeModulationAndRatio is called."	modulation := mod asFloat.! !!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:39'!modulation: mod multiplier: freqRatio	"For backward compatibility. Needed to read old .fmp files."	self modulation: mod ratio: freqRatio.! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!modulation: mod ratio: freqRatio	"Set the modulation index and carrier to modulation frequency ratio for this sound, and compute the internal state that depends on these parameters."	modulation := mod asFloat.	multiplier := freqRatio asFloat.	self internalizeModulationAndRatio.! !!FMSound methodsFor: 'accessing' stamp: 'jm 12/17/97 18:05'!multiplier	^ multiplier! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!pitch: p	"Warning: Since the modulation and ratio are relative to the current pitch, some internal state must be recomputed when the pitch is changed. However, for efficiency during envelope processing, this compuation will not be done until internalizeModulationAndRatio is called."	scaledIndexIncr :=		((p asFloat * waveTable size asFloat * ScaleFactor asFloat) / self samplingRate asFloat) asInteger			min: (waveTable size // 2) * ScaleFactor.! !!FMSound methodsFor: 'accessing' stamp: 'jm 2/4/98 07:08'!ratio	"Return the FM modulation to carrier frequency ratio."	^ multiplier! !!FMSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!ratio: freqRatio	"Set the FM modulation to carrier frequency ratio."	"Warning: This method is intended primarily for use by envelopes. For efficiency during envelope processing, this change will not take effect until internalizeModulationAndRatio is called."	multiplier := freqRatio asFloat.! !!FMSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	super initialize.	waveTable := SineTable.	scaledWaveTableSize := waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation := 0.0].	multiplier ifNil: [multiplier := 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples := SoundBuffer fromArray: anArray]		ifFalse: [samples := anArray].	p := self pitch.	dur := self duration.	vol := self loudness.	waveTable := samples.	scaledWaveTableSize := waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #waveTable declareC: 'short int *waveTable'.	doingFM := (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample := (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset := normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex := (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex := scaledOffsetIndex + scaledWaveTableSize].				scaledIndex := (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex := scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex := (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	count := count - n.! !!FMSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	self internalizeModulationAndRatio.	super reset.	count := initialCount.	scaledIndex := 0.	scaledOffsetIndex := 0.! !!FMSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 19:34'!samplesRemaining	^ count! !!FMSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count := (mSecs * self samplingRate) // 1000.! !!FMSound methodsFor: 'storing' stamp: 'stephaneducasse 2/4/2006 20:41'!storeOn: strm	| env |	strm nextPutAll: '(((FMSound';		nextPutAll: ' pitch: '; print: self pitch;		nextPutAll: ' dur: '; print: self duration;		nextPutAll: ' loudness: '; print: self loudness; nextPutAll: ')';		nextPutAll: ' modulation: '; print: self modulation;		nextPutAll: ' ratio: '; print: self ratio; nextPutAll: ')'.	1 to: envelopes size do:		[:i | env := envelopes at: i.		strm cr; nextPutAll: '    addEnvelope: '. env storeOn: strm.		i < envelopes size ifTrue: [strm nextPutAll: ';']].	strm  nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FMSound class	instanceVariableNames: ''!!FMSound class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize := 4000.	SineTable := SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep := (2.0 * Float pi) / tableSize asFloat.	peak := ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd := FMSound new modulation: 0 ratio: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!bassoon1	"FMSound bassoon1 play"	"(FMSound lowMajorScaleOn: FMSound bassoon1) play"	| snd p env |	snd := FMBassoonSound new ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 40@0.45; add: 90@1.0; add: 180@0.9; add: 270@1.0; add: 320@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p := OrderedCollection new.	p add: 0@0.2; add: 40@0.9; add: 90@0.6; add: 270@0.6; add: 320@0.5.	env := Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #modulation:; scale: 5.05.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd := FMSound new modulation: 0 ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p := OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env := Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd := FMSound new modulation: 1 ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p := OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env := Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!clarinet	"FMSound clarinet play"	"(FMSound lowMajorScaleOn: FMSound clarinet) play"	| snd p env |	snd := FMSound new modulation: 0 ratio: 2.	p := OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p := OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env := Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!clarinet2	"FMSound clarinet2 play"	"(FMSound lowMajorScaleOn: FMSound clarinet2) play"	| snd p env |	snd := FMClarinetSound new modulation: 0 ratio: 2.	p := OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p := OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env := Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/5/98 17:35'!default	^ self oboe1! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd := FMSound new.	p := OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!flute2	"FMSound flute2 play"	"(FMSound majorScaleOn: FMSound flute2) play"	| snd p |	snd := FMSound new.	p := OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!marimba	"FMSound marimba play"	"(FMSound majorScaleOn: FMSound marimba) play"	| snd p env |	snd := FMSound new modulation: 1 ratio: 0.98.	p := OrderedCollection new.	p add: 0@1.0; add: 10@0.3; add: 40@0.1; add: 80@0.02; add: 120@0.1; add: 160@0.02; add: 220@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p := OrderedCollection new.	p add: 0@1.2; add: 80@0.85; add: 120@1.0; add: 160@0.85; add: 220@0.0.	env := Envelope points: p loopStart: 2 loopEnd: 4.	env updateSelector: #modulation:.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!mellowBrass	"FMSound mellowBrass play"	"(FMSound lowMajorScaleOn: FMSound mellowBrass) play"	| snd p env |	snd := FMSound new modulation: 0 ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 70@0.325; add: 120@0.194; add: 200@0.194; add: 320@0.194; add: 380@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p := OrderedCollection new.	p add: 0@0.1; add: 70@0.68; add: 120@0.528; add: 200@0.519; add: 320@0.528; add: 380@0.0.	env := Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd := FMSound new modulation: 1 ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!oboe2	"FMSound oboe2 play"	"(FMSound majorScaleOn: FMSound oboe2) play"	| snd p |	snd := FMSound new modulation: 1 ratio: 1.	p := OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd := FMSound new.	p := OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 110@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!pluckedElecBass	"FMSound pluckedElecBass play"	"(FMSound lowMajorScaleOn: FMSound pluckedElecBass) play"	| snd p env |	snd := FMSound new modulation: 1 ratio: 3.0.	p := OrderedCollection new.	p add: 0@0.4; add: 20@1.0; add: 30@0.6; add: 100@0.6; add: 130@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 4).	p := OrderedCollection new.	p add: 0@1.0; add: 20@2.0; add: 30@4.5; add: 100@4.5; add: 130@0.0.	env := Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #modulation:.	snd addEnvelope: env.	p := OrderedCollection new.	p add: 0@6.0; add: 20@4.0; add: 30@3.0; add: 100@3.0; add: 130@3.0.	env := Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #ratio:.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd := FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p := Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd := FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !FMSound subclass: #FMBassoonSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!FMBassoonSound methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p := self nameOrNumberToPitch: pitchNameOrNumber.	modScale := 9.4.	p > 100.0 ifTrue: [modScale := 8.3].	p > 150.0 ifTrue: [modScale := 6.4].	p > 200.0 ifTrue: [modScale := 5.2].	p > 300.0 ifTrue: [modScale := 3.9].	p > 400.0 ifTrue: [modScale := 2.8].	p > 600.0 ifTrue: [modScale := 1.7].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !FMSound subclass: #FMClarinetSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!FMClarinetSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p := self nameOrNumberToPitch: pitchNameOrNumber.	p < 262.0		ifTrue: [modScale := 25.0. self ratio: 4]		ifFalse: [modScale := 20.0. self ratio: 2].	p > 524.0 ifTrue: [modScale := 8.0].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !Object subclass: #FWT	instanceVariableNames: 'alpha beta coeffs h g hTilde gTilde samples nSamples nLevels transform'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!FWT commentStamp: '<historical>' prior: 0!This class implements the Fast Wavelet Transform.  It follows Mac Cody's article in Dr. Dobb's Journal, April 1992.  See also... 	http://www.dfw.net/~mcody/fwt/fwt.htmlNotable features of his implementation include...1.  The ability to generate a large family of wavelets (including the Haar (alpha=beta) and Daubechies) from two parameters, alpha and beta, which range between -pi and pi.2.  All data arrays have 5 elements added on to allow for convolution overrun with filters up to 6 in length (the max for this implementation).3.  After a forward transform, the detail coefficients of the deomposition are found in transform at: 2*i, for i = 1, 2, ... nLevels;  and the approximation coefficients are in transform at: (2*nLevels-1).  these together comprise the complete wavelet transform.The following changes from cody's listings should also be noted...1.  The three DotProduct routines have been merged into one.2.  The four routines WaveletDecomposition, DecomposeBranches, WaveletReconstruction, ReconstructBranches have all been merged into transformForward:.3.  All indexing follows the Smalltalk 1-to-N convention, naturally.!!FWT methodsFor: 'access' stamp: 'stephaneducasse 2/4/2006 20:41'!coeffs	"Return all coefficients needed to reconstruct the original samples"	| header csize strm |	header := Array with: nSamples with: nLevels with: alpha with: beta.	csize := header size.	1 to: nLevels do: [:i | csize := csize + (transform at: i*2) size].	csize := csize + (transform at: nLevels*2-1) size.	coeffs := Array new: csize.	strm := WriteStream on: coeffs.	strm nextPutAll: header.	1 to: nLevels do: [:i | strm nextPutAll: (transform at: i*2)].	strm nextPutAll: (transform at: nLevels*2-1).	^ coeffs! !!FWT methodsFor: 'access' stamp: 'stephaneducasse 2/4/2006 20:41'!coeffs: coeffArray	"Initialize this instance from the given coeff array (including header)."	| header strm |	strm := ReadStream on: coeffArray.	header := strm next: 4.	self nSamples: header first nLevels: header second.	self setAlpha: header third beta: header fourth.	1 to: nLevels do: [:i | transform at: i*2 put: (strm next: (transform at: i*2) size)].	transform at: nLevels*2-1 put: (strm next: (transform at: nLevels*2-1) size).	strm atEnd ifFalse: [self error: 'Data size error'].! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:26'!samples	^ samples copyFrom: 1 to: nSamples! !!FWT methodsFor: 'access' stamp: 'di 10/31/1998 12:25'!samples: anArray	1 to: anArray size do:		[:i | samples at: i put: (anArray at: i)].	nSamples+1 to: nSamples+5 do:		[:i | samples at: i put: 0.0]! !!FWT methodsFor: 'computation' stamp: 'stephaneducasse 2/4/2006 20:41'!convolveAndDec: inData dataLen: inLen filter: filter out: outData	"convolve the input sequence with the filter and decimate by two"	| filtLen offset outi dotp |	filtLen := filter size.	outi := 1.	1 to: inLen+9 by: 2 do:		[:i | 		i < filtLen		ifTrue:			[dotp := self dotpData: inData endIndex: i filter: filter						start: 1 stop: i inc: 1]		ifFalse:			[i > (inLen+5)			ifTrue:				[offset := i - (inLen+5).				dotp := self dotpData: inData endIndex: inLen+5 filter: filter						start: 1+offset stop: filtLen inc: 1]			ifFalse:				[dotp := self dotpData: inData endIndex: i filter: filter						start: 1 stop: filtLen inc: 1]].		outData at: outi put: dotp.		outi := outi + 1]! !!FWT methodsFor: 'computation' stamp: 'stephaneducasse 2/4/2006 20:41'!convolveAndInt: inData dataLen: inLen filter: filter sumOutput:sumOutput into: outData	"insert zeros between each element of the input sequence and	   convolve with the filter to interpolate the data"	| outi filtLen oddTerm evenTerm j |	outi := 1.	filtLen := filter size.	"every other dot product interpolates the data"	filtLen // 2 to: inLen + filtLen - 2 do:		[:i |		oddTerm := self dotpData: inData endIndex: i filter: filter									start: 2 stop: filter size inc: 2.		evenTerm := self dotpData: inData endIndex: i+1 filter: filter									start: 1 stop: filter size inc: 2.		sumOutput			ifTrue:				["summation with previous convolution if true"				outData at: outi put: (outData at: outi) + oddTerm.				outData at: outi+1 put: (outData at: outi+1) + evenTerm]			ifFalse:				["first convolution of pair if false"				outData at: outi put: oddTerm.				outData at: outi+1 put: evenTerm].		outi := outi + 2].	"Ought to be able to fit this last term into the above loop."	j := inLen + filtLen - 1.	oddTerm := self dotpData: inData endIndex: j filter: filter									start: 2 stop: filter size inc: 2.	sumOutput		ifTrue: [outData at: outi put: (outData at: outi) + oddTerm]		ifFalse: [outData at: outi put: oddTerm].! !!FWT methodsFor: 'computation' stamp: 'stephaneducasse 2/4/2006 20:41'!dotpData: data endIndex: endIndex filter: filter start: start stop: stop inc: inc	| sum i j |	sum := 0.0.	j := endIndex.	i := start.	[i <= stop] whileTrue:		[sum := sum + ((data at: j) * (filter at: i)).		i := i + inc.		j := j - 1].	^ sum! !!FWT methodsFor: 'computation' stamp: 'stephaneducasse 2/4/2006 20:41'!transformForward: forward	| inData inLen outData |	forward	ifTrue:		["first InData is input signal, following are intermediate approx coefficients"		inData := samples.  inLen := nSamples.		1 to: nLevels do:			[:i |			self convolveAndDec: inData dataLen: inLen					filter: hTilde out: (transform at: 2*i-1).			self convolveAndDec: inData dataLen: inLen					filter: gTilde out: (transform at: 2*i).			inData := transform at: 2*i-1.  inLen := inLen // 2]]	ifFalse:		[inLen := nSamples >> nLevels.		"all but last outData are next higher intermediate approximations,		last is final reconstruction of samples"		nLevels to: 1 by: -1 do:			[:i |			outData := i = 1 ifTrue: [samples]						ifFalse: [transform at: 2*(i-1)-1].			self convolveAndInt: (transform at: 2*i-1) dataLen: inLen					filter: h sumOutput: false into: outData.			self convolveAndInt: (transform at: 2*i) dataLen: inLen					filter: g sumOutput: true into: outData.			inLen := inLen * 2]]! !!FWT methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!nSamples: n nLevels: nLevs	"Initialize a wavelet transform."	"Note the sample array size must be N + 5, where N is a multiple of 2^nLevels"	| dyadSize |	(n // (1 bitShift: nLevs)) > 0 ifFalse: [self error: 'Data size error'].	(n \\ (1 bitShift: nLevs)) = 0 ifFalse: [self error: 'Data size error'].	nSamples := n.	samples := Array new: n + 5.	nLevels := nLevs.	transform := Array new: nLevels*2.  "Transformed data is stored as a tree of coeffs"	dyadSize := nSamples.	1 to: nLevels do:		[:i |  dyadSize := dyadSize // 2.		transform at: 2*i-1 put: (Array new: dyadSize + 5).		transform at: 2*i put: (Array new: dyadSize + 5)]! !!FWT methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setAlpha: alph beta: bet	"Set alpha and beta, compute wavelet coeefs, and derive hFilter and lFilter"	| tcosa tcosb tsina tsinb |	alpha := alph.	beta := bet.	"WaveletCoeffs..."	"precalculate cosine of alpha and sine of beta"	tcosa := alpha cos.	tcosb := beta cos.	tsina := alpha sin.	tsinb := beta sin.	coeffs := Array new: 6.		"calculate first two wavelet coefficients a := a(-2) and b := a(-1)"	coeffs at: 1 put: ((1.0 + tcosa + tsina) * (1.0 - tcosb - tsinb)					+ (2.0 * tsinb * tcosa)) / 4.0.	coeffs at: 2 put: ((1.0 - tcosa + tsina) * (1.0 + tcosb - tsinb)					- (2.0 * tsinb * tcosa)) / 4.0.	"precalculate cosine and sine of alpha minus beta"	tcosa := (alpha - beta) cos.	tsina := (alpha - beta) sin.	"calculate last four wavelet coefficients c := a(0), d := a(1), e := a(2), and f := a(3)"	coeffs at: 3 put: (1.0 + tcosa + tsina) / 2.0.	coeffs at: 4 put: (1.0 + tcosa - tsina) / 2.0.	coeffs at: 5 put: 1.0 - (coeffs at: 1) - (coeffs at: 3).	coeffs at: 6 put: 1.0 - (coeffs at: 2) - (coeffs at: 4).	"MakeFiltersFromCoeffs..."	"Select the non-zero wavelet coefficients"	coeffs := coeffs copyFrom: (coeffs findFirst: [:c | c abs > 1.0e-14])						to: (coeffs findLast: [:c | c abs > 1.0e-14]).	"Form the low pass and high pass filters for decomposition"	hTilde := coeffs reversed collect: [:c | c / 2.0].	gTilde := coeffs collect: [:c | c / 2.0].	1 to: gTilde size by: 2 do:		[:i | gTilde at: i put: (gTilde at: i) negated].	"Form the low pass and high pass filters for reconstruction"	h := coeffs copy.	g := coeffs reversed.	2 to: g size by: 2 do:		[:i | g at: i put: (g at: i) negated]! !!FWT methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:41'!doWaveDemo  "FWT new doWaveDemo"	"Printing the above should yield a small number -- I get 1.1e-32"	| originalData |	self nSamples: 312 nLevels: 3.	self setAlpha: 0.0 beta: 0.0.	"Install a sine wave as sample data"	self samples: ((1 to: nSamples) collect: [:i | ((i-1) * 0.02 * Float pi) sin]).	originalData := samples copy.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (0@0 extent: nSamples@100).	"Transform forward and plot the decomposition"	self transformForward: true.	transform withIndexDo:		[:w :i |		FFT new plot: (w copyFrom: 1 to: w size-5)			in: (i-1\\2*320@(i+1//2*130) extent: (w size-5)@100)].	"Test copy out and read in the transform coefficients"	self coeffs: self coeffs.	"Ttransform back, plot the reconstruction, and return the error figure"	self transformForward: false.	FFT new plot: (samples copyFrom: 1 to: nSamples) in: (320@0 extent: nSamples@100).	^ self meanSquareError: originalData! !!FWT methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:41'!meanSquareError: otherData	"Return the mean-square error between the current sample array and	some other data, presumably to evaluate a compression scheme."	| topSum bottomSum pointDiff |	topSum := bottomSum := 0.0.	1 to: nSamples do:		[:i |  pointDiff := (samples at: i) - (otherData at: i).		topSum := topSum + (pointDiff * pointDiff).		bottomSum := bottomSum + ((otherData at: i) * (otherData at: i))].	^ topSum / bottomSum! !!FWT methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:41'!viewPhiAndPsi  "(FWT new nSamples: 256 nLevels: 6) viewPhiAndPsi"	"View the scaling function and mother wavelets for this transform"	| p |	Display fillWhite: (0@0 extent: 300@300).	Display border: (0@0 extent: 300@300) width: 2.	[Sensor anyButtonPressed] whileFalse:		["Move mouse around in the outer rectangle to explore"		p := Sensor cursorPoint min: 300@300.		self setAlpha: (p x - 150) / 150.0 * Float pi				beta: (p y - 150) / 150.0 * Float pi.		'alpha=', (alpha roundTo: 0.01) printString, '   ',			'beta=', (beta roundTo: 0.01) printString, '    ' displayAt: 50@5.		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size - 1) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@30 extent: nSamples@100).		transform do: [:w | w atAllPut: 0.0].		(transform at: transform size) at: (nSamples>>nLevels) put: 1.0.		self transformForward: false.		FFT new plot: (samples copyFrom: 1 to: nSamples) in: (20@170 extent: nSamples@100)].	Sensor waitNoButton! !AbstractSound subclass: #LoopedSampledSound	instanceVariableNames: 'initialCount count releaseCount sampleCountForRelease leftSamples rightSamples originalSamplingRate perceivedPitch gain firstSample lastSample loopEnd scaledLoopLength scaledIndex scaledIndexIncr'	classVariableNames: 'FloatLoopIndexScaleFactor LoopIndexFractionMask LoopIndexScaleFactor'	poolDictionaries: ''	category: 'Sound-Synthesis'!!LoopedSampledSound commentStamp: '<historical>' prior: 0!I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!beUnlooped	scaledLoopLength := 0.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	super duration: seconds.	count := initialCount := (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!firstSample: aNumber	firstSample := (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!gain: aNumber	gain := aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!leftSamples: aSampleBuffer	leftSamples := aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26'!originalSamplingRate	^ originalSamplingRate! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:54'!perceivedPitch	^ perceivedPitch! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!pitch: p	scaledIndexIncr :=		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount := (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount := 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!rightSamples: aSampleBuffer	rightSamples := aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'zz 3/2/2004 08:18'!samples	"For compatibility with SampledSound. Just return my left channel (which is the only channel if I am mono)."	^ leftSamples! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'stephaneducasse 2/4/2006 20:41'!comeFullyUpOnReload: smartRefStream	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples := SoundBuffer fromByteArray: self leftSamples.			rightSamples := leftSamples]		ifFalse: [			leftSamples := SoundBuffer fromByteArray: self leftSamples.			rightSamples := SoundBuffer fromByteArray: self rightSamples].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'tk 9/25/2000 12:06'!objectForDataStream: refStrm    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	refStrm replace: leftSamples with: leftSamples asByteArray.	refStrm replace: rightSamples with: rightSamples asByteArray.	"substitution will be made in DataStream nextPut:"	^ self! !!LoopedSampledSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:41'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."	| reverseBytes |	(self isStereo or: [self samplingRate ~= originalSamplingRate]) ifTrue: [		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].	"optimization: if I'm not stereo and sampling rates match, just store my buffer"	reverseBytes := bigEndianFlag ~= SmalltalkImage current  isBigEndian.	reverseBytes ifTrue: [leftSamples reverseEndianness].	(aBinaryStream isKindOf: StandardFileStream)		ifTrue: [  "optimization for files: write sound buffer directly to file"			aBinaryStream next: (leftSamples size // 2) putAll: leftSamples startingAt: 1]  "size in words"		ifFalse: [  "for non-file streams:"			1 to: leftSamples monoSampleCount do: [:i | aBinaryStream int16: (leftSamples at: i)]].	reverseBytes ifTrue: [leftSamples reverseEndianness].  "restore to original endianness"! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p := OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	env := (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease := (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease := 0].	releaseCount := sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader := AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples := aiffFileReader rightSamples].	initialCount := (leftSamples size * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples := aiffFileReader rightSamples].	initialCount := (leftSamples size * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples := FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	super initialize.	loopStartIndex := (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples := rightSamples := aSoundBuffer.	originalSamplingRate := samplingRateInHz asFloat.	perceivedPitch := perceivedPitchInHz asFloat.	gain := 1.0.	firstSample := 1.	lastSample := leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd := loopEndIndex.	scaledLoopLength := (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr := (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	super initialize.	leftSamples := rightSamples := aSoundBuffer.	originalSamplingRate := samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch := 100.0]		ifNotNil: [perceivedPitch := perceivedPitchInHz asFloat].	gain := 1.0.	firstSample := 1.	lastSample := leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd := leftSamples size.	scaledLoopLength := 0.  "zero length means unlooped"	scaledIndexIncr := (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen := scaledLoopLength asFloat / LoopIndexScaleFactor.	ed := WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples := (leftSamples size - startIndex) + 1.	fftWinSize := 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize := fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize := fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!findStartPointAfter: index	"Answer the index of the last zero crossing sample before the given index."	| i |	i := index min: lastSample.	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i := i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i := i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i := self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i := i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i := i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft := self fftAt: startIndex.	powerArray := self normalizedResultsFromFFT: fft.	threshold := powerArray max / 50.0.	indices := (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s := leftSamples at: i.				s < 0 ifTrue: [s := 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s := leftSamples at: i.				s < 0 ifTrue: [s := 0 - s].				s > threshold ifTrue: [^ i].				s := rightSamples at: i.				s < 0 ifTrue: [s := 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo := leftSamples ~~ rightSamples.	compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.	compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor.	i := (2 * startIndex) - 1.	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex := (scaledIndex := scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex := (scaledIndex := scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex := sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count := 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex := sampleIndex]				ifFalse: [nextSampleIndex := ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m := scaledIndex bitAnd: LoopIndexFractionMask.		rightVal := leftVal :=			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal :=				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		rightVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0].			compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.			compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor]].	count := count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	super reset.	count := initialCount.	scaledIndex := firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count := (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo := self isStereo.	leftSamples := leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples := rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples := leftSamples].	originalSamplingRate := originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength := (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength := self loopLength / 2.0].	firstSample := (firstSample + 1) // 2.	lastSample := (lastSample + 1) // 2.	loopEnd := (loopEnd + 1) // 2.	scaledLoopLength := (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr := scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu := ((windowSize - 1) log: 2) truncated + 1.	n := 2 raisedTo: nu.	fft := FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r := (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg := r sum / r size.	^ r collect: [:v | v / avg].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LoopedSampledSound class	instanceVariableNames: ''!!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor := 512.	FloatLoopIndexScaleFactor := LoopIndexScaleFactor asFloat.	LoopIndexFractionMask := LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader := AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	self new fromAIFFFileReader: aiffFileReader mergeIfStereo: mergeFlag! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !AbstractSound subclass: #MixedSound	instanceVariableNames: 'sounds leftVols rightVols soundDone'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!MixedSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration	"Answer the duration of this sound in seconds."	| dur |	dur := 0.	sounds do: [:snd | dur := dur max: snd duration].	^ dur! !!MixedSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 20:23'!isStereo	^ true! !!MixedSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:37'!sounds	^ sounds! !!MixedSound methodsFor: 'composition'!+ aSound	"Return the mix of the receiver and the argument sound."	^ self add: aSound! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound	"Add the given sound with a pan setting of centered and no attenuation."	self add: aSound pan: 0.5 volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound pan: leftRightPan	"Add the given sound with the given left-right panning and no attenuation."	self add: aSound pan: leftRightPan volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'stephaneducasse 2/4/2006 20:41'!add: aSound pan: leftRightPan volume: volume	"Add the given sound with the given left-right pan, where 0.0 is full left, 1.0 is full right, and 0.5 is centered. The loudness of the sound will be scaled by volume, which ranges from 0 to 1.0."	| pan vol |	pan := ((leftRightPan * ScaleFactor) asInteger max: 0) min: ScaleFactor.	vol := ((volume * ScaleFactor) asInteger max: 0) min: ScaleFactor.	sounds := sounds copyWith: aSound.	leftVols := leftVols copyWith: ((ScaleFactor - pan) * vol) // ScaleFactor.	rightVols := rightVols copyWith: (pan * vol) // ScaleFactor.! !!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sounds."	^ super copy copySounds! !!MixedSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!copySounds	"Private!! Support for copying. Copy my component sounds and settings array."	sounds := sounds collect: [:s | s copy].	leftVols := leftVols copy.	rightVols := rightVols copy.! !!MixedSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	super initialize.	sounds := Array new.	leftVols := Array new.	rightVols := Array new.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	1 to: sounds size do: [:i | (sounds at: i) doControl].! !!MixedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| snd left right |	1 to: sounds size do: [:i |		(soundDone at: i) ifFalse: [			snd := sounds at: i.			left := (leftVol * (leftVols at: i)) // ScaleFactor.			right := (rightVol * (rightVols at: i)) // ScaleFactor.			snd samplesRemaining > 0				ifTrue: [					snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]				ifFalse: [soundDone at: i put: true]]].! !!MixedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	super reset.	sounds do: [:snd | snd reset].	soundDone := (Array new: sounds size) atAllPut: false.! !!MixedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!samplesRemaining	| remaining r |	remaining := 0.	1 to: sounds size do: [:i |		r := (sounds at: i) samplesRemaining.		r > remaining ifTrue: [remaining := r]].	^ remaining! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/10/1999 08:45'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	super stopGracefully.	sounds do: [:s | s stopGracefully].! !Envelope subclass: #PitchEnvelope	instanceVariableNames: 'centerPitch'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 1/31/98 14:46'!centerPitch	^ centerPitch! !!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!centerPitch: aNumber	centerPitch := aNumber.! !!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 07:30'!updateSelector	"Needed by the envelope editor."	^ #pitch:! !!PitchEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!updateTargetAt: mSecs	"Update the pitch for my target. Answer true if the value changed."	"Details: Assume envelope range is 0.0..2.0, with 1 being the center pitch. Subtracting one yields the range -1.0..1.0. Raising two to this power yields pitches between half and double the center pitch; i.e. from an octave below to an octave about the center pitch."	| newValue |	newValue := self valueAtMSecs: mSecs.	newValue ~= lastValue ifTrue: [		target pitch: (2.0 raisedTo: newValue - (scale / 2.0)) * centerPitch.		lastValue := newValue.		^ true].	^ false! !AbstractSound subclass: #PluckedSound	instanceVariableNames: 'initialCount count ring scaledIndex scaledIndexIncr scaledIndexLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!PluckedSound commentStamp: '<historical>' prior: 0!The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. Fractional indexing is used to allow precise tuning; without this, the pitch would be rounded to the pitch corresponding to the nearest buffer size.!!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!PluckedSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	super duration: seconds.	count := initialCount := (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	^ super copy copyRing! !!PluckedSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!copyRing	"Private!! Support for copying"	ring := ring copy.! !!PluckedSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p := self nameOrNumberToPitch: pitchNameOrNumber.	initialCount := (d * self samplingRate asFloat) asInteger.	ring := SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz := ring monoSampleCount.	scaledIndexLimit := (sz + 1) * ScaleFactor.	scaledIndexIncr := (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex := (startIndex + n) - 1.	scaledThisIndex := scaledNextIndex := scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex := scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex := ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average :=			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample := (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex := scaledNextIndex.		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	scaledIndex := scaledNextIndex.	count := count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"Fill the ring with random noise."	| seed n |	super reset.	seed := 17.	n := ring monoSampleCount.	1 to: n do: [:i |		seed := ((seed * 1309) + 13849) bitAnd: 65535.		ring at: i put: seed - 32768].	count := initialCount.	scaledIndex := ScaleFactor.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 11/26/97 10:51'!samplesRemaining	^ count! !!PluckedSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count := (mSecs * self samplingRate) // 1000.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluckedSound class	instanceVariableNames: ''!!PluckedSound class methodsFor: 'instruments' stamp: 'stephaneducasse 2/4/2006 20:41'!default	"PluckedSound default play"	"(AbstractSound majorScaleOn: PluckedSound default) play"	| snd p env |	snd := PluckedSound new.	p := OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 20@0.0.	env := VolumeEnvelope points: p loopStart: 2 loopEnd: 2.	env target: snd; scale: 0.3.	^ snd		addEnvelope: env;		setPitch: 220 dur: 3.0 loudness: 0.3! !AbstractSound subclass: #QueueSound	instanceVariableNames: 'startTime sounds currentSound done'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!QueueSound commentStamp: 'efc 1/2/2003 00:30' prior: 0!I am a queue for sound - give me a bunch of sounds to play and I will play them one at a time in the order that they are received.Example:"Here is a simple example which plays two sounds three times."| clink warble queue |clink _ SampledSound soundNamed: 'clink'.warble _ SampledSound soundNamed: 'warble'.queue _ QueueSound new.3 timesRepeat:[	queue add: clink; add: warble].queue play.Structure: startTime 		Integer -- if present, start playing when startTime <= Time millisecondClockValue							(schedule the sound to play later) sounds			SharedQueue -- the synchronized list of sounds. currentSound	AbstractSound -- the currently active sound done			Boolean -- am I done playing ?Other:You may want to keep track of the queue's position so that you can feed it at an appropriate rate. To do this in an event driven way, modify or subclass nextSound to notify you when appropriate. You could also poll by checking currentSound, but this is not recommended for most applications.!!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:52'!add: aSound	self sounds nextPut: aSound.	^ aSound! !!QueueSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!currentSound	currentSound isNil ifTrue: [currentSound := self nextSound].	^ currentSound! !!QueueSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!currentSound: aSound	currentSound := aSound! !!QueueSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!done: aBoolean	done := aBoolean! !!QueueSound methodsFor: 'accessing' stamp: 'len 8/29/1999 21:46'!sounds	^ sounds! !!QueueSound methodsFor: 'accessing' stamp: 'len 9/26/1999 17:19'!startTime	^ startTime! !!QueueSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!startTime: anInteger	startTime := anInteger! !!QueueSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	super initialize.	sounds := SharedQueue new.	done := false.	startTime := Time millisecondClockValue! !!QueueSound methodsFor: 'sound generation' stamp: 'len 8/29/1999 22:07'!doControl	super doControl.	self currentSound notNil ifTrue: [self currentSound doControl]! !!QueueSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	| finalIndex i remaining count rate |	self currentSound isNil ifTrue: [^ self].  "already done"	self startTime > Time millisecondClockValue ifTrue: [^ self].	rate := self samplingRate.	finalIndex := (startIndex + n) - 1.	i := startIndex.	[i <= finalIndex] whileTrue: [		[self currentSound isNil ifTrue: [^ self].		(remaining := self currentSound samplesRemaining) <= 0]			whileTrue: [self currentSound: self nextSound].		count := (finalIndex - i) + 1.		remaining < count ifTrue: [count := remaining].		self currentSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i := i + count]! !!QueueSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!nextSound	| answer |	sounds isEmpty ifTrue: [^ nil].	answer := sounds next.	answer reset.	^ answer! !!QueueSound methodsFor: 'sound generation' stamp: 'len 9/13/1999 00:26'!reset	super reset.	self currentSound notNil		ifTrue: [self currentSound reset]		ifFalse: [self currentSound: self nextSound]! !!QueueSound methodsFor: 'sound generation' stamp: 'len 8/29/1999 22:13'!samplesRemaining	(done and: [self sounds isEmpty])		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !Envelope subclass: #RandomEnvelope	instanceVariableNames: 'rand lowLimit highLimit delta'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18'!centerPitch: aNumber	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."	updateSelector = #pitch: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta	^ delta! !!RandomEnvelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!delta: aNumber	delta := aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit	^ highLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!highLimit: aNumber	highLimit := aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!lowLimit	^ lowLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!lowLimit: aNumber	lowLimit := aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17'!volume: aNumber	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."	updateSelector = #volume: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'applying' stamp: 'stephaneducasse 2/4/2006 20:41'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| r |	r := rand next.	r > 0.5		ifTrue: [			currValue := currValue + delta.			currValue > highLimit ifTrue: [currValue := highLimit]]		ifFalse: [			currValue := currValue - delta.			currValue < lowLimit ifTrue: [currValue := lowLimit]].	currValue = lastValue ifTrue: [^ false].	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].	target		perform: updateSelector		with: scale * currValue.	lastValue := currValue.	^ true! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29'!duration	^ 1.0! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!duration: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 1/14/1999 13:17'!name	^ 'random ', updateSelector! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30'!sustainEnd: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'stephaneducasse 2/4/2006 20:41'!points	| env |	points isNil ifTrue: [		env := self target envelopes first.		points := OrderedCollection new.		points			add: 0@(self delta * 5 + 0.5);			add: (env points at: env loopStartIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points at: env loopEndIndex)x@(self highLimit -1 * 5 + 0.5);			add: (env points last)x@(self lowLimit -1 * 5 + 0.5).		loopStartIndex := 2.		loopEndIndex := 3.	].	^points! !!RandomEnvelope methodsFor: 'envelopeEditor compatibility' stamp: 'JMV 1/9/2001 13:08'!setPoints: pointList loopStart: startIndex loopEnd: endIndex	self delta: pointList first y - 0.5 / 5.	self highLimit: (pointList at: startIndex) y - 0.5 / 5 + 1.	self lowLimit: pointList last y - 0.5 / 5 + 1.	^super setPoints: pointList loopStart: startIndex loopEnd: endIndex! !!RandomEnvelope methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	rand := Random new.	lowLimit := 0.994.	highLimit := 1.006.	delta := 0.0002.	currValue := 1.0.	scale := 1.0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RandomEnvelope class	instanceVariableNames: ''!!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!for: aSelector	"Answer a random envelope for the given selector."	^ self new updateSelector: aSelector! !AbstractSound subclass: #RepeatingSound	instanceVariableNames: 'sound iterationCount iteration samplesPerIteration'	classVariableNames: 'CarMotorSamples'	poolDictionaries: ''	category: 'Sound-Synthesis'!!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!iterationCount	^ iterationCount! !!RepeatingSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!iterationCount: aNumber	iterationCount := aNumber.! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!sound	^ sound! !!RepeatingSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!sound: aSound	sound := aSound.! !!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sound."	^ super copy copySound! !!RepeatingSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!copySound	"Private!! Support for copying. Copy my component sound."	sound := sound copy.! !!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 15:54'!setPitch: p dur: d loudness: l	self error: 'RepeatingSounds do not support playing notes'.! !!RepeatingSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setSound: aSound iterations: anIntegerOrSymbol	"Initialize the receiver to play the given sound the given number of times. If iteration count is the symbol #forever, then repeat indefinitely."	"(RepeatingSound repeat: AbstractSound scaleTest count: 2) play"	"(RepeatingSound repeatForever: PluckedSound lowMajorScale) play"	super initialize.	sound := aSound.	iterationCount := anIntegerOrSymbol.	self reset.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	sound doControl.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"(RepeatingSound new		setSound: FMSound majorScale		iterations: 2) play"	| i count samplesNeeded |	iteration <= 0 ifTrue: [^ self].	i := startIndex.	samplesNeeded := n.	[samplesNeeded > 0] whileTrue: [		count := sound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			iterationCount == #forever				ifFalse: [					iteration := iteration - 1.					iteration <= 0 ifTrue: [^ self]].  "done"			sound reset.			count := sound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		sound mixSampleCount: count			into: aSoundBuffer			startingAt: i			leftVol: leftVol			rightVol: rightVol.		i := i + count.		samplesNeeded := samplesNeeded - count].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	super reset.	sound reset.	samplesPerIteration := sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration := 1]		ifFalse: [iteration := iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 1/18/1999 10:31'!samplesRemaining	iterationCount == #forever ifTrue: [^ 1000000].	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RepeatingSound class	instanceVariableNames: ''!!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 1/29/1999 10:01'!carMotorSound	"Return a repeating sound for the sound of a car engine."	"RepeatingSound carMotorSound play"	^ self carMotorSound: 10.0! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 1/29/1999 09:32'!carMotorSound: speed	"Return a repeating sound for the sound of a car engine running at the given speed."	"(RepeatingSound carMotorSound: 2.0) play"	CarMotorSamples ifNil: [self initializeCarMotor].	^ RepeatingSound repeatForever:		((LoopedSampledSound			unloopedSamples: CarMotorSamples			pitch: 20.0			samplingRate: 22050)				setPitch: speed dur: 100.0 loudness: 1.0)! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'stephaneducasse 2/4/2006 20:41'!initializeCarMotor	"Initialize the samples array for the sound of a car engine."	CarMotorSamples := SoundBuffer fromArray: #(36 199 190 508 332 167 253 302 788 884 1233 1145 977 904 991 1371 1361 1495 1253 1346 1696 1454 1631 1784 1752 1826 1389 1234 1202 1152 1188 1000 1048 898 724 937 1145 1537 2023 2079 2371 2156 2098 1855 1843 2208 2126 2218 1664 1457 1389 1454 1481 1458 1661 1400 1548 1499 1949 2055 2130 2220 2038 1904 1750 1993 2114 2272 2418 2101 1976 1791 2161 2690 2958 3013 2888 2798 2792 2875 3207 3627 3732 3842 3791 3836 3964 4082 4351 4550 4755 4746 4851 5180 5507 6100 6491 6533 6133 5394 4627 3886 3133 2209 1073 -368 -1876 -3170 -4067 -4641 -4963 -5049 -4922 -4634 -4147 -3544 -2805 -1962 -1219 -592 -326 -374 -627 -901 -1075 -1159 -1252 -1312 -1444 -1397 -1338 -1142 -748 -541 -350 -314 -265 -143 52 464 653 927 1269 1617 2048 2365 2654 2924 3306 3669 3855 3799 3160 2372 1629 1289 1635 1841 1838 1557 987 630 557 857 1005 868 435 -309 -1083 -1765 -2025 -2055 -2219 -2388 -2409 -2438 -2314 -2002 -1687 -1477 -1533 -1641 -1878 -1885 -1776 -1580 -1005 -525 -164 -84 396 768 1160 1788 2219 2365 1836 1435 1097 988 1326 1423 2106 2191 1965 1829 1578 1835 1429 1570 1596 1301 1357 1233 1634 2386 2597 3037 3225 3406 3339 3049 2935 2611 2428 2340 2728 2621 2994 2599 2591 3010 3341 3922 3992 3824 2982 2128 1376 1455 1437 2022 1927 1730 1841 1832 2334 2942 3183 3124 3362 3342 3549 3322 3474 3686 4164 4550 4051 3701 2742 2656 3210 4011 4641 4416 3697 2998 3382 3715 3729 3687 3375 3521 3932 4273 4172 3970 3598 3675 4879 5887 6320 5794 4623 4179 4453 5626 6412 6353 5563 4689 4683 5058 5905 6270 6218 6134 5704 5297 4087 2627 1221 -181 -1351 -2616 -4341 -6598 -8702 -9888 -10087 -9286 -8357 -7568 -6878 -6063 -4839 -3540 -2281 -1176 -315 248 409 337 -353 -1326 -2135 -2392 -2324 -2288 -2486 -3272 -3618 -3573 -2804 -1503 -604 267 808 1389 2069 2643 3328 3964 4706 5502 6136 6163 5665 4956 4491 4507 4409 4042 3132 1996 998 330 -116 -475 -877 -1370 -1250 -1048 -851 -740 -1207 -1166 -1040 -395 405 441 342 -281 -763 -799 -774 -447 -319 -190 -120 115 182 91 207 387 959 1462 1811 1767 1335 972 730 979 1157 1338 1347 807 591 232 417 696 664 1406 1512 2065 2416 2374 2539 2395 2483 2677 2674 2585 2299 1134 320 -336 -65 676 743 538 16 -374 -515 138 463 1043 1533 1786 2332 2258 2566 2663 2961 3599 3498 3518 2952 2309 2045 1667 1571 1504 1213 1118 1029 874 843 710 977 1377 1816 2236 2114 1989 1698 1618 1672 1682 1602 1382 1044 689 364 55 -24 4 322 669 948 1148 1193 1280 1463 1873 2261 2578 2654 2543 2312 1976 1772 1738 1763 1855 1834 1664 1469 1312 1399 1484 1732 1880 2004 2124 2090 2056 2000 2048 2227 2464 2670 2721 2511 2234 2056 2081 2263 2522 2737 2768 2728 2693 2711 2768 2891 3068 3182 3126 2913 2545 2171 1950 1820 1765 1710 1538 1319 1020 764 600 538 607 742 808 710 517 307 162 62 17 -8 -205 -486 -858 -1288 -1581 -1720 -1795 -1834 -1863 -1906 -1966 -1895 -1855 -1651 -1350 -1049 -721 -464 -265 -65 75 189 306 412 472 458 374 222 113 101 178 309 481 568 576 516 497 582 724 844 964 914 774 662 509 472 576 610 572 554 517 605 785 1008 1312 1555 1786 1957 2044 2081 2118 2193 2264 2328 2335 2277 2205 2098 2002 1981 1982 2017 1972 1912 1788 1611 1519 1428 1393 1367 1209 1045 842 624 564 509 465 398 172 11 -157 -264 -259 -269 -248 -249 -222 -266 -355 -372 -288 -158 -55 1 71 91 102 228 420 619 798 829 930 1012 1047 1210 1359 1531 1676 1702 1787 1809 1729 1668 1653 1721 1808 1793 1747 1616 1485 1476 1516 1751 1961 2029 2057 2006 1955 1893 1904 1960 1967 1975 1934 1827 1814 1749 1809 1947 2037 2098 2067 1970 1754 1627 1667 1759 1904 1890 1819 1747 1644 1698 1746 1834 1959 1922 1887 1864 1712 1734 1770 1895 2029 2062 2153 2132 2203 2206 2202 2194 2075 2019 1889 1923 1930 2090 2250 2335 2372 2209 2085 1902 1805 1826 1843 1804 1761 1605 1580 1680 1713 1825 1904 2097 2269 2373 2384 2235 2351 2445 2530 2610 2560 2618 2511 2445 2374 2111 1959 1760 1602 1474 1208 1021 786 688 654 573 526 409 452 566 694 746 831 914 1008 1043 821 513 214 -45 -242 -453 -723 -898 -1103 -1078 -1081 -1087 -1015 -1073 -869 -884 -720 -555 -329 -24 -63 14 -96 5 260 412 636 623 611 785 788 1001 1025 989 1162 1215 1404 1408 1305 1311 1120 1076 956 785 740 371 389 164 202 522 478 770 483 259 250 79 497 987 1288 1453 1283 1350 1436 1441 1804 1861 2059 2156 1969 2142 2148 2384 2652 2470 2383 1883 1739 1618 1475 1523 1134 1167 1031 816 674 274 251 162 301 387 23 -176 -345 -333 -198 -356 -363 -444 -421 -192 -226 -230 -239 -326 10 106 195 132 95 202 79 -68 -222 -45 429 788 954 1256 1426 1521 1704 1729 2053 1867 1581 1434 1367 1554 1386 1221 1165 1253 1571 1394 1425 1390 948 1288 999 1421 1568 1292 1478 1019 1053 591 693 520 302 314 116 847 1340 1792 1883 1582 1474 1821 2140 2486 2651 2167 1728 1380 1345 1811 1993 2052 2325 2231 2148 2271 2450 2831 2866 2908 2721 2623 2252 2025 2393 2667 3015 2817 2668 2588 2540 2736 2761 3275 3232 3252 3168 3112 3284 3138 3458 3716 3876 3928 3824 3928 4040 4330 4923 5226 5205 5183 5172 5510 5926 6225 6306 6020 5433 4448 3261 2118 959 -239 -1741 -3208 -4507 -5623 -6134 -6133 -5617 -4931 -4192 -3378 -2817 -2219 -1588 -817 -110 199 281 -5 -417 -652 -749 -679 -890 -1261 -1549 -1905 -1928 -2002 -1885 -1552 -1185 -655 -235 222 793 1424 1992 2599 2940 3081 2982 2695 2667 2771 2919 2980 2662 2146 1537 1215 1217 1374 1337 1061 790 376 250 -97 -111 5 -149 -243 -733 -936 -1395 -1810 -1781 -1762 -1500 -1716 -2039 -2318 -2398 -1907 -1592 -1422 -1900 -2619 -3034 -3024 -2335 -1429 -557 323 1051 1587 2021 2282 2438 2207 1843 1789 1482 1392 1056 742 1220 1294 1464 1641 1731 1847 1291 1682 1970 2097 2253 1624 1474 1312 1312 1873 2315 2523 2486 2323 2385 2924 3638 4341 4431 4045 3644 2945 2939 2935 2867 3411 2886 2731 2211 1405 1001 640 1077 1430 1688 1803 1857 2036 2447 3394 3628 3702 3468 3361 3782 3668 3672 4050 3895 4188 4564 4217 3965 2693 1946 1878 2245 3152 3267 3120 2670 2675 3308 4567 5358 5556 5114 3953 3653 3658 4111 4688 4262 3819 3732 4224 4771 5579 5622 5585 5613 5501 5593 5452 5570 5632 6094 5985 5579 4982 4206 3878 3683 3274 2172 698 -1224 -2821 -3890 -4742 -5518 -6463 -7297 -7730 -8054 -7991 -7508 -6683 -5163 -3562 -2162 -1401 -1000 -650 -255 344 643 475 -347 -1530 -2545 -3189 -3506 -3525 -3563 -3239 -2710 -1975 -1174 -649 117 1250 2603 3929 4750 4920 4876 4692 4897 5263 5455 5008 4285 3535 2650 2480 2198 1908 1831 1412 1060 602 80 -281 -245 -37 518 694 559 449 134 264 395 501 454 294 14 -188 -258 -603 -471 -526 -212 202 413 643 447 674 1151 2015 2779 2830 2783 2349 2213 2223 1805 1467 750 640 762 709 685 202 48 360 1103 1707 1935 1604 992 986 883 1293 1285 840 880 25 72 -201 -568 -194 -266 416 698 748 1106 930 1391 2268 2672 3350 3207 3010 3183 2888 3077 3048 2737 2684 2102 1594 1047 146 -39 -397 -420 -237 -520 -465 -526 -247 398 929 1605 2176 2568 2979 3102 3165 3206 3205 3315 3167 2841 2330 1660 1172 909 881 992 1021 1063 1098 1184 1407 1681 1927 2245 2498 2652 2755 2740 2720 2600 2599 2547 2529 2425 2327 2216 1983 1798 1578 1501 1596 1707 1778 1775 1794 1832 1945 2157 2368 2534 2679 2726 2647 2546 2482 2500 2613 2715 2858 2909 2875 2798 2847 3002 3238 3544 3763 3906 3870 3762 3684 3570 3510 3375 3115 2665 2099 1534 1114 848 744 650 462 329 147 161 282 430 614 681 701 635 505 263 -31 -284 -523 -787 -1040 -1310 -1530 -1694 -1726 -1660 -1541 -1319 -1101 -872 -661 -468 -289 -53 235 439 581 607 542 488 496 442 476 539 528 480 404 353 383 409 514 643 801 911 1039 1099 1060 1002 1008 1079 1079 1088 1043 998 953 947 1077 1232 1417 1630 1737 1807 1861 1947 2139 2352 2521 2494 2388 2251 2163 2142 2183 2246 2312 2333 2215 2167 2080 1954 1856 1767 1725 1685 1560 1366 1157 915 754 677 570 434 268 50 -48 -106 -80 23 -6 3 -105 -143 -106 -86 -10 15 72 129 151 224 269 377 540 615 755 802 841 986 1126 1263 1430 1501 1565 1592 1629 1704 1769 1780 1815 1868 1875 1853 1767 1657 1676 1777 1954 2063 2033 2006 1997 2052 2132 2218 2192 2163 2068 1935 1832 1731 1692 1644 1603 1587 1656 1704 1735 1707 1693 1778 1855 1886 1808 1854 1866 2020 2082 2051 2063 1922 1994 2055 1979 1867 1654 1725 1958 2103 2250 2210 2181 2136 1990 1769 1538 1555 1690 1847 1927 1833 1861 1845 1916 1901 1878 1827 1965 2079 2011 1813 1442 1294 1314 1438 1527 1471 1351 1346 1433 1541 1742 1882 2055 2187 2137 2094 2026 2216 2547 2788 2910 2700 2476 2276 2271 2219 2140 2106 1948 1839 1563 1271 991 871 785 695 490 237 93 101 302 452 541 637 735 773 731 667 554 479 381 262 -30 -313 -571 -871 -940 -1094 -1156 -946 -946 -789 -822 -1016 -846 -729 -380 -130 -174 -291 -393 -459 -370 -385 -488 -235 -189 -29 66 20 251 506 931 1376 1399 1348 1192 940 1022 839 916 1173 1247 1303 1207 950 888 944 1151 1385 1216 1012 762 741 964 995 1072 1129 1201 1243 1189 1214 1209 1090 1188 1226 962 840 480 309 201 8 -27 -108 19 120 122 175 188 247 298 326 490 659 638 530 299 294 391 561 749 632 677 592 520 445 175 452 195 476 279 54 216 -444 -153 -497 -42 65 -76 89 -307 613 424 736 729 692 1203 923 1051 761 782 993 912 1361 971 671 640 713 1230 870 821 292 243 774 1172 1686 1286 1348 1303 1523 1622 1578 1833 1810 1913 1658 1535 1352 1375 1673 2156 2537 2408 2275 2078 2090 2117 2030 2120 2227 2296 2388 2667 2966 3152 3134 2987 2799 2665 2686 2666 2584 2637 2572 2631 2836 3106 3325 3066 2882 2869 3046 3325 3369 3339 3398 3350 3293 3457 3587 3759 3999 4191 4413 4437 4477 4519 4628 4905 5061 5239 5014 4922 5179 5616 6008 6053 5515 4650 3634 2615 2101 1403 430 -981 -2592 -4097 -5331 -6002 -6365 -6339 -5996 -5552 -4825 -4058 -3378 -2538 -1678 -858 -70 377 250 -342 -1019 -1354 -1355 -1196 -1361 -1521 -1624 -1862 -1561 -1109 -638 -510 -705 -845 -1026 -585 -35 768 1668 2308 2850 3002 3103 3216 3453 3876 4335 4501 4065 3249 2233 1669 1518 1717 1688 1115 370 -493 -662 -599 -225 85 -153 -466 -954 -1270 -1132 -935 -978 -1481 -2039 -2683 -3353 -3678 -3673 -3362 -2780 -2386 -2281 -2137 -2034 -1498 -801 -239 351 480 608 886 1176 1592 1788 2106 2205 2010 1893 1582 1539 1597 1795 1990 2158 2092 1255 800 1029 1404 1884 2085 1537 1103 919 870 2111 3220 3367 3480 2671 2319 2914 3620 4073 3498 2841 2067 1810 2225 2669 3168 2603 1347 499 729 1563 2063 1953 1175 432 458 1393 2521 3149 3279 2822 2467 2697 3005 3756 4386 4418 4555 3662 3241 3320 3520 3914 4087 3923 2896 2532 1732 1807 2221 2972 3933 3101 2464 1657 1615 2639 3948 4718 5026 4305 3909 3815 3811 4014 3853 4090 4153 4670 4783 4527 4113 4296 4866 5695 6258 6024 5748 5089 5020 5101 4974 4353 3499 2056 779 -738 -2628 -4028 -5515 -6213 -6815 -7376 -7953 -8558 -8565 -7680 -6158 -4573 -3152 -2390 -1579 -792 -128 414 470 360 165 -390 -1164 -2225 -3460 -4085 -4255 -3862 -3277 -2975 -2731 -2390 -1656 -387 1008 2146 3014 3428 3832 4526 4822 4875 4472 3941 3954 3945 3710 2856 1848 931 619 1054 1206 877 318 -270 -412 34 160 399 532 402 655 568 472 246 -92 356 716 776 540 -331 -730 -548 -242 338 202 -72 4 -6 637 885 1005 1330 1619 2174 2350 2069 1709 1412 1476 1747 1558 1230 711 321 398 293 313 92 81 454 659 806 581 346 351 585 870 851 436 -76 -479 -756 -907 -1190 -1414 -1586 -1628 -1483 -1389 -1238 -816 -177 556 1249 1735 2074 2385 2710 3065 3264 3285 3143 2928 2692 2297 1832 1387 1022 955 1088 1101 1028 872 870 1090 1475 1976 2316 2578 2716 2705 2557 2467 2367 2328 2364 2301 2073 1686 1366 1175 1116 1199 1196 1109 962 920 934 983 1051 1258 1536 1752 1836 1770 1680 1643 1800 1954 2082 2111 1986 1885 1813 1824 1898 2088 2236 2353 2399 2340 2255 2213 2244 2350 2365 2326 2266 2154 2072 2068 2093 2130 2223 2295 2394 2515 2449 2426 2527 2778 3021 3240 3286 3216 3108 3004 3042 3106 3147 2990 2690 2282 1902 1641 1457 1359 1172 825 473 189 106 166 377 569 634 551 403 364 415 437 366 107 -242 -524 -723 -824 -959 -1100 -1264 -1381 -1408 -1252 -1072 -932 -889 -819 -581 -341 -107 56 128 156 158 185 260 284 270 324 376 391 423 449 446 429 521 569 566 584 546 589 624 594 594 584 607 725 876 976 1004 1046 1082 1193 1341 1372 1434 1446 1409 1528 1618 1747 1911 1985 2090 2092 2110 2170 2230 2360 2411 2433 2402 2317 2280 2227 2126 2017 1878 1729 1564 1406 1237 1073 957 906 841 788 706 548 437 429 449 554 653 664 582 500 486 511 519 430 339 318 294 287 265 288 299 429 605 681 822 808 887 950 1042 1240 1348 1547 1638 1752 1787 1765 1864 1949 2025 2058 1990 1921 1818 1707 1755 1810 2007 2069 2017 1840 1623 1633 1646 1803 1962 2002 1985 1838 1694 1588 1493 1551 1685 1756 1784 1604 1458 1532 1660 1898 1986 1737 1551 1457 1665 1890 2078 2066 2082 2181 2156 2167 2174 2290 2341 2314 2302 2134 2114 2054 2020 2109 1974 1916 1841 1628 1718 1718 1860 1951 1774 1893 1745 1701 1769 1541 1733 1542 1509 1547 1370 1640 1572 1480 1679 1501 1747 1697 1748 1973 1763 1949 1795 2000 2185 2249 2600 2532 2713 2672 2558 2572 2506 2691 2760 2797 2680 2299 1992 1796 1558 1444 1055 663 489 6 -197 -508 -713 -632 -763 -579 -532 -472 -253 -174 -66 75 -39 72 208 312 339 87 16 -170 -198 -166 -227 -270 -498 -495 -406 -544 -569 -766 -656 -500 -344 -121 -161 -67 -60 97 96 47 31 -76 163 173 417 465 257 332 5 48 -14 -135 124 -51 17 -190 -361 -127 -23 352 410 491 632 489 608 746 1100 1463 1473 1668 1380 1289 1319 1575 1979 1935 1824 1385 1265 1351 1528 1675 1429 1018 548 133 -254 -466 -736 -796 -815 -994 -916 -948 -584 -366 -196 -132 -119 -108 -165 12 -235 -107 -353 -349 -579 -765 -953 -1235 -888 -764 -286 -769 -804 -787 -508 255 127 169 -177 -373 -111).! !!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:14'!repeat: aSound count: anInteger	"Return a RepeatingSound that will repeat the given sound for the given number of iterations."	^ self new setSound: aSound iterations: anInteger! !!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:13'!repeatForever: aSound	"Return a RepeatingSound that will repeat the given sound forever."	^ self new setSound: aSound iterations: #forever! !AbstractSound subclass: #RestSound	instanceVariableNames: 'initialCount count'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RestSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	super duration: seconds.	count := initialCount := (seconds * self samplingRate) rounded.! !!RestSound methodsFor: 'accessing' stamp: 'di 2/17/1999 21:09'!samples	^ SoundBuffer newMonoSampleCount: initialCount! !!RestSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setDur: d	"Set rest duration in seconds."	initialCount := (d * self samplingRate asFloat) rounded.	count := initialCount.	self reset.! !!RestSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play silence for a given duration."	"(RestSound dur: 1.0) play"	count := count - n.! !!RestSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	super reset.	count := initialCount.! !!RestSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:37'!samplesRemaining	^ count! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RestSound class	instanceVariableNames: ''!!RestSound class methodsFor: 'instance creation' stamp: 'jm 3/31/1999 21:05'!dur: d	"Return a rest of the given duration."	^ self new setDur: d! !!RestSound class methodsFor: 'instance creation' stamp: 'jm 12/15/97 22:38'!pitch: p dur: d loudness: l	"Return a rest of the given duration."	"Note: This message allows one to silence one or more voices of a multi-voice piece by using RestSound as their instrument."	^ self new setDur: d! !AbstractSound subclass: #ReverbSound	instanceVariableNames: 'sound tapDelays tapGains tapCount bufferSize bufferIndex leftBuffer rightBuffer'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/7/98 22:41'!sound	^ sound! !!ReverbSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!sound: aSound	sound := aSound.! !!ReverbSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!tapDelays: delayList gains: gainList	"ReverbSound new tapDelays: #(537 691 1191) gains: #(0.07 0.07 0.07)"	| maxDelay gain d |	delayList size = gainList size		ifFalse: [self error: 'tap delay and gains lists must be the same size'].	tapCount := delayList size.	tapDelays := Bitmap new: tapCount.	tapGains := Bitmap new: tapCount.	maxDelay := 0.	1 to: tapGains size do: [:i |		tapDelays at: i put: (delayList at: i) asInteger.		gain := gainList at: i.		gain >= 1.0 ifTrue: [self error: 'reverb tap gains must be under 1.0'].		tapGains at: i put: (gain * ScaleFactor) asInteger.		d := tapDelays at: i.		d > maxDelay ifTrue: [maxDelay := d]].	bufferSize := maxDelay.	leftBuffer := SoundBuffer newMonoSampleCount: maxDelay.	rightBuffer := SoundBuffer newMonoSampleCount: maxDelay.	bufferIndex := 1.! !!ReverbSound methodsFor: 'copying' stamp: 'jm 1/21/98 14:29'!copy	"Copy my component sound."	^ super copy copySound! !!ReverbSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!copySound	"Private!! Support for copying. Copy my component sound."	sound := sound copy.	leftBuffer := leftBuffer clone.	rightBuffer := rightBuffer clone.! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 14:32'!doControl	super doControl.	sound doControl.! !!ReverbSound methodsFor: 'sound generation' stamp: 'zz 3/2/2004 08:26'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play my sound with reverberation."	sound mixSampleCount: n		into: aSoundBuffer		startingAt: startIndex		leftVol: leftVol		rightVol: rightVol.	self applyReverbTo: aSoundBuffer startingAt: startIndex count: n.! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 16:47'!reset	super reset.	sound reset.	1 to: bufferSize do: [:i |		leftBuffer at: i put: 0.		rightBuffer at: i put: 0].! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 17:02'!samplesRemaining	^ sound samplesRemaining! !!ReverbSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #tapDelays declareC: 'int *tapDelays'.	self var: #tapGains declareC: 'int *tapGains'.	self var: #leftBuffer declareC: 'short int *leftBuffer'.	self var: #rightBuffer declareC: 'short int *rightBuffer'.	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft := delayedRight := 0.		1 to: tapCount do: [:tapIndex |			i := bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i := i + bufferSize].  "wrap"			tapGain := tapGains at: tapIndex.			delayedLeft := delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight := delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j := (2 * sliceIndex) - 1.		out := (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j := j + 1.		out := (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex := (bufferIndex \\ bufferSize) + 1].! !Object subclass: #SampledInstrument	instanceVariableNames: 'sustainedSoft sustainedLoud staccatoSoft staccatoLoud sustainedThreshold loudThreshold'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!SampledInstrument commentStamp: '<historical>' prior: 0!I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!allSampleSets: sortedNotes	| keyMap |	keyMap := self midiKeyMapFor: sortedNotes.	sustainedSoft := keyMap.	sustainedLoud := keyMap.	staccatoSoft := keyMap.	staccatoLoud := keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	sustainedThreshold := 0.15.	loudThreshold := 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!loudThreshold: aNumber	loudThreshold := aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud := self midiKeyMapFor: sortedNotes.	staccatoSoft := staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!staccatoLoudSampleSet: sortedNotes	staccatoLoud := self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!staccatoSoftSampleSet: sortedNotes	staccatoSoft := self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!sustainedLoudSampleSet: sortedNotes	sustainedLoud := self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!sustainedSoftSampleSet: sortedNotes	sustainedSoft := self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!sustainedThreshold: aNumber	sustainedThreshold := aNumber asFloat.! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r := IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i := 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i := i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower := sortedNotes at: i - 1.	higher := sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total := 0.	self allNotes do: [:n |		total := total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total := total + (n leftSamples monoSampleCount * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r := OrderedCollection new: aNoteList size.	interval := (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch := 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch := n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud := self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft := self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud := self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft := self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap := Array new: 128 withAll: aNote.	sustainedLoud := oneNoteMap.	sustainedSoft := oneNoteMap.	staccatoLoud := oneNoteMap.	staccatoSoft := oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all := SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir := FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName := dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd := LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all := OrderedCollection new.	dir := FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName := dir fullNameFor: n.		info := AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern := (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap := sustainedLoud]				ifFalse: [keymap := staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap := sustainedSoft]				ifFalse: [keymap := staccatoSoft]].	keymap ifNil: [keymap := sustainedLoud].	note := (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SampledInstrument class	instanceVariableNames: ''!!SampledInstrument class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!buildSmallOrchestra	"Example of how to build a skeleton orchestra that uses less memory (about 14 MBytes)."	"SampledInstrument buildSmallOrchestra"	| dir |	AbstractSound unloadSampledTimbres.	dir := 'Tosh:Not Backed Up:Sample Library:Orchestra'.	#(clarinet oboe bassoon trombone tympani) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: dir.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].	#(flute bass) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: dir.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].	(AbstractSound soundNamed: 'bass-f') allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 2500)].	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n |		n beUnlooped.		n firstSample: (n findStartPointForThreshold: 0)].	(AbstractSound soundNamed: 'trombone-f') allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1800)].	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n | n beUnlooped].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir := orchestraDir, ':', instName.	memBefore := Smalltalk garbageCollect.	loud := SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short := SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter := Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd := SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd := SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir := orchestraDir, ':', instName, ' pizz'.	memBefore := Smalltalk garbageCollect.	sampleSet := SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter := Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd := SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir := orchestraDir, ':', instName, ' f'.	memBefore := Smalltalk garbageCollect.	sampleSet := SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter := Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd := SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !AbstractSound subclass: #SampledSound	instanceVariableNames: 'initialCount count samples originalSamplingRate samplesSize scaledIndex indexHighBits scaledIncrement'	classVariableNames: 'CoffeeCupClink DefaultSampleTable IncrementFractionBits IncrementScaleFactor NominalSamplePitch ScaledIndexOverflow SoundLibrary'	poolDictionaries: ''	category: 'Sound-Synthesis'!!SampledSound methodsFor: 'accessing' stamp: 'di 12/7/2000 16:04'!compressWith: codecClass	^ codecClass new compressSound: self! !!SampledSound methodsFor: 'accessing' stamp: 'RAA 12/24/2000 08:49'!compressWith: codecClass atRate: aSamplingRate	^ codecClass new compressSound: self atRate: aSamplingRate! !!SampledSound methodsFor: 'accessing' stamp: 'jm 3/28/98 05:46'!duration	^ initialCount asFloat / self samplingRate asFloat! !!SampledSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration: seconds	super duration: seconds.	count := initialCount := (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:51'!originalSamplingRate	^ originalSamplingRate! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/12/97 16:46'!samples	^ samples! !!SampledSound methodsFor: 'file i/o' stamp: 'stephaneducasse 2/4/2006 20:41'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."	| reverseBytes |	self samplingRate ~= originalSamplingRate ifTrue: [		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].	"optimization: if sampling rates match, just store my buffer"	reverseBytes := bigEndianFlag ~= SmalltalkImage current  isBigEndian.	reverseBytes ifTrue: [samples reverseEndianness].	(aBinaryStream isKindOf: StandardFileStream)		ifTrue: [  "optimization for files: write sound buffer directly to file"			aBinaryStream next: (samples size // 2) putAll: samples startingAt: 1]  "size in words"		ifFalse: [  "for non-file streams:"			1 to: samples monoSampleCount do: [:i | aBinaryStream int16: (samples at: i)]].	reverseBytes ifTrue: [samples reverseEndianness].  "restore to original endianness"! !!SampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!pitch: pitchNameOrNumber	| p |	p := self nameOrNumberToPitch: pitchNameOrNumber.	originalSamplingRate :=		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p := self nameOrNumberToPitch: pitchNameOrNumber.	samples := DefaultSampleTable.	samplesSize := samples size.	initialCount := (d * self samplingRate asFloat) rounded.	originalSamplingRate :=		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self loudness: vol.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setSamples: anArray samplingRate: rate	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."	"Note: There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSampleTable:)."	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."	"(SampledSound		samples: SampledSound coffeeCupClink		samplingRate: 5000) play"	"copy the array into a SoundBuffer if necessary"	anArray class isWords		ifTrue: [samples := anArray]		ifFalse: [samples := SoundBuffer fromArray: anArray].	samplesSize := samples size.	samplesSize >= SmallInteger maxVal ifTrue: [  "this is unlikely..."		self error: 'sample count must be under ',  SmallInteger maxVal printString].	originalSamplingRate := rate.	initialCount := (samplesSize * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self reset.! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!endGracefully	"See stopGracefully, which affects initialCOunt, and I don't think it should (di)."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs := 10]		ifFalse: [			env := envelopes first.			decayInMs := env attackTime + env decayTime].	count := decayInMs * self samplingRate // 1000.! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex := (startIndex + n) - 1.	outIndex := startIndex.    "index of next stereo output sample pair"	sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample := ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i := (2 * outIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * outIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].		scaledIndex := scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow := scaledIndex >> IncrementFractionBits.			indexHighBits := indexHighBits + overflow.			scaledIndex := scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex := outIndex + 1].	count := count - n.! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!playSilentlyUntil: startTime	"Used to fast foward to a particular starting time.	Overridden to be instant for sampled sounds.""true ifTrue: [^ super playSilentlyUntil: startTime]."	indexHighBits := (startTime * originalSamplingRate) asInteger.	scaledIndex := IncrementScaleFactor.	count := initialCount - (startTime * self samplingRate).	mSecsSinceStart := (startTime * 1000) asInteger.! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"Details: The sample index and increment are scaled to allow fractional increments without having to do floating point arithmetic in the inner loop."	super reset.	scaledIncrement :=		((originalSamplingRate asFloat / self samplingRate) * IncrementScaleFactor) rounded.	count := initialCount.	scaledIndex := IncrementScaleFactor.  "index of the first sample, scaled"	indexHighBits := 0.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/13/97 19:07'!samplesRemaining	^ count! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!setScaledIncrement: aNumber	scaledIncrement := (aNumber * IncrementScaleFactor) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count := (mSecs * self samplingRate) // 1000.! !!SampledSound methodsFor: 'sound tracks' stamp: 'stephaneducasse 2/4/2006 20:41'!sonogramMorph: height from: start to: stop nPoints: nPoints	"FYI:  It is very cool that we can do this, but for sound tracks on a movie,	simple volume is easier to read, easier to scale, and way faster to compute.	Code preserved here just in case it makes a useful example."	"In an inspector of a samplesSound...		self currentWorld addMorph: (self sonogramMorph: 32 from: 1 to: 50000 nPoints: 256)	"	| fft sonogramMorph data width |	fft := FFT new: nPoints.	width := stop-start//nPoints.	sonogramMorph := Sonogram new			extent: width@height			minVal: 0.0			maxVal: 1.0			scrollDelta: width.	start to: stop-nPoints by: nPoints do:		[:i |		data := fft transformDataFrom: samples startingAt: i.		data := data collect: [:v | v sqrt].  "square root compresses dynamic range"		data /= 200.0.		sonogramMorph plotColumn: data].	^ sonogramMorph	! !!SampledSound methodsFor: 'sound tracks' stamp: 'stephaneducasse 2/4/2006 20:41'!volumeForm: height from: start to: stop nSamplesPerPixel: nPerPixel	"Note: nPerPixel can be Integer or Float for pixel-perfect alignment."	"In an inspector of a samplesSound...		self currentWorld addMorph: (ImageMorph new image:			(self volumeForm: 32 from: 1 to: samples size nSamplesPerPixel: 225))	"	| volPlot width sample min max vol |	width := stop-start//nPerPixel.	volPlot := Form extent: width@height.	(start max: 1) to: (stop min: samples size)-nPerPixel by: nPerPixel do:		[:i | min:= max:= 0.		i asInteger to: (i+nPerPixel-1) asInteger by: 4 do:  "by: 4 makes it faster yet looks the same"			[:j | sample := samples at: j.			sample < min ifTrue: [min := sample].			sample > max ifTrue: [max := sample]].		vol := (max - min) * height // 65536.		volPlot fillBlack: ((i-start//nPerPixel) @ (height-vol//2) extent: 1@(vol+1))].	^ volPlot	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SampledSound class	instanceVariableNames: ''!!SampledSound class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"SampledSound initialize"	IncrementFractionBits := 16.	IncrementScaleFactor := 2 raisedTo: IncrementFractionBits.	ScaledIndexOverflow := 2 raisedTo: 29.  "handle overflow before needing LargePositiveIntegers"	self useCoffeeCupClink.	SoundLibrary ifNil: [SoundLibrary := Dictionary new].	Beeper setDefault: (self new						setSamples: self coffeeCupClink						samplingRate: 12000).! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 8/23/97 22:25'!coffeeCupClink	"Return the samples array for the sound of a spoon being tapped against a coffee cup."	CoffeeCupClink ifNil: [self initializeCoffeeCupClink].	^ CoffeeCupClink! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'stephaneducasse 2/4/2006 20:41'!initializeCoffeeCupClink	"Initialize the samples array for the sound of a spoon being tapped against a coffee cup."	"SampledSound initializeCoffeeCupClink"	| samples |	samples := #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256).	CoffeeCupClink := SoundBuffer fromArray: samples.! !!SampledSound class methodsFor: 'default sound' stamp: 'stephaneducasse 2/4/2006 20:41'!defaultSampleTable: anArray	"Set the sample table to be used as the default waveform for playing a score such as the Bach fugue. Array is assumed to contain monaural signed 16-bit sample values."	DefaultSampleTable := SoundBuffer fromArray: anArray.! !!SampledSound class methodsFor: 'default sound' stamp: 'stephaneducasse 2/4/2006 20:41'!defaultSamples: anArray repeated: n	| data |	data := WriteStream on: (SoundBuffer newMonoSampleCount: anArray size * n).	n timesRepeat: [		anArray do: [:sample | data nextPut: sample truncated]].	DefaultSampleTable := data contents.! !!SampledSound class methodsFor: 'default sound' stamp: 'stephaneducasse 2/4/2006 20:41'!nominalSamplePitch: aNumber	"Record an estimate of the normal pitch of the sampled sound."	NominalSamplePitch := aNumber.! !!SampledSound class methodsFor: 'default sound' stamp: 'stephaneducasse 2/4/2006 20:41'!useCoffeeCupClink	"Set the sample table to be used as the default waveform to the sound of a coffee cup being tapped with a spoon."	"SampledSound useCoffeeCupClink bachFugue play"	DefaultSampleTable := self coffeeCupClink.	NominalSamplePitch := 400.! !!SampledSound class methodsFor: 'instance creation' stamp: 'gk 2/24/2004 08:50'!beep	"Beep in the presence of the sound system.	Not to be used directly - use Beeper class>>beep	or Beeper class>>beepPrimitive instead."	(self new			setSamples: self coffeeCupClink			samplingRate: 12000) play			! !!SampledSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name, merging stereo to mono if necessary."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	"| snd |	 FileDirectory default fileNames do: [:n |		(n endsWith: '.aif')			ifTrue: [				snd := SampledSound fromAIFFfileNamed: n.				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	| aiffFileReader |	aiffFileReader := AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: true		skipDataChunk: false.	^ self		samples: (aiffFileReader channelData at: 1)		samplingRate: aiffFileReader samplingRate! !!SampledSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromWaveFileNamed: fileName	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"	"| snd fd |	fd := FileDirectory on:'c:\windows\media\'.	fd fileNames do: [:n |		(n asLowercase endsWith: '.wav')			ifTrue: [				snd := SampledSound fromWaveFileNamed: (fd pathName,n).				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	^self fromWaveStream: (FileStream oldFileNamed: fileName)! !!SampledSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromWaveStream: fileStream	| stream header data type channels samplingRate blockAlign bitsPerSample leftAndRight |	header := self readWaveChunk: 'fmt ' inRIFF: fileStream.	data := self readWaveChunk: 'data' inRIFF: fileStream.	fileStream close.	stream := ReadStream on: header.	type := self next16BitWord: false from: stream.	type = 1 ifFalse: [^ self error:'Unexpected wave format'].	channels := self next16BitWord: false from: stream.	(channels < 1 or: [channels > 2])		ifTrue: [^ self error: 'Unexpected number of wave channels'].	samplingRate := self next32BitWord: false from: stream.	stream skip: 4. "skip average bytes per second"	blockAlign := self next16BitWord: false from: stream.	bitsPerSample := self next16BitWord: false from: stream.	(bitsPerSample = 8 or: [bitsPerSample = 16])		ifFalse: [  "recompute bits per sample"			bitsPerSample := (blockAlign // channels) * 8].	bitsPerSample = 8		ifTrue: [data := self convert8bitUnsignedTo16Bit: data]		ifFalse: [data := self convertBytesTo16BitSamples: data mostSignificantByteFirst: false].	channels = 2 ifTrue: [		leftAndRight := data splitStereo.		^ MixedSound new			add: (self samples: leftAndRight first samplingRate: samplingRate) pan: 0.0;			add: (self samples: leftAndRight last samplingRate: samplingRate) pan: 1.0;			yourself].	^ self samples: data samplingRate: samplingRate! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 19:20'!samples: anArrayOf16BitSamples samplingRate: samplesPerSecond	"Return a SampledSound with the given samples array and sampling rate."	^ self new setSamples: anArrayOf16BitSamples samplingRate: samplesPerSecond! !!SampledSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!addLibrarySoundNamed: aString fromAIFFfileNamed: fileName	"Add a sound from the given AIFF file to the library."	"SampledSound		addLibrarySoundNamed: 'shutterClick'		fromAIFFfileNamed: '7.aif'"	"Add all .aif files in the current directory to the sound library:	| fileNames |	fileNames := FileDirectory default fileNamesMatching: '*.aif'.	fileNames do: [:fName |		SampledSound			addLibrarySoundNamed: (fName copyUpTo: $.)			fromAIFFfileNamed: fName]"	| snd |	snd := self fromAIFFfileNamed: fileName.	self addLibrarySoundNamed: aString		samples: snd samples		samplingRate: snd originalSamplingRate.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:41'!addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples. If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 4/14/2003 00:01'!assimilateSoundsFrom: aDictionary
	"assimilate sounds with new keys from the given dictionary"

	aDictionary associationsDo:
		[:assoc | (SoundLibrary includesKey: assoc key) ifFalse:
			[SoundLibrary add: assoc]]! !!SampledSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!playSoundNamed: aString	"Play the sound with given name. Do nothing if there is no sound of that name in the library."	"SampledSound playSoundNamed: 'croak'"	| snd |	snd := self soundNamed: aString.	snd ifNotNil: [snd play].	^ snd! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:40'!putCoffeeCupClinkInSoundLibrary	"SampledSound putCoffeeCupClinkInSoundLibrary"	self addLibrarySoundNamed: 'clink'		samples: self coffeeCupClink		samplingRate: 11025! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/12/97 19:46'!removeSoundNamed: aString	"Remove the sound with the given name from the sound library."	SoundLibrary removeKey: aString ifAbsent: [].! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:06'!soundLibrary	"Answer the sound library dictionary."	^ SoundLibrary! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 9/27/2001 14:46'!soundNamed: aString	"Answer the sound of the given name, or, if there is no sound of that name, put up an informer so stating, and answer nil"	"(SampledSound soundNamed: 'shutterClick') play"	^ self soundNamed: aString ifAbsent:		[self inform: aString, ' not found in the Sound Library'.		nil]! !!SampledSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!soundNamed: aString ifAbsent: aBlock	"Answer the sound of the given name, or if there is no sound of that name, answer the result of evaluating aBlock"	"(SampledSound soundNamed: 'shutterClick') play"	| entry samples |	entry := SoundLibrary		at: aString		ifAbsent:			[^ aBlock value].	entry ifNil: [^ aBlock value].	samples := entry at: 1.	samples class isBytes ifTrue: [samples := self convert8bitSignedTo16Bit: samples].	^ self samples: samples samplingRate: (entry at: 2)! !!SampledSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!soundNames	"Answer a list of sound names for the sounds stored in the sound library."	"| s |	 SampledSound soundNames asSortedCollection do: [:n |		n asParagraph display.		s := SampledSound soundNamed: n.		s ifNotNil: [s playAndWaitUntilDone]]"	^ SoundLibrary keys asArray! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 4/13/2003 20:58'!universalSoundKeys
	"Answer a list of the sound-names that are expected to be found in the SoundLibrary of every image."

	^ #('splash' 'peaks' 'clink' 'croak' 'scratch' 'chirp' 'scritch' 'warble' 'scrape' 'camera' 'coyote' 'silence' 'motor')

! !!SampledSound class methodsFor: 'sound library' stamp: 'stephaneducasse 2/4/2006 20:41'!unusedSoundNameLike: desiredName	"Pick an unused sound name based on the given string. If necessary, append digits to avoid name conflicts with existing sounds."	"SampledSound unusedSoundNameLike: 'chirp'"	| newName i |	newName := desiredName.	i := 2.	[SoundLibrary includesKey: newName] whileTrue: [		newName := desiredName, i printString.		i := i + 1].	^ newName! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	self var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'.	n := aByteArray size.	1 to: n do: [:i |		s := aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!convert8bitSignedTo16Bit: aByteArray	"Convert the given array of samples--assumed to be 8-bit signed, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed AIFF sound data."	| result |	result := SoundBuffer newMonoSampleCount: aByteArray size.	self convert8bitSignedFrom: aByteArray to16Bit: result.	^ result! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!convert8bitUnsignedTo16Bit: anArray	"Convert the given array of samples--assumed to be 8-bit unsigned, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed WAVE sound data."	| n samples s |	n := anArray size.	samples := SoundBuffer newMonoSampleCount: n.	1 to: n do: [:i |		s := anArray at: i.		samples at: i put: (s - 128 * 256)].	^ samples! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!convertBytesTo16BitSamples: aByteArray mostSignificantByteFirst: msbFirst	"Convert the given ByteArray (with the given byte ordering) into 16-bit sample buffer."	| n data src b1 b2 w |	n := aByteArray size // 2.	data := SoundBuffer newMonoSampleCount: n.	src := 1.	1 to: n do: [:i |		b1 := aByteArray at: src.		b2 := aByteArray at: src + 1.		msbFirst			ifTrue: [w := (b1 bitShift: 8) + b2]			ifFalse: [w := (b2 bitShift: 8) + b1].		w > 32767 ifTrue: [w := w - 65536].		data at: i put: w.		src := src + 2].	^ data! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!uLawDecode: aByteArray	"Convert the given array of uLaw-encoded 8-bit samples into a SoundBuffer of 16-bit signed samples."	| n out decodingTable |	n := aByteArray size.	out := SoundBuffer newMonoSampleCount: n.	decodingTable := self uLawDecodeTable.	1 to: n do: [:i | out at: i put: (decodingTable at: (aByteArray at: i) + 1)].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!uLawDecodeTable	"Return a 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"Details: This table was computed as follows:		| d encoded lastEncodedPos lastEncodedNeg |		d := Array new: 256.		lastEncodedPos := nil.		lastEncodedNeg := nil.		4095 to: 0 by: -1 do: [:s |			encoded := SampledSound uLawEncodeSample: s.			lastEncodedPos = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3).					lastEncodedPos := encoded].			encoded := encoded bitOr: 16r80.			lastEncodedNeg = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3) negated.					lastEncodedNeg := encoded]].		d "	^ #(32760 31608 30584 29560 28536 27512 26488 25464 24440 23416 22392 21368 20344 19320 18296 17272 16248 15736 15224 14712 14200 13688 13176 12664 12152 11640 11128 10616 10104 9592 9080 8568 8056 7800 7544 7288 7032 6776 6520 6264 6008 5752 5496 5240 4984 4728 4472 4216 3960 3832 3704 3576 3448 3320 3192 3064 2936 2808 2680 2552 2424 2296 2168 2040 1912 1848 1784 1720 1656 1592 1528 1464 1400 1336 1272 1208 1144 1080 1016 952 888 856 824 792 760 728 696 664 632 600 568 536 504 472 440 408 376 360 344 328 312 296 280 264 248 232 216 200 184 168 152 136 120 112 104 96 88 80 72 64 56 48 40 32 24 16 8 0 -32760 -31608 -30584 -29560 -28536 -27512 -26488 -25464 -24440 -23416 -22392 -21368 -20344 -19320 -18296 -17272 -16248 -15736 -15224 -14712 -14200 -13688 -13176 -12664 -12152 -11640 -11128 -10616 -10104 -9592 -9080 -8568 -8056 -7800 -7544 -7288 -7032 -6776 -6520 -6264 -6008 -5752 -5496 -5240 -4984 -4728 -4472 -4216 -3960 -3832 -3704 -3576 -3448 -3320 -3192 -3064 -2936 -2808 -2680 -2552 -2424 -2296 -2168 -2040 -1912 -1848 -1784 -1720 -1656 -1592 -1528 -1464 -1400 -1336 -1272 -1208 -1144 -1080 -1016 -952 -888 -856 -824 -792 -760 -728 -696 -664 -632 -600 -568 -536 -504 -472 -440 -408 -376 -360 -344 -328 -312 -296 -280 -264 -248 -232 -216 -200 -184 -168 -152 -136 -120 -112 -104 -96 -88 -80 -72 -64 -56 -48 -40 -32 -24 -16 -8 0)! !!SampledSound class methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!uLawEncode: anArray	"Convert the given array of 16-bit signed samples into a ByteArray of uLaw-encoded 8-bit samples."	| n out s |	n := anArray size.	out := ByteArray new: n.	1 to: n do: [:i |		s := anArray at: i.		s := s bitShift: -3.  "drop 4 least significant bits"		s < 0			ifTrue: [s := (self uLawEncodeSample: s negated) bitOr: 16r80]			ifFalse: [s := (self uLawEncodeSample: s)].		out at: i put: s].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:40'!uLawEncodeSample: s	"Encode the given 16-bit signed sample using the uLaw 8-bit encoding."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !!SampledSound class methodsFor: 'WAV reading' stamp: 'stephaneducasse 2/4/2006 20:41'!next16BitWord: msbFirst from: stream	"Read a 16-bit positive integer from the input stream."	"Assume: Stream has at least two bytes left."	| n |	n := stream next: 2.	^msbFirst		ifTrue:[(n at: 1) * 256 + (n at: 2)]		ifFalse:[(n at: 2) * 256 + (n at: 1)]! !!SampledSound class methodsFor: 'WAV reading' stamp: 'stephaneducasse 2/4/2006 20:41'!next32BitWord: msbFirst from: stream	"Read a 32-bit positive integer from the input stream."	"Assume: Stream has at least four bytes left."	| n |	n := stream next: 4.	^msbFirst		ifTrue:[(n at: 1) * 256 + (n at: 2) * 256 + (n at: 3) * 256 + (n at: 4)]		ifFalse:[(n at: 4) * 256 + (n at: 3) * 256 + (n at: 2) * 256 + (n at: 1)]! !!SampledSound class methodsFor: 'WAV reading' stamp: 'stephaneducasse 2/4/2006 20:41'!readWaveChunk: chunkType inRIFF: stream	"Search the stream for a format chunk of the given type and return its contents."	| id count |	stream reset; binary.	stream skip: 8.  "skip 'RIFF' and total length"	id := (stream next: 4) asString.  "contents type"	id = 'WAVE' ifFalse: [^ ''].     "content type must be WAVE"	"search for a chunk of the given type"	[id := (stream next: 4) asString.	 count := self next32BitWord: false from: stream.	 id = chunkType] whileFalse: [		"skip this chunk, rounding length up to a word boundary"		stream skip: (count + 1 bitAnd: 16rFFFFFFFE).		stream atEnd ifTrue: [^ '']].	^ stream next: count  "return raw chunk data"! !AbstractSound subclass: #SequentialSound	instanceVariableNames: 'sounds currentIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!SequentialSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!duration	"Answer the duration of this sound in seconds."	"7 dec 2000 - handle compressed sounds. better way??"	| dur |	dur := 0.	sounds do: [:snd | dur := dur + snd asSound duration].	^ dur! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:36'!sounds	^ sounds! !!SequentialSound methodsFor: 'composition'!, aSound	"Return the concatenation of the receiver and the argument sound."	^ self add: aSound! !!SequentialSound methodsFor: 'composition' stamp: 'stephaneducasse 2/4/2006 20:41'!add: aSound	sounds := sounds copyWith: aSound.! !!SequentialSound methodsFor: 'composition' stamp: 'di 12/7/2000 16:03'!compressWith: codecClass	^ self copy transformSounds: [:s | s compressWith: codecClass]! !!SequentialSound methodsFor: 'composition' stamp: 'RAA 12/24/2000 08:42'!compressWith: codecClass atRate: aSamplingRate	^ self copy transformSounds: [:s | s compressWith: codecClass atRate: aSamplingRate]! !!SequentialSound methodsFor: 'composition' stamp: 'stephaneducasse 2/4/2006 20:41'!pruneFinishedSounds	"Remove any sounds that have been completely played."	| newSnds |	(currentIndex > 1 and: [currentIndex < sounds size]) ifFalse: [^ self].	newSnds := sounds copyFrom: currentIndex to: sounds size.	currentIndex := 1.	sounds := newSnds.! !!SequentialSound methodsFor: 'composition' stamp: 'stephaneducasse 2/4/2006 20:41'!removeFirstCompleteSoundOrNil	"Remove the first sound if it has been completely recorded."	| firstSound |	sounds size > 0 ifFalse: [^ nil].	firstSound := sounds first.	sounds := sounds copyFrom: 2 to: sounds size.	^firstSound! !!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:10'!copy	"Copy my component sounds."	^ super copy copySounds! !!SequentialSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!copySounds	"Private!! Support for copying. Copy my component sounds."	sounds := sounds collect: [:s | s copy].! !!SequentialSound methodsFor: 'copying' stamp: 'stephaneducasse 2/4/2006 20:41'!transformSounds: tfmBlock	"Private!! Support for copying. Copy my component sounds."	sounds := sounds collect: [:s | tfmBlock value: s].! !!SequentialSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	super initialize.	sounds := Array new.	currentIndex := 0.! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:41'!doControl	super doControl.	currentIndex > 0		ifTrue: [(sounds at: currentIndex) doControl].! !!SequentialSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"PluckedSound chromaticScale play"	| finalIndex i snd remaining count |	currentIndex = 0 ifTrue: [^ self].  "already done"	finalIndex := (startIndex + n) - 1.	i := startIndex.	[i <= finalIndex] whileTrue: [		snd := (sounds at: currentIndex).		[(remaining := snd samplesRemaining) <= 0] whileTrue: [			"find next undone sound"			currentIndex < sounds size				ifTrue: [					currentIndex := currentIndex + 1.					snd := (sounds at: currentIndex)]				ifFalse: [					currentIndex := 0.					^ self]].  "no more sounds"		count := (finalIndex - i) + 1.		remaining < count ifTrue: [count := remaining].		snd mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i := i + count].! !!SequentialSound methodsFor: 'sound generation' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	super reset.	sounds do: [:snd | snd reset].	sounds size > 0 ifTrue: [currentIndex := 1].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47'!samplesRemaining	currentIndex = 0		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !ImageMorph subclass: #Sonogram	instanceVariableNames: 'lastX scrollDelta columnForm minVal maxVal pixValMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!Sonogram commentStamp: '<historical>' prior: 0!Sonograms are imageMorphs that will repeatedly plot arrays of values as black on white columns moving to the right in time and scrolling left as necessary.!!Sonogram methodsFor: 'all' stamp: 'stephaneducasse 2/4/2006 20:41'!extent: extent minVal: min maxVal: max scrollDelta: d	minVal := min.	maxVal := max.	scrollDelta := d.	self extent: extent." try following with scrolldelta = 1, 20, 200	| s data |	s := Sonogram new extent: 200@50				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.	World addMorph: s.	data := (1 to: 133) collect: [:i | 0.0].	1 to: 300 do:		[:i | data at: (i\\133)+1 put: 1.0.		s plotColumn: data.		data at: (i\\133)+1 put: 0.0.		World doOneCycleNow].	s delete	"! !!Sonogram methodsFor: 'all' stamp: 'jdl 3/28/2003 09:30'!plotColumn: dataArray 	| chm1 i normVal r |	columnForm unhibernate.	chm1 := columnForm height - 1.	0 to: chm1		do: 			[:y | 			i := y * (dataArray size - 1) // chm1 + 1.			normVal := ((dataArray at: i) - minVal) / (maxVal - minVal).			normVal := normVal max: 0.0.			normVal := normVal min: 1.0.			columnForm bits at: chm1 - y + 1				put: (pixValMap at: (normVal * 255.0) truncated + 1)].	(lastX := lastX + 1) > (image width - 1) ifTrue: [self scroll].	image 		copy: (r := lastX @ 0 extent: 1 @ image height)		from: (32 // image depth - 1) @ 0		in: columnForm		rule: Form over.	"self changed."	self invalidRect: (r translateBy: self position)! !!Sonogram methodsFor: 'all' stamp: 'stephaneducasse 2/4/2006 20:41'!scroll	image copy: (scrollDelta@0 extent: (image width-scrollDelta)@image height)			from: image to: 0@0 rule: Form over.	lastX := lastX - scrollDelta.	self changed! !!Sonogram methodsFor: 'geometry' stamp: 'stephaneducasse 2/4/2006 20:41'!extent: newExtent	super image: (Form extent: newExtent depth: Display depth).	lastX := -1.	columnForm := Form extent: (32//image depth)@(image height) depth: image depth.	pixValMap := ((1 to: 256) collect:			[:i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])		as: Bitmap.! !ArrayedCollection variableWordSubclass: #SoundBuffer	instanceVariableNames: ''	classVariableNames: 'SineTable'	poolDictionaries: ''	category: 'Sound-Synthesis'!!SoundBuffer commentStamp: '<historical>' prior: 0!SoundBuffers store 16 bit unsigned quantities.  !!SoundBuffer methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 2! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:00'!monoSampleCount	"Return the number of monaural 16-bit samples that fit into this SoundBuffer."	^ super size * 2! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:28'!size	"Return the number of 16-bit sound samples that fit in this sound buffer. To avoid confusion, it is better to get the size of SoundBuffer using monoSampleCount or stereoSampleCount."	^ self monoSampleCount! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:01'!stereoSampleCount	"Return the number of stereo slices that fit into this SoundBuffer. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ super size! !!SoundBuffer methodsFor: 'as yet unclassified' stamp: 'RAA 7/11/2000 11:31'!writeOnGZIPByteStream: aStream 		aStream nextPutAllWordArray: self! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'stephaneducasse 2/4/2006 20:41'!restoreEndianness	"This word object was just read in from a stream.  It was stored in Big Endian (Mac) format.  Swap each pair of bytes (16-bit word), if the current machine is Little Endian.	Why is this the right thing to do?  We are using memory as a byteStream.  High and low bytes are reversed in each 16-bit word, but the stream of words ascends through memory.  Different from a Bitmap."	| hack blt |	SmalltalkImage current  isLittleEndian ifTrue: [		"The implementation is a hack, but fast for large ranges"		hack := Form new hackBits: self.		blt := (BitBlt toForm: hack) sourceForm: hack.		blt combinationRule: Form reverse.  "XOR"		blt sourceY: 0; destY: 0; height: self size; width: 1.		blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"		blt sourceX: 1; destX: 0; copyBits.		blt sourceX: 0; destX: 1; copyBits.		blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"		blt sourceX: 3; destX: 2; copyBits.		blt sourceX: 2; destX: 3; copyBits].! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'stephaneducasse 2/4/2006 20:41'!reverseEndianness	"Swap the bytes of each 16-bit word, using a fast BitBlt hack."	| hack blt |	hack := Form new hackBits: self.	blt := (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 1.	blt sourceX: 0; destX: 1; copyBits.  "Exchange bytes 0 and 1"	blt sourceX: 1; destX: 0; copyBits.	blt sourceX: 0; destX: 1; copyBits.	blt sourceX: 2; destX: 3; copyBits.  "Exchange bytes 2 and 3"	blt sourceX: 3; destX: 2; copyBits.	blt sourceX: 2; destX: 3; copyBits.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/2/97 16:07'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	"Note: Since 16-bit word arrays are not built into the virtual machine, this primitive fills by 32-bit words."	<primitive: 145>	self errorImproperStore.! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount := self monoSampleCount.	bytes := ByteArray new: 2 * sampleCount.	dst := 0.	1 to: sampleCount do: [:src |		s := self at: src.		bytes at: (dst := dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst := dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!averageEvery: nSamples from: anotherBuffer upTo: inCount	| fromIndex sum |	fromIndex := 1.	1 to: inCount // nSamples do: [ :i |		sum := 0.		nSamples timesRepeat: [			sum := sum + (anotherBuffer at: fromIndex).			fromIndex := fromIndex + 1.		].		self at: i put: sum // nSamples.	].! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n := self monoSampleCount.	resultBuf := SoundBuffer newMonoSampleCount: n // 2.	j := 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j := j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j := j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n := self monoSampleCount.	resultBuf := SoundBuffer newMonoSampleCount: n // 2.	j := 0.	1 to: n by: 2 do: [:i | resultBuf at: (j := j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n := self monoSampleCount.	resultBuf := SoundBuffer newMonoSampleCount: n // 2.	j := 0.	2 to: n by: 2 do: [:i | resultBuf at: (j := j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfFirstSampleOver: threshold	"Return the index of the first sample whose absolute value is over the given threshold value. Return an index one greater than my size if no sample is over the threshold."	1 to: self size do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ self size + 1! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfLastSampleOver: threshold	"Return the index of the last sample whose absolute value is over the given threshold value. Return zero if no sample is over the threshold."	self size to: 1 by: -1 do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ 0! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!lowPassFiltered	"Answer a simple low-pass filtered copy of this buffer. Assume it is monophonic."	| sz out last this |	sz := self monoSampleCount.	out := self clone.	last := self at: 1.	2 to: sz do: [:i |		this := self at: i.		out at: i put: (this + last) // 2.		last := this].	^ out! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!mergeStereo	"Answer a new SoundBuffer half the size of the receiver that mixes the left and right stereo channels of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n := self monoSampleCount.	resultBuf := SoundBuffer newMonoSampleCount: n // 2.	j := 0.	1 to: n by: 2 do: [:i | resultBuf at: (j := j + 1) put: (((self at: i) + (self at: i + 1)) // 2)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!normalized: percentOfFullVolume	"Increase my amplitudes so that the highest peak is the given percent of full volume. For example 's normalized: 50' would normalize to half of full volume."	| peak s mult |	peak := 0.	1 to: self size do: [:i |		s := (self at: i) abs.		s > peak ifTrue: [peak := s]].	mult := (32767.0 * percentOfFullVolume) / (100.0 * peak).	1 to: self size do: [:i | self at: i put: (mult * (self at: i)) asInteger].! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!saveAsAIFFFileSamplingRate: rate on: aBinaryStream	"Store this mono sound buffer in AIFF file format with the given sampling rate on the given stream."	| sampleCount s swapBytes |	sampleCount := self monoSampleCount.	aBinaryStream nextPutAll: 'FORM' asByteArray.	aBinaryStream nextInt32Put: (2 * sampleCount) + ((7 * 4) + 18).	aBinaryStream nextPutAll: 'AIFF' asByteArray.	aBinaryStream nextPutAll: 'COMM' asByteArray.	aBinaryStream nextInt32Put: 18.	aBinaryStream nextNumber: 2 put: 1.  "channels"	aBinaryStream nextInt32Put: sampleCount.	aBinaryStream nextNumber: 2 put: 16.  "bits/sample"	self storeExtendedFloat: rate on: aBinaryStream.	aBinaryStream nextPutAll: 'SSND' asByteArray.	aBinaryStream nextInt32Put: (2 * sampleCount) + 8.	aBinaryStream nextInt32Put: 0.	aBinaryStream nextInt32Put: 0.	(aBinaryStream isKindOf: StandardFileStream) ifTrue: [		"optimization: write sound buffer directly to file"		swapBytes := SmalltalkImage current  isLittleEndian.		swapBytes ifTrue: [self reverseEndianness].  "make big endian"		aBinaryStream next: (self size // 2) putAll: self startingAt: 1.  "size in words"		swapBytes ifTrue: [self reverseEndianness].  "revert to little endian"		^ self].	1 to: sampleCount do: [:i |		s := self at: i.		aBinaryStream nextPut: ((s bitShift: -8) bitAnd: 16rFF).		aBinaryStream nextPut: (s bitAnd: 16rFF)].! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!splitStereo	"Answer an array of two SoundBuffers half the size of the receiver consisting of the left and right channels of the receiver (which is assumed to contain stereo sound data)."	| n leftBuf rightBuf leftIndex rightIndex |	n := self monoSampleCount.	leftBuf := SoundBuffer newMonoSampleCount: n // 2.	rightBuf := SoundBuffer newMonoSampleCount: n // 2.	leftIndex := rightIndex := 0.	1 to: n by: 2 do: [:i |		leftBuf at: (leftIndex := leftIndex + 1) put: (self at: i).		rightBuf at: (rightIndex := rightIndex + 1) put: (self at: i + 1)].	^ Array with: leftBuf with: rightBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!storeExtendedFloat: aNumber on: aBinaryStream	"Store an Apple extended-precision 80-bit floating point number on the given stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| n isNeg exp mantissa |	n := aNumber asFloat.	isNeg := false.	n < 0.0 ifTrue: [		n := 0.0 - n.		isNeg := true].	exp := (n log: 2.0) ceiling.	mantissa := (n * (2 raisedTo: 64 - exp)) truncated.	exp := exp + 16r4000 - 2.  "not sure why the -2 is needed..."	isNeg ifTrue: [exp := exp bitOr: 16r8000].  "set sign bit"	aBinaryStream nextPut: ((exp bitShift: -8) bitAnd: 16rFF).	aBinaryStream nextPut: (exp bitAnd: 16rFF).	8 to: 1 by: -1 do: [:i | aBinaryStream nextPut: (mantissa digitAt: i)].! !!SoundBuffer methodsFor: 'utilities' stamp: 'stephaneducasse 2/4/2006 20:41'!trimmedThreshold: threshold	| start end |	start := self indexOfFirstSampleOver: threshold.	end :=  self indexOfLastSampleOver: threshold.	start > end ifTrue: [^ SoundBuffer new].	start := (start - 200) max: 1.	end := (end + 200) min: self size.	^ self copyFrom: start to: end! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundBuffer class	instanceVariableNames: ''!!SoundBuffer class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"Build a sine wave table."	"SoundBuffer initialize"	| tableSize radiansPerStep peak |	tableSize := 4000.	SineTable := self newMonoSampleCount: tableSize.	radiansPerStep := (2.0 * Float pi) / tableSize asFloat.	peak := ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!SoundBuffer class methodsFor: 'class initialization' stamp: 'ads 7/31/2003 11:13'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'RAA 12/30/2000 18:20'!averageEvery: nSamples from: anotherBuffer upTo: inCount	^(self newMonoSampleCount: inCount // nSamples)		averageEvery: nSamples 		from: anotherBuffer 		upTo: inCount! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromArray: anArray	"Return a new SoundBuffer whose contents are copied from the given Array or ByteArray."	| new |	new := SoundBuffer newMonoSampleCount: anArray size.	1 to: anArray size do: [:i | new at: i put: (anArray at: i)].	^ new! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!fromByteArray: aByteArray	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."	| n buf src w |	n := aByteArray size // 2.	buf := SoundBuffer newMonoSampleCount: n.	src := 1.	1 to: n do: [:i |		w := ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).		w > 32767 ifTrue: [w := w - 65536].		buf at: i put: w.		src := src + 2].	^ buf! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 13:25'!new: anInteger	"See the comment in newMonoSampleCount:. To avoid confusion, it is best to create new instances using newMonoSampleCount: or newStereoSampleCount:."	^ self newMonoSampleCount: anInteger! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:44'!newMonoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of monaural samples (i.e., 16-bit words)."	"Details: The size is rounded up to an even number, since the underlying representation is in terms of 32-bit words."	^ self basicNew: (anInteger + 1) // 2! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:52'!newStereoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of stereo slices. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ self basicNew: anInteger! !!SoundBuffer class methodsFor: 'objects from disk' stamp: 'stephaneducasse 2/4/2006 20:41'!startUp	"Check if the word order has changed from the last save."	| la |	la := ShortIntegerArray classPool at: #LastSaveOrder.	((la at: 2) = 42 and: [(la at: 1) = 13]) 		ifTrue: [^self swapHalves]. "Reverse the two 16-bit halves."				"Another reversal happened automatically which reversed the bytes."! !!SoundBuffer class methodsFor: 'objects from disk' stamp: 'nk 2/22/2005 15:29'!startUpFrom: anImageSegment 	"In this case, do we need to swap word halves when reading this segment?"	^SmalltalkImage current endianness ~~ anImageSegment endianness 		ifTrue: [Message selector: #swapHalves	"will be run on each instance"]		ifFalse: [nil]! !Object subclass: #SoundCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!SoundCodec commentStamp: '<historical>' prior: 0!I am an abstract class that describes the protocol for sound codecs. Each codec (the name stems from "COder/DECoder") describes a particular algorithm for compressing and decompressing sound data. Most sound codecs are called 'lossy' because they lose information; the decompressed sound data is not exactly the same as the original data.!!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!compressAndDecompress: aSound	"Compress and decompress the given sound. Useful for testing."	"(MuLawCodec new compressAndDecompress: (SampledSound soundNamed: 'camera')) play"	^ (self compressSound: aSound) asSound! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'stephaneducasse 2/4/2006 20:41'!compressSound: aSound	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels |	compressed := CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		channels := Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: aSound samples).		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: 1;			loopEnd: aSound samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels := Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels := Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'stephaneducasse 2/4/2006 20:41'!compressSound: aSound atRate: desiredSampleRate	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels samples newRate ratio buffer |	compressed := CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		(desiredSampleRate isNil or: 				[(ratio := aSound originalSamplingRate // desiredSampleRate) <= 1]) ifTrue: [			samples := aSound samples.			newRate := aSound originalSamplingRate.		] ifFalse: [			buffer := aSound samples.			samples := SoundBuffer 				averageEvery: ratio 				from: buffer 				upTo: buffer monoSampleCount.			newRate := aSound originalSamplingRate / ratio.		].		channels := Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: samples).		compressed			channels: channels;			samplingRate: newRate;			firstSample: 1;			loopEnd: samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels := Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels := Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'stephaneducasse 2/4/2006 20:41'!decompressSound: aCompressedSound	"Decompress the entirety of the given compressed sound with this codec and answer the resulting sound."	| channels sound |	channels := aCompressedSound channels		collect: [:compressed | self decodeCompressedData: compressed].	'SampledSound' = aCompressedSound soundClassName ifTrue: [		sound := SampledSound			samples: channels first			samplingRate: (aCompressedSound samplingRate).		sound loudness: aCompressedSound gain.		^ sound].	'LoopedSampledSound' = aCompressedSound soundClassName ifTrue: [		aCompressedSound loopLength = 0			ifTrue: [				sound := LoopedSampledSound					unloopedSamples: channels first					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate]			ifFalse: [				sound := LoopedSampledSound					samples: channels first					loopEnd: aCompressedSound loopEnd					loopLength: aCompressedSound loopLength					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate].		channels size > 1 ifTrue: [sound rightSamples: channels last].		sound			firstSample: aCompressedSound firstSample;			gain: aCompressedSound gain.		sound			setPitch: 100.0			dur: (channels first size / aCompressedSound samplingRate)			loudness: 1.0.		^ sound].	self error: 'unknown sound class'.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 14:23'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:38'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:39'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:30'!reset	"Reset my encoding and decoding state. Optional. This default implementation does nothing."! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:45'!samplesPerFrame	"Answer the number of sound samples per compression frame."	self subclassResponsibility.! !!SoundCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!decodeCompressedData: aByteArray	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."	| frameCount result increments |	frameCount := self frameCount: aByteArray.	result := SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.	self reset.	increments := self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [		self error: 'implementation problem; increment sizes should match buffer sizes'].	^ result! !!SoundCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!encodeSoundBuffer: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i lastIncs |	frameSize := self samplesPerFrame.	fullFrameCount := aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples := aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	codeFrameSize := self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue:		["Allow room for 1 byte per sample for variable-length compression"		codeFrameSize := frameSize].	lastFrameSamples > 0		ifTrue: [result := ByteArray new: (fullFrameCount + 1) * codeFrameSize]		ifFalse: [result := ByteArray new: fullFrameCount * codeFrameSize].	self reset.	increments := self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame := SoundBuffer newMonoSampleCount: frameSize.		i := fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i := i + 1))].		lastIncs := self encodeFrames: 1 from: finalFrame at: 1 into: result at: 1 + increments second.		increments := Array with: increments first + lastIncs first							with: increments second + lastIncs second].	increments second < result size		ifTrue: [^ result copyFrom: 1 to: increments second]		ifFalse: [^ result]! !!SoundCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!frameCount: aByteArray	"Compute the frame count for this byteArray.  This default computation will have to be overridden by codecs with variable frame sizes."	| codeFrameSize |	codeFrameSize := self bytesPerEncodedFrame.	(aByteArray size \\ codeFrameSize) = 0 ifFalse:		[self error: 'encoded buffer is not an even multiple of the encoded frame size'].	^ aByteArray size // codeFrameSize! !SoundCodec subclass: #ADPCMCodec	instanceVariableNames: 'predicted index deltaSignMask deltaValueMask deltaValueHighBit frameSizeMask currentByte bitPosition byteIndex encodedBytes samples rightSamples sampleIndex bitsPerSample stepSizeTable indexTable'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!ADPCMCodec commentStamp: '<historical>' prior: 0!This is a simple ADPCM (adapative delta pulse code modulation) codec. This is a general audio codec that compresses speech, music, or sound effects equally well, and works at any sampling rate (i.e., it contains no frequency-sensitive filters). It compresses 16-bit sample data down to 5, 4, 3, or 2 bits per sample, with lower fidelity and increased noise at the lowest bit rates. Although it does not deliver state-of-the-art compressions, the algorithm is small, simple, and extremely fast, since the encode/decode primitives have been translated into C primitives.This codec will also encode and decode all Flash .swf file compressed sound formats, both mono and stereo. (Note: stereo Flash compression is not yet implemented, but stereo decompression works.)!!ADPCMCodec methodsFor: 'bit streaming' stamp: 'stephaneducasse 2/4/2006 20:40'!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	self inline: true.	result := 0.	remaining := n.	[true] whileTrue: [		shift := remaining - bitPosition.		result := result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining := remaining - bitPosition.							currentByte := (encodedBytes at: (byteIndex := byteIndex + 1)).				bitPosition := 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition := bitPosition - remaining.				"mask out the consumed bits:"				currentByte := currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]].! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'stephaneducasse 2/4/2006 20:40'!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	self inline: true.	buf := anInteger.	bufBits := n.	[true] whileTrue: [		bitsAvailable := 8 - bitPosition.		shift := bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte := currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte.				bitPosition := 0.				currentByte := 0.				"clear saved high bits of buf:"				buf := buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits := bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition := bitPosition + bufBits.				^ self]].! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data."	"Note: When used as a normal codec, the frame size is always 8 samples which results in (8 * bitsPerSample) / 8 = bitsPerSample bytes."	| bitCount |	frameSizeMask = 0 ifTrue: [^ bitsPerSample].	"Following assumes mono:"	bitCount := 16 + 6 + ((self samplesPerFrame - 1) * bitsPerSample).	^ (bitCount + 7) // 8! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!compressAndDecompress: aSound	"Compress and decompress the given sound. Overridden to use same bits per sample for both compressing and decompressing."	| compressed decoder |	compressed := self compressSound: aSound.	decoder := self class new		initializeForBitsPerSample: bitsPerSample		samplesPerFrame: 0.	^ decoder decompressSound: compressed! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	encodedBytes := srcByteArray.	byteIndex := srcIndex - 1.	bitPosition := 0.	currentByte := 0.	samples := dstSoundBuffer.	sampleIndex := dstIndex - 1.	self privateDecodeMono: (frameCount * self samplesPerFrame).	^ Array with: (byteIndex - (srcIndex - 1)) with: (sampleIndex - (dstIndex - 1))! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	samples := srcSoundBuffer.	sampleIndex := srcIndex - 1.	encodedBytes := dstByteArray.	byteIndex := dstIndex - 1.	bitPosition := 0.	currentByte := 0.	self privateEncodeMono: (frameCount * self samplesPerFrame).	^ Array with: frameCount with: (byteIndex - (dstIndex - 1))! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 12/14/2001 11:21'!reset	self resetForMono.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!resetForMono	"Reset my encoding and decoding state for mono."	predicted := 0.	index := 0.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'stephaneducasse 2/4/2006 20:40'!resetForStereo	"Reset my encoding and decoding state for stereo."	"keep state as SoundBuffers to allow fast access from primitive"	predicted := SoundBuffer new: 2.	index := SoundBuffer new: 2.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/27/1999 08:34'!samplesPerFrame	"Answer the number of sound samples per compression frame."	frameSizeMask > 0 ifTrue: [^ frameSizeMask + 1].	^ 8  "frame size when there are no running headers"! !!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 06:26'!decode: aByteArray bitsPerSample: bits	^ self		decode: aByteArray		sampleCount: (aByteArray size * 8) // bits		bitsPerSample: bits		frameSize: 0		stereo: false! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!decode: aByteArray sampleCount: count bitsPerSample: bits frameSize: frameSize stereo: stereoFlag	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.	encodedBytes := aByteArray.	byteIndex := 0.	bitPosition := 0.	currentByte := 0.	stereoFlag		ifTrue: [			self resetForStereo.			samples := SoundBuffer newMonoSampleCount: count.			rightSamples := SoundBuffer newMonoSampleCount: count.			sampleIndex := 0.			self privateDecodeStereo: count.			^ Array with: samples with: rightSamples]		ifFalse: [			samples := SoundBuffer newMonoSampleCount: count.			sampleIndex := 0.			self privateDecodeMono: count.			^ samples]! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!decodeFlash: aByteArray sampleCount: sampleCount stereo: stereoFlag	| bits |	encodedBytes := aByteArray.	byteIndex := 0.	bitPosition := 0.	currentByte := 0.	bits := 2 + (self nextBits: 2).  "bits per sample"	self initializeForBitsPerSample: bits samplesPerFrame: 4096.	stereoFlag		ifTrue: [			self resetForStereo.			samples := SoundBuffer newMonoSampleCount: sampleCount.			rightSamples := SoundBuffer newMonoSampleCount: sampleCount.			sampleIndex := 0.			self privateDecodeStereo: sampleCount.			^ Array with: samples with: rightSamples]		ifFalse: [			samples := SoundBuffer newMonoSampleCount: sampleCount.			sampleIndex := 0.			self privateDecodeMono: sampleCount.			^ Array with: samples].! !!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 08:59'!encode: aSoundBuffer bitsPerSample: bits	^ self		encodeLeft: aSoundBuffer		right: nil		bitsPerSample: bits		frameSize: 0		forFlash: false! !!ADPCMCodec methodsFor: 'private' stamp: 'jm 3/28/1999 08:58'!encodeFlashLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits	^ self		encodeLeft: leftSoundBuffer		right: rightSoundBuffer		bitsPerSample: bits		frameSize: 4096		forFlash: true! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!encodeLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits frameSize: frameSize forFlash: flashFlag	| stereoFlag sampleCount sampleBitCount bitCount |	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.	stereoFlag := rightSoundBuffer notNil.	sampleCount := leftSoundBuffer monoSampleCount.	stereoFlag		ifTrue: [sampleBitCount := 2 * (sampleCount * bitsPerSample)]		ifFalse: [sampleBitCount := sampleCount * bitsPerSample].	bitCount := sampleBitCount +		(self headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag).	encodedBytes := ByteArray new: ((bitCount / 8) ceiling roundUpTo: self bytesPerEncodedFrame).	byteIndex := 0.	bitPosition := 0.	currentByte := 0.	flashFlag ifTrue: [self nextBits: 2 put: bits - 2].	stereoFlag		ifTrue: [			samples := Array with: leftSoundBuffer with: rightSoundBuffer.			sampleIndex := Array with: 0 with: 0.			self privateEncodeStereo: sampleCount]		ifFalse: [			samples := leftSoundBuffer.			sampleIndex := 0.			self privateEncodeMono: sampleCount].	^ encodedBytes! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag	"Answer the number of extra header bits required for the given number of samples. This will be zero if I am not using frame headers."	| frameCount bitsPerHeader |	frameSizeMask = 0 ifTrue: [^ 0].	frameCount := (sampleCount / self samplesPerFrame) ceiling.	bitsPerHeader := 16 + 6.	stereoFlag ifTrue: [bitsPerHeader := 2 * bitsPerHeader].	^ frameCount * bitsPerHeader! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash actually computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	self inline: true.	diff := nextSample - thisSample.	diff < 0 ifTrue: [diff := 0 - diff].	bestIndex := 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex := j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!initializeForBitsPerSample: sampleBits samplesPerFrame: frameSize	self resetForMono.	stepSizeTable := #(7 8 9 10 11 12 13 14 16 17 19 21 23 25 28 31 34 37 41 45 50 55 60 66 73 80 88 97 107 118 130 143 157 173 190 209 230 253 279 307 337 371 408 449 494 544 598 658 724 796 876 963 1060 1166 1282 1411 1552 1707 1878 2066 2272 2499 2749 3024 3327 3660 4026 4428 4871 5358 5894 6484 7132 7845 8630 9493 10442 11487 12635 13899 15289 16818 18500 20350 22385 24623 27086 29794 32767).	indexTable := nil.	sampleBits = 2 ifTrue: [		indexTable := #(-1 2)].	sampleBits = 3 ifTrue: [		indexTable := #(-1 -1 2 4)].	sampleBits = 4 ifTrue: [		indexTable := #(-1 -1 -1 -1 2 4 6 8)].	sampleBits = 5 ifTrue: [		indexTable := #(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16)].	indexTable ifNil: [self error: 'unimplemented bits/sample'].	bitsPerSample := sampleBits.	deltaSignMask := 1 bitShift: bitsPerSample - 1.	deltaValueMask := deltaSignMask - 1.	deltaValueHighBit := deltaSignMask / 2.	frameSize <= 1		ifTrue: [frameSizeMask := 0]		ifFalse: [			(frameSize = (1 bitShift: frameSize highBit - 1))				ifFalse: [self error: 'frameSize must be a power of two'].			frameSizeMask := frameSize - 1].	"keep as SoundBuffer to allow fast access from primitive"	indexTable := SoundBuffer fromArray: indexTable.	stepSizeTable := SoundBuffer fromArray: stepSizeTable.! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted := self nextBits: 16.				predicted > 32767 ifTrue: [predicted := predicted - 65536].				index := self nextBits: 6.				samples at: (sampleIndex := sampleIndex + 1) put: predicted]			ifFalse: [				delta := self nextBits: bitsPerSample.				step := stepSizeTable at: index + 1.				predictedDelta := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta := predictedDelta + step].					step := step bitShift: -1.					bit := bit bitShift: -1].				predictedDelta := predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted := predicted - predictedDelta]					ifFalse: [predicted := predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted := 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].				index := index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index := 0]					ifFalse: [index > 88 ifTrue: [index := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	self var: #rightSamples declareC: 'short int *rightSamples'.	self var: #predicted declareC: 'short int *predicted'.	self var: #index declareC: 'short int *index'.	"make local copies of decoder state variables"	predictedLeft := predicted at: 1.	predictedRight := predicted at: 2.	indexLeft := index at: 1.	indexRight := index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft := self nextBits: 16.				indexLeft := self nextBits: 6.				predictedRight := self nextBits: 16.				indexRight := self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft := predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight := predictedRight - 65536].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft := self nextBits: bitsPerSample.				deltaRight := self nextBits: bitsPerSample.				stepLeft := stepSizeTable at: indexLeft + 1.				stepRight := stepSizeTable at: indexRight + 1.				predictedDeltaLeft := predictedDeltaRight := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft := predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight := predictedDeltaRight + stepRight].					stepLeft := stepLeft bitShift: -1.					stepRight := stepRight bitShift: -1.					bit := bit bitShift: -1].				predictedDeltaLeft := predictedDeltaLeft + stepLeft.				predictedDeltaRight := predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft := predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft := predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight := predictedRight - predictedDeltaRight]					ifFalse: [predictedRight := predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft := 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft := -32768]].				predictedRight > 32767					ifTrue: [predictedRight := 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight := -32768]].				indexLeft := indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft := 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft := 88]].				indexRight := indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight := 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:40'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	step := stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted := samples at: (sampleIndex := sampleIndex + 1).			(p := predicted) < 0 ifTrue: [p := p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index := self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign := 0.			diff := (samples at: (sampleIndex := sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign := deltaSignMask.				diff := 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta := (4 * diff) / step.				predictedDelta := ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta := 0.			predictedDelta := 0.			bit := deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta := delta + bit.					predictedDelta := predictedDelta + step.					diff := diff - step].				step := step bitShift: -1.				bit := bit bitShift: -1].			predictedDelta := predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted := predicted - predictedDelta]				ifFalse: [predicted := predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted := 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].			"compute new index and step values"			index := index + (indexTable at: delta + 1).			index < 0				ifTrue: [index := 0]				ifFalse: [index > 88 ifTrue: [index := 88]].			step := stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'private' stamp: 'ar 4/23/2001 15:12'!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	"not yet implemented"	self inline: false.	self success: false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ADPCMCodec class	instanceVariableNames: ''!!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 3/27/1999 11:15'!new	^ super new		initializeForBitsPerSample: 4		samplesPerFrame: 0.! !!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 11/15/2001 16:02'!newBitsPerSample: bitsPerSample	^ super new		initializeForBitsPerSample: bitsPerSample		samplesPerFrame: 0.! !!ADPCMCodec class methodsFor: 'primitive generation' stamp: 'ar 2/3/2001 15:50'!translatedPrimitives	"Answer a string containing the translated C code for my primitives."	"Note: This code currently must be hand-edited to remove several methods that are inlined (thus not needed) but not pruned out by the ST-to-C translator."	^#(		(ADPCMCodec privateDecodeMono:)		(ADPCMCodec privateDecodeStereo:)		(ADPCMCodec privateEncodeMono:)		(ADPCMCodec privateEncodeStereo:)		(ADPCMCodec indexForDeltaFrom:to:)		(ADPCMCodec nextBits:)		(ADPCMCodec nextBits:put:))! !SoundCodec subclass: #GSMCodec	instanceVariableNames: 'encodeState decodeState'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primDecode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMDecode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primEncode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMEncode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:35'!primNewState	<primitive: 'primitiveGSMNewState' module: 'SoundCodecPrims'>	self error: 'The SoundCodecPrims plugin is not available'.! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!bytesPerEncodedFrame	^ 33! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'stephaneducasse 2/4/2006 20:41'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	| p |	p := self	primDecode: decodeState frames: frameCount			from: srcByteArray at: srcIndex			into: dstSoundBuffer at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'stephaneducasse 2/4/2006 20:41'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	| p |	p := self	primEncode: encodeState frames: frameCount			from: srcSoundBuffer at: srcIndex			into: dstByteArray at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"Reset my encoding/decoding state to prepare to encode or decode a new sound stream."	encodeState := self primNewState.	decodeState := self primNewState.! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!samplesPerFrame	^ 160! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GSMCodec class	instanceVariableNames: ''!!GSMCodec class methodsFor: 'instance creation' stamp: 'jm 10/21/2001 10:10'!new	^ super new reset! !SoundCodec subclass: #MuLawCodec	instanceVariableNames: ''	classVariableNames: 'DecodingTable'	poolDictionaries: ''	category: 'Sound-Synthesis'!!MuLawCodec commentStamp: '<historical>' prior: 0!I represent a mu-law (u-law) codec. I compress sound data by a factor of 2:1 by encoding the most significant 12 bits of each 16-bit sample as a signed, exponentially encoded byte. The idea is to use more resolution for smaller lower sample values. This encoding was developed for the North American phone system and a variant of it, a-law, is a European phone standard. It is a popular sound encoding on Unix platforms (.au files).!!MuLawCodec methodsFor: 'external access' stamp: 'di 2/8/1999 22:28'!uLawDecodeSample: byte	"Decode a 16-bit signed sample from 8 bits using uLaw decoding"	^ DecodingTable at: byte + 1! !!MuLawCodec methodsFor: 'external access' stamp: 'stephaneducasse 2/4/2006 20:41'!uLawEncodeSample: sample	"Encode a 16-bit signed sample into 8 bits using uLaw encoding"	| s |	s := sample // 8.  "drop 3 least significant bits"	s < 0 ifTrue: [^ (self uLawEncode12Bits: 0-s) + 16r80]		ifFalse: [^ (self uLawEncode12Bits: s)].! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:15'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	^ 1! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'stephaneducasse 2/4/2006 20:41'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| dst |	dst := dstIndex.	srcIndex to: srcIndex + frameCount - 1 do: [:src |		dstSoundBuffer at: dst put: (DecodingTable at: (srcByteArray at: src) + 1).		dst := dst + 1].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'di 2/8/1999 22:25'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	srcIndex to: srcIndex + frameCount - 1 do: [:i |		dstByteArray at: i put: (self uLawEncodeSample: (srcSoundBuffer at: i))].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:11'!samplesPerFrame	"Answer the number of sound samples per compression frame."	^ 1! !!MuLawCodec methodsFor: 'private' stamp: 'di 2/9/1999 13:25'!uLawEncode12Bits: s	"Encode a 12-bit unsigned sample (0-4095) into 7 bits using uLaw encoding.	This gets called by a method that scales 16-bit signed integers down to a		12-bit magnitude, and then ORs in 16r80 if they were negative.	Detail: May get called with s >= 4096, and this works fine."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MuLawCodec class	instanceVariableNames: ''!!MuLawCodec class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"Build the 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"MuLawCodec initialize"	| encoded codec lastEncodedPos lastEncodedNeg |	DecodingTable := Array new: 256.	codec := self new.	lastEncodedPos := nil.	lastEncodedNeg := nil.	4095 to: 0 by: -1 do: [:s |		encoded := codec uLawEncode12Bits: s.		lastEncodedPos = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3).				lastEncodedPos := encoded].		encoded := encoded bitOr: 16r80.		lastEncodedNeg = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3) negated.				lastEncodedNeg := encoded]].! !Object subclass: #SoundPlayer	instanceVariableNames: ''	classVariableNames: 'ActiveSounds Buffer BufferIndex BufferMSecs LastBuffer PlayerProcess PlayerSemaphore ReadyForBuffer ReverbState SamplingRate SoundJustStarted SoundSupported Stereo UseReadySemaphore UseReverb'	poolDictionaries: ''	category: 'Sound-Synthesis'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundPlayer class	instanceVariableNames: ''!!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 1/27/98 09:28'!reverbState	^ ReverbState! !!SoundPlayer class methodsFor: 'accessing'!samplingRate	^ SamplingRate! !!SoundPlayer class methodsFor: 'accessing' stamp: 'JMM 11/6/2000 10:16'!setVolumeLeft: aLeftVolume volumeRight: aRightVolume	"Set sound pass in float 0.0-1.0 for left and right channel, with possible 2.0 or  higher to overdrive sound channel "	self primSoundSetVolumeLeft: aLeftVolume volumeRight: aRightVolume! !!SoundPlayer class methodsFor: 'accessing' stamp: 'JMM 11/6/2000 10:17'!soundVolume	"Return sound as array of doubles left then right channel, range is 0.0 to 1.0 but may be overdriven"	^self primSoundGetVolume! !!SoundPlayer class methodsFor: 'accessing'!stereo	^ Stereo! !!SoundPlayer class methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate := 22050.	BufferMSecs := 120.	Stereo := true.	UseReverb ifNil: [UseReverb := true].! !!SoundPlayer class methodsFor: 'initialization' stamp: 'ar 1/24/2002 18:40'!useLastBuffer	^LastBuffer notNil! !!SoundPlayer class methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!useLastBuffer: aBool	Buffer ifNil:[^self].	aBool 		ifTrue:[LastBuffer := SoundBuffer basicNew: Buffer basicSize]		ifFalse:[LastBuffer := nil]	! !!SoundPlayer class methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!useShortBuffer	"Experimental support for real-time MIDI input. This only works on platforms whose hardware allows very short buffer sizes. It has been tested on a Macintosh Powerbook G3."	"SoundPlayer useShortBuffer"	self shutDown.	BufferMSecs := 15.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/29/98 18:56'!isReverbOn	^ ReverbState ~~ nil! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 1/24/2002 18:41'!lastPlayBuffer	^LastBuffer! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!oldStylePlayLoop	"This version of the play loop is used if the VM does not yet support sound primitives that signal a semaphore when a sound buffer becomes available."	| bytesPerSlice count |	bytesPerSlice := Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count := self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [(Delay forMilliseconds: 1) wait].		count := count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds := ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted := nil]].! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!playLoop	"The sound player process loop."	| bytesPerSlice count willStop mayStop |	mayStop := Preferences soundStopWhenDone.	bytesPerSlice := Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count := self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [ReadyForBuffer wait].		count := count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds := ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			willStop := mayStop and:[						(ActiveSounds size = 0) and:[							self isAllSilence: Buffer size: count]].			LastBuffer ifNotNil:[				LastBuffer replaceFrom: 1 to: LastBuffer size with: Buffer startingAt: 1.			].			willStop				ifTrue:[self shutDown. PlayerProcess := nil]				ifFalse:[Buffer primFill: 0].			SoundJustStarted := nil].		willStop ifTrue:[^self].	].! !!SoundPlayer class methodsFor: 'player process' stamp: 'nk 2/16/2001 13:26'!playerProcess	^PlayerProcess! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 2/4/2001 18:01'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	^self startPlayerProcessBufferSize: bufferSize 			rate: samplesPerSecond 			stereo: stereoFlag 			sound: nil! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag sound: aSound	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	aSound		ifNil:[ActiveSounds := OrderedCollection new]		ifNotNil:[ActiveSounds := OrderedCollection with: aSound].	Buffer := SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	LastBuffer ifNotNil:[LastBuffer := SoundBuffer basicNew: Buffer basicSize].	PlayerSemaphore := Semaphore forMutualExclusion.	SamplingRate := samplesPerSecond.	Stereo := stereoFlag.	ReadyForBuffer := Semaphore new.	SoundSupported := true. "Assume so"	UseReadySemaphore := true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess := [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess := [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!startReverb	"Start a delay-line style reverb with the given tap delays and gains. Tap delays are given in samples and should be prime integers; the following comment gives an expression that generates primes."	"Integer primesUpTo: 22050"	UseReverb := true.	ReverbState := ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!stopPlayerProcess	"Stop the sound player process."	"SoundPlayer stopPlayerProcess"	(PlayerProcess == nil or:[PlayerProcess == Processor activeProcess]) 		ifFalse:[PlayerProcess terminate].	PlayerProcess := nil.	self primSoundStop.	ActiveSounds := OrderedCollection new.	Buffer := nil.	PlayerSemaphore := Semaphore forMutualExclusion.	ReadyForBuffer ifNotNil:		[Smalltalk unregisterExternalObject: ReadyForBuffer].	ReadyForBuffer := nil.! !!SoundPlayer class methodsFor: 'player process' stamp: 'stephaneducasse 2/4/2006 20:41'!stopReverb	UseReverb := false.	ReverbState := nil.! !!SoundPlayer class methodsFor: 'playing' stamp: 'ar 2/1/2001 15:20'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	Preferences canRecordWhilePlaying ifTrue: [^ true].	SoundRecorder anyActive ifTrue:[^false].	^ true! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 8/23/97 20:38'!pauseSound: aSound	"Stop playing the given sound. Playing can be resumed from this point later."	PlayerSemaphore critical: [		ActiveSounds remove: aSound ifAbsent: []].! !!SoundPlayer class methodsFor: 'playing' stamp: 'ar 2/19/2001 01:28'!playSound: aSound	"Reset and start playing the given sound from its beginning."	aSound reset.	aSound samplesRemaining = 0 ifTrue:[^self].	self resumePlaying: aSound.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences soundsEnabled ifFalse: [^ self].	doQuickStart := quickStart.	Preferences soundQuickStart ifFalse: [doQuickStart := false].	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		^self startUpWithSound: aSound].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart := false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!stopPlayingAll	"Stop playing all sounds."	PlayerSemaphore critical: [		ActiveSounds := ActiveSounds species new].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:49'!waitUntilDonePlaying: aSound	"Wait until the given sound is no longer playing."	[PlayerSemaphore critical: [ActiveSounds includes: aSound]]		whileTrue: [(Delay forMilliseconds: 100) wait].! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'stephaneducasse 2/4/2006 20:41'!boinkPitch: p dur: d loudness: l waveTable: waveTable pan: pan	"Play a decaying note on the given stream using the given wave table. Used for testing only."	| decay tableSize amplitude increment cycles i |	decay := 0.96.	tableSize := waveTable size.	amplitude := l asInteger min: 1000.	increment := ((p asFloat * tableSize asFloat) / SamplingRate asFloat) asInteger.	increment := (increment max: 1) min: (tableSize // 2).	cycles := (d * SamplingRate asFloat) asInteger.	i := 1.	1 to: cycles do: [:cycle |		(cycle \\ 100) = 0			ifTrue: [amplitude := (decay * amplitude asFloat) asInteger].		i := (((i - 1) + increment) \\ tableSize) + 1.		self playTestSample: (amplitude * (waveTable at: i)) // 1000 pan: pan].! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'stephaneducasse 2/4/2006 20:41'!boinkScale	"Tests the sound output primitives by playing a scale."	"SoundPlayer boinkScale"	| sineTable pan |	self shutDown.	SamplingRate := 11025.	Stereo := true.	sineTable := self sineTable: 1000.	Buffer := SoundBuffer newStereoSampleCount: 1000.	BufferIndex := 1.	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: SamplingRate		stereo: Stereo.	pan := 0.	#(261.626 293.665 329.628 349.229 391.996 440.001 493.884 523.252) do: [:p |		self boinkPitch: p dur: 0.3 loudness: 300 waveTable: sineTable pan: pan.		pan := pan + 125].	self boinkPitch: 261.626 dur: 1.0 loudness: 300 waveTable: sineTable pan: 500.	self primSoundStop.	self shutDown.	SoundPlayer initialize.  "reset sampling rate, buffer size, and stereo flag"! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'stephaneducasse 2/4/2006 20:41'!playTestSample: s pan: pan	"Append the given sample in the range [-32767..32767] to the output buffer, playing the output buffer when it is full. Used for testing only."	| sample leftSample |	BufferIndex >= Buffer size		ifTrue: [			"current buffer is full; play it"			[self primSoundAvailableBytes > 0]				whileFalse. "wait for space to be available"			self primSoundPlaySamples: Buffer stereoSampleCount from: Buffer startingAt: 1.			Buffer primFill: 0.			BufferIndex := 1].	sample := s.	sample >  32767 ifTrue: [ sample :=  32767 ]. 	sample < -32767 ifTrue: [ sample := -32767 ].	Stereo		ifTrue: [			leftSample := (sample * pan) // 1000.			Buffer at: BufferIndex		put: sample - leftSample.			Buffer at: BufferIndex + 1	put: leftSample]		ifFalse: [			Buffer at: BufferIndex + 1 put: sample].	BufferIndex := BufferIndex + 2.! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'stephaneducasse 2/4/2006 20:41'!sineTable: size	"Compute a sine table of the given size. Used for testing only."	| radiansPerStep table |	table := Array new: size.	radiansPerStep := (2.0 * Float pi) / table size asFloat.	1 to: table size do: [:i |		table at: i put:			(32767.0 * (radiansPerStep * i) sin) asInteger].	^ table! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'stephaneducasse 2/4/2006 20:41'!shutDown	"Stop player process, for example before snapshotting."	self stopPlayerProcess.	ReverbState := nil.! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 7/11/97 12:17'!startUp	"Start up the player process."	SoundPlayer initialize.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'ar 2/4/2001 17:59'!startUpWithSound: aSound	"Start up the player process."	SoundPlayer initialize.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo		sound: aSound.! !!SoundPlayer class methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!isAllSilence: buffer size: count	"return true if the buffer is all silence after reverb has ended"	| value |	value := buffer at: 1.	2 to: count do:[:i| (buffer at: i) = value ifFalse:[^false]].	^true! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundAvailableBytes	"Return the number of bytes of available space in the sound output buffer."	"Note: Squeak always uses buffers containing 4-bytes per sample (2 channels at 2 bytes per channel) regardless of the state of the Stereo flag."	<primitive: 'primitiveSoundAvailableSpace' module: 'SoundPlugin'>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'JMM 11/6/2000 10:17'!primSoundGetVolume	"Return sound as array of doubles left then right channel, range is 0.0 to 1.0 but may be overdriven"	<primitive: 'primitiveSoundGetVolume' module: 'SoundPlugin'>	^Array with: 1.0 with: 1.0! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundInsertSamples: count from: aSoundBuffer samplesOfLeadTime: anInteger	"Mix the given number of sample frames from the given sound buffer into the queue of samples that has already been submitted to the sound driver. This primitive is used to start a sound playing with minimum latency, even if large sound output buffers are being used to ensure smooth sound output. Returns the number of samples consumed, or zero if the primitive is not implemented or fails."	<primitive: 'primitiveSoundInsertSamples' module: 'SoundPlugin'>	^ 0! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 2/2/2001 15:09'!primSoundPlaySamples: count from: aSampleBuffer startingAt: index	"Copy count bytes into the current sound output buffer from the given sample buffer starting at the given index."	<primitive: 'primitiveSoundPlaySamples' module: 'SoundPlugin'>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'JMM 11/6/2000 10:14'!primSoundSetVolumeLeft: aLeftVolume volumeRight: aRightVolume	"Set sound pass in float 0.0-1.0 for left and right channel, with possible 2.0 or  higher to overdrive sound channel "	<primitive: 'primitiveSoundSetLeftVolume' module: 'SoundPlugin'>! !!SoundPlayer class methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	"ar 12/5/1998 Turn off the sound if not supported"	<primitive: 'primitiveSoundStart' module: 'SoundPlugin'>	SoundSupported := false.! !!SoundPlayer class methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag semaIndex: anInteger	"Start double-buffered sound output with the given buffer size and sampling rate. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled when the sound driver is ready to accept another buffer of samples."	"Details: If this primitive fails, this method tries to use the older version instead."	<primitive: 'primitiveSoundStartWithSemaphore' module: 'SoundPlugin'>	UseReadySemaphore := false.	self primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag.! !!SoundPlayer class methodsFor: 'private' stamp: 'tpr 2/2/2001 19:46'!primSoundStop	"Stop double-buffered sound output. Must not raise an error because it is used inside error handling and at system shutdown"	<primitive: 'primitiveSoundStop' module: 'SoundPlugin'>! !!SoundPlayer class methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!startPlayingImmediately: aSound	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."	| totalSamples buf n leftover src rest |	"first, fill a double-size buffer with samples"	"Note: The code below assumes that totalSamples contains two	 buffers worth of samples, and the insertSamples primitive is	 expected to consume at least one buffer's worth of these	 samples. The remaining samples are guaranteed to fit into	 a single buffer."	totalSamples := Buffer stereoSampleCount * 2.  "two buffer's worth"	buf := SoundBuffer newStereoSampleCount: totalSamples.	aSound playSampleCount: totalSamples into: buf startingAt: 1.	ReverbState == nil ifFalse: [		ReverbState applyReverbTo: buf startingAt: 1 count: totalSamples].	PlayerSemaphore critical: [		"insert as many samples as possible into the sound driver's buffers"		n := self primSoundInsertSamples: totalSamples			from: buf			samplesOfLeadTime: 1024.		n > 0 ifTrue:[			leftover := totalSamples - n.			"copy the remainder of buf into Buffer"			"Note: the following loop iterates over 16-bit words, not two-word stereo slices"			"assert: 0 < leftover <= Buffer stereoSampleCount"			src := 2 * n.			1 to: 2 * leftover do:				[:dst | Buffer at: dst put: (buf at: (src := src + 1))].			"generate enough additional samples to finish filling Buffer"			rest := Buffer stereoSampleCount - leftover.			aSound playSampleCount: rest into: Buffer startingAt: leftover + 1.			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: leftover + 1 count: rest].			"record the fact that this sound has already been played into Buffer so that we don't process it again this time around"			SoundJustStarted := aSound.		] ifFalse:[			"quick start failed; reset the sound so we start over"			aSound reset.		].		ActiveSounds add: aSound].! !Object subclass: #SoundRecorder	instanceVariableNames: 'stereo samplingRate recordLevel recordedBuffers recordedSound recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex codec desiredSampleRate'	classVariableNames: 'CanRecordWhilePlaying RecorderActive'	poolDictionaries: ''	category: 'Sound-Synthesis'!!SoundRecorder methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!codec: aSoundCodec	codec := aSoundCodec! !!SoundRecorder methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!desiredSampleRate: newRate	"use of this method indicates a strong desire for the specified rate, even if	the OS/hardware are not cooperative"	desiredSampleRate := samplingRate := newRate  "Best are 44100 22050 11025"! !!SoundRecorder methodsFor: 'accessing' stamp: 'jj 10/20/97 15:30'!isActive	"Return true if I have a recordProcess running."	^ recordProcess ~~ nil! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/2/97 16:16'!isPaused	"Return true if recording is paused."	^ paused! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/18/97 19:19'!meterLevel	"Return the meter level, an integer in the range [0..100] where zero is silence and 100 represents the maximum signal level possible without clipping."	^ (100 * meterLevel) // 32768! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel := (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 12/15/97 14:28'!samplingRate	^ samplingRate! !!SoundRecorder methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!samplingRate: newRate	samplingRate := newRate  "Best are 44100 22050 11025"! !!SoundRecorder methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"SoundRecorder new"	stereo := false.	samplingRate := 11025.	recordLevel := 0.5.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initializeRecordingState	recordProcess := nil.	bufferAvailableSema := nil.	paused := true.	meteringBuffer := nil.	meterLevel := 0.	soundPlaying := nil.	currentBuffer := nil.	nextIndex := 1.! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primGetActualRecordingSampleRate	"Return the actual sample rate being used for recording. This primitive fails unless sound recording is currently in progress."	<primitive: 'primitiveSoundGetRecordingSampleRate' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primRecordSamplesInto: aWordArray startingAt: index	"Record a sequence of 16-bit sound samples into the given array starting at the given sample index. Return the number of samples recorded, which may be zero if no samples are currently available."	<primitive: 'primitiveSoundRecordSamples' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primSetRecordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	<primitive: 'primitiveSoundSetRecordLevel' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primStartRecordingDesiredSampleRate: samplesPerSec stereo: stereoFlag semaIndex: anInteger	"Start sound recording with the given stereo setting. Use a sampling rate as close to the desired rate as the underlying platform will support. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled every time a recording buffer is filled."	<primitive: 'primitiveSoundStartRecording' module: 'SoundPlugin'>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'tpr 2/15/2001 17:13'!primStopRecording	"Stop sound recording. Does nothing if recording is not currently in progress. Do not fail if plugin is not available"	<primitive: 'primitiveSoundStopRecording' module: 'SoundPlugin'>! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!clearRecordedSound	"Clear the sound recorded thus far. Go into pause mode if currently recording."	paused := true.	recordedSound := SequentialSound new.	self allocateBuffer.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'sw 6/10/2003 12:34'!hasRecordedSound
	"Answer whether the receiver currently has any recorded sound"

	^ self recordedSound notNil! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused := true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying := nil].	"Note: there can be problems if canRecordWhilePlaying is true. Recorders which only pause will inhibit other recorders from recording. I chose to make #stopPlaying unconditional in a subclass. The same might be appropriate here at the expense of making recorders resumable"	Preferences canRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying := self recordedSound.	soundPlaying play.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!resumeRecording	"Continue recording from the point at which it was last paused."	self flag: #bob.	"Note: If canRecordWhilePlaying is true, then recordings may never get started (at least by this method). One possibility, used in a subclass, is to make the #startPlaying unconditional. Another would be to use #startPlaying instead of #resumePlaying in appropriate cases"	Preferences canRecordWhilePlaying ifFalse: [self startRecording].	paused := false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel := 0.5].  "lazy initialization"	Preferences canRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused := true.	meteringBuffer := SoundBuffer newMonoSampleCount: 1024.	meterLevel := 0.	self allocateBuffer.	bufferAvailableSema := Semaphore new.	semaIndex := Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	RecorderActive := true.	samplingRate := self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess := [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!stopRecording	"Stop the recording process and turn of the sound input driver."	recordProcess ifNotNil: [recordProcess terminate].	recordProcess := nil.	self primStopRecording.	RecorderActive := false.	Smalltalk unregisterExternalObject: bufferAvailableSema.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer].	self initializeRecordingState.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'sw 3/3/2004 19:49'!verifyExistenceOfRecordedSound
	"If the receiver has a recorded sound, answer true; if not, put up an informer and answer false"

	^ self recordedSound
		ifNotNil:
			[true]
		ifNil:
			[self inform: 'please record a sound first' translated.
			false]! !!SoundRecorder methodsFor: 'results' stamp: 'stephaneducasse 2/4/2006 20:41'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedBuffers := recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz := recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf := SoundBuffer newMonoSampleCount: sz.	i := 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i := i + 1]].	recordedBuffers := nil.	^ newBuf! !!SoundRecorder methodsFor: 'results' stamp: 'stephaneducasse 2/4/2006 20:41'!condensedStereoSound	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."	| sz leftBuf rightBuf leftI rightI left |	sz := recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	leftBuf := SoundBuffer newMonoSampleCount: (sz + 1) // 2.	rightBuf := SoundBuffer newMonoSampleCount: (sz + 1) // 2.	leftI := rightI := 1.	left := true.	recordedBuffers do: [:b |		1 to: b size do: [:j |			left				ifTrue: [leftBuf at: leftI put: (b at: j). leftI := leftI + 1. left := false]				ifFalse: [rightBuf at: rightI put: (b at: j). rightI := rightI + 1. left := true]]].	^ MixedSound new		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 11:07'!recordedSound	"Return the sound that was recorded."	^ recordedSound! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 21:24'!soundSegments	^ self segmentsAbove: 1000 normalizedVolume: 80.0! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset	"Return a new SoundBuffer containing the samples in the given range."	| startBufIndex startSampleIndex endBufIndex endSampleIndex	 count resultBuf j buf firstInBuf n |	startBufIndex := startPlace at: 1.	startSampleIndex := startPlace at: 2.	endBufIndex := endPlace at: 1.	endSampleIndex := endPlace at: 2.	startBufIndex = endBufIndex		ifTrue: [count := endSampleIndex + 1 - startSampleIndex]		ifFalse: [			count := ((recordedBuffers at: startBufIndex) size + 1 - startSampleIndex).  "first buffer"			count := count + endSampleIndex.  "last buffer"			startBufIndex + 1 to: endBufIndex - 1 do:				[:i | count := count + (recordedBuffers at: i) size]].  "middle buffers"	resultBuf := SoundBuffer newMonoSampleCount: count.	j := 1.  "next destination index in resultBuf"	startBufIndex to: endBufIndex do: [:i |		buf := recordedBuffers at: i.		firstInBuf := 1.	 	n := buf size.		i = startBufIndex ifTrue: [			n := (recordedBuffers at: startBufIndex) size + 1 - startSampleIndex.			firstInBuf := startSampleIndex].		i = endBufIndex ifTrue: [			i = startBufIndex				ifTrue: [n := endSampleIndex + 1 - startSampleIndex]				ifFalse: [n := endSampleIndex]].		self copyTo: resultBuf from: j to: (j + n - 1)			from: buf startingAt: firstInBuf			normalize: nFactor dcOffset: dcOffset.		j := j + n].	^ resultBuf! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!copyTo: resultBuf from: startIndex to: endIndex from: buf startingAt: firstInBuf normalize: nFactor dcOffset: dcOffset	"Copy samples from buf to resultBuf removing the DC offset and normalizing their volume in the process."	| indexOffset |	indexOffset := firstInBuf - startIndex.	startIndex to: endIndex do: [:i |		resultBuf at: i put: (((buf at: (i + indexOffset)) - dcOffset) * nFactor) // 1000].! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!endPlace	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!firstSampleOverThreshold: threshold dcOffset: dcOffset startingAt: startPlace	"Beginning at startPlace, this routine will return the first place at which a sample exceeds the given threshold."	| buf s iStart jStart nThreshold |	nThreshold := threshold negated.	iStart := startPlace first.	jStart := startPlace second.	iStart to: recordedBuffers size do:		[:i | buf := recordedBuffers at: i.		jStart to: buf size do:			[:j | s := (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold]) ifTrue:				["found a sample over threshold"				^ Array with: i with: j]].		jStart := 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset	"Return a normalization factor for the range of sample values and DC offset. A normalization factor is a fixed-point number that will be divided by 1000 after multiplication with each sample value."	| peak factor |	peak := (max - dcOffset) max: (min - dcOffset) negated.	peak = 0 ifTrue: [^ 1000].	factor := (32767.0 * percentOfMaxVolume) / (100.0 * peak).	^ (factor * 1000.0) asInteger! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!place: startPlace plus: nSamples	"Return the place that is nSamples (may be negative) beyond thisPlace."	| i j remaining buf |	i := startPlace first.	j := startPlace second.	nSamples >= 0	ifTrue: [remaining := nSamples.			[buf := recordedBuffers at: i.			(j + remaining) <= buf size ifTrue: [^ Array with: i with: j + remaining].			i < recordedBuffers size]				whileTrue: [remaining := remaining - (buf size - j + 1).							i := i+1.  j := 1].			^ self endPlace]	ifFalse: [remaining := nSamples negated.			[buf := recordedBuffers at: i.			(j - remaining) >= 1 ifTrue: [^ Array with: i with: j - remaining].			i > 1]				whileTrue: [remaining := remaining - j.							i := i-1.  j := (recordedBuffers at: i) size].			^ #(1 1)]! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!scanForEndThreshold: threshold dcOffset: dcOffset minLull: lull startingAt: startPlace	"Beginning at startPlace, this routine will find the last sound that exceeds threshold, such that if you look lull samples later you will not find another sound over threshold within the following block of lull samples.	Return the place that is lull samples beyond to that last sound.	If no end of sound is found, return endPlace."	| buf s iStart jStart nThreshold n |	nThreshold := threshold negated.	iStart := startPlace first.	jStart := startPlace second.	n := 0.	iStart to: recordedBuffers size do:		[:i | buf := recordedBuffers at: i.		jStart to: buf size do:			[:j | s := (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold])				ifTrue: ["found a sample over threshold"						n := 0]				ifFalse: ["still not over threshold"						n := n + 1.						n >= lull ifTrue: [^ Array with: i with: j]]].		jStart := 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!scanForStartThreshold: threshold dcOffset: dcOffset minDur: duration startingAt: startPlace	"Beginning at startPlace, this routine will find the first sound that exceeds threshold, such that if you look duration samples later you will find another sound over threshold within the following block of duration samples.	Return the place that is duration samples prior to that first sound.	If no sound is found, return endPlace."	| soundPlace lookPlace nextSoundPlace thirdPlace |	soundPlace := self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: startPlace.	[soundPlace = self endPlace ifTrue: [^ soundPlace].	"Found a sound -- look duration later"	lookPlace := self place: soundPlace plus: duration.	nextSoundPlace := self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: lookPlace.	thirdPlace := self place: lookPlace plus: duration.	nextSoundPlace first < thirdPlace first		or: [nextSoundPlace first = thirdPlace first			and: [nextSoundPlace second < thirdPlace second]]]		whileFalse: [soundPlace := nextSoundPlace].	"Yes, there is sound in the next interval as well"	^ self place: soundPlace plus: 0-duration! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!segmentsAbove: threshold normalizedVolume: percentOfMaxVolume	"Break the current recording up into a sequence of sound segments separated by silences."	| max min sum totalSamples bufSize s dcOffset firstPlace endPlace resultBuf nFactor lastPlace segments gapSize minDur minLull soundSize restSize |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	(recordedSound == nil or: [recordedSound sounds isEmpty]) ifTrue:[^ self].	"Reconstruct buffers so old trimming code will work"	recordedBuffers := recordedSound sounds collect: [:snd | snd samples].	soundSize := restSize := 0.	max := min := sum := totalSamples := 0.	recordedBuffers do: [:buf |		bufSize := buf size.		totalSamples := totalSamples + buf size.		1 to: bufSize do: [:i |			s := buf at: i.			s > max ifTrue: [max := s].			s < min ifTrue: [min := s].			sum := sum + s]].	dcOffset := sum // totalSamples.	minDur := (samplingRate/20.0) asInteger.  " 1/20 second "	minLull := (samplingRate/4.0) asInteger.  " 1/2 second "	segments := SequentialSound new.	endPlace := self endPlace.	lastPlace := #(1 1).	[firstPlace := self scanForStartThreshold: threshold						dcOffset: dcOffset						minDur: minDur						startingAt: lastPlace.	firstPlace = endPlace]		whileFalse:		[firstPlace = lastPlace ifFalse:			["Add a silence equal to the gap size"			"Wasteful but simple way to get gap size..."			gapSize := (self copyFrom: lastPlace to: firstPlace						normalize: 1000 dcOffset: dcOffset) size - 2.			"... -2 makes up for overlap of one sample on either end"			segments add: (RestSound dur: gapSize asFloat / samplingRate).			restSize := restSize + gapSize."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: gapSize; space; show: 'gap'."			].		lastPlace := self scanForEndThreshold: threshold						dcOffset: dcOffset						minLull: minLull + minDur						startingAt: firstPlace.		"Allow room for lead time of next sound"		lastPlace := self place: lastPlace plus: minDur negated.		nFactor := self normalizeFactorFor: percentOfMaxVolume						min: min max: max dcOffset: dcOffset.		resultBuf := self copyFrom: firstPlace to: lastPlace						normalize: nFactor dcOffset: dcOffset.		soundSize := soundSize + resultBuf size."Transcript cr; print: firstPlace; space; print: lastPlace; space; print: resultBuf size; space; show: 'sound'."		segments add: (codec == nil			ifTrue: [SampledSound new setSamples: resultBuf samplingRate: samplingRate]			ifFalse: [codec compressSound: (SampledSound new setSamples: resultBuf samplingRate: samplingRate)])].	"Final gap for consistency"	gapSize := (self copyFrom: lastPlace to: self endPlace				normalize: 1000 dcOffset: dcOffset) size - 1.	segments add: (RestSound dur: gapSize asFloat / samplingRate).	restSize := restSize + gapSize.	self inform: ((soundSize+restSize/samplingRate) roundTo: 0.1) printString , ' secs reduced to ' , ((soundSize/samplingRate) roundTo: 0.1) printString.	recordedBuffers := nil.	^ segments! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!suppressSilence	recordedSound := self soundSegments! !!SoundRecorder methodsFor: 'trimming' stamp: 'stephaneducasse 2/4/2006 20:41'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers := recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ self].	max := min := sum := totalSamples := 0.	recordedBuffers do: [:buf |		bufSize := buf size.		totalSamples := totalSamples + buf size.		1 to: bufSize do: [:i |			s := buf at: i.			s > max ifTrue: [max := s].			s < min ifTrue: [min := s].			sum := sum + s]].	dcOffset := sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace := self scanForStartThreshold: threshold					dcOffset: dcOffset					minDur: (samplingRate/60.0) asInteger "at least 1/60th of a second"					startingAt: #(1 1).	startPlace = self endPlace ifTrue:		["no samples above threshold"		recordedBuffers := nil.  ^ self].	endPlace := self scanForEndThreshold: threshold					dcOffset: dcOffset					minLull: (samplingRate/5) asInteger					startingAt: startPlace.	nFactor := self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf := self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedSound := SampledSound new setSamples: resultBuf samplingRate: samplingRate.	recordedBuffers := nil! !!SoundRecorder methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	| bufferTime |	bufferTime := stereo  "Buffer time = 1/2 second"		ifTrue: [self samplingRate asInteger]		ifFalse: [self samplingRate asInteger // 2].	currentBuffer := SoundBuffer newMonoSampleCount:		"Multiple of samplesPerFrame that is approx. bufferTime long"		(bufferTime truncateTo: self samplesPerFrame).	nextIndex := 1.! !!SoundRecorder methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!emitBuffer: buffer	| sound ratio resultBuf |	"since some sound recording devices cannot (or will not) record below a certain sample rate,	trim the samples down if the user really wanted fewer samples"	(desiredSampleRate isNil or: [(ratio := samplingRate // desiredSampleRate) <= 1]) ifTrue: [		sound := SampledSound new setSamples: buffer samplingRate: samplingRate.	] ifFalse: [		resultBuf := SoundBuffer 			averageEvery: ratio 			from: buffer 			upTo: buffer monoSampleCount.		sound := SampledSound new setSamples: resultBuf samplingRate: samplingRate / ratio.	].	recordedSound add: (codec ifNil: [sound] ifNotNil: [codec compressSound: sound])! !!SoundRecorder methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!emitPartialBuffer	| s |	s := self samplesPerFrame.	self emitBuffer: (currentBuffer copyFrom: 1 to: ((nextIndex-1) +( s-1) truncateTo: s))! !!SoundRecorder methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!meterFrom: start count: count in: buffer	"Update the meter level with the maximum signal level in the given range of the given buffer."	| last max sample |	count = 0 ifTrue: [^ self].  "no new samples"	last := start + count - 1.	max := 0.	start to: last do: [:i |		sample := buffer at: i.		sample < 0 ifTrue: [sample := sample negated].		sample > max ifTrue: [max := sample]].	meterLevel := max.! !!SoundRecorder methodsFor: 'private' stamp: 'dgd 4/4/2006 16:15'!recordLoop	"Record process loop that records samples."	| n sampleCount |	n := 0.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n := self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n := self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex := nextIndex + n.				stereo					ifTrue: [sampleCount := currentBuffer stereoSampleCount]					ifFalse: [sampleCount := currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						self emitBuffer: currentBuffer.						self allocateBuffer]].		"workaround for OSS emulation on top on ALSA (on Linux environments)"		(Delay forMilliseconds: 20) wait.	].! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 10:39'!samplesPerFrame	"Can be overridden to quantize buffer size for, eg, fixed-frame codecs"	codec == nil		ifTrue: [^ 1]		ifFalse: [^ codec samplesPerFrame]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundRecorder class	instanceVariableNames: ''!!SoundRecorder class methodsFor: 'accessing' stamp: 'ar 2/1/2001 15:20'!anyActive	"Return true if any sound recorder is actively recording"	^RecorderActive == true! !!SoundRecorder class methodsFor: 'accessing' stamp: 'RAA 8/7/2000 19:23'!canRecordWhilePlaying	"Return true if this platform supports simultaneous sound recording and playback."	^Preferences canRecordWhilePlaying.		"now in preferences"! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying := #ignoredNowInPreferences.! !SoundRecorder subclass: #SoundInputStream	instanceVariableNames: 'bufferSize mutex'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!SoundInputStream commentStamp: '<historical>' prior: 0!This subclass of SoundRecorder supports real-time processing of incoming sound data. The sound input process queues raw sound buffers, allowing them to be read and processed by the client as they become available. A semaphore is used to synchronize between the record process and the client process. Since sound data is buffered, the client process may lag behind the input process without losing data.!!SoundInputStream methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!bufferCount	"Answer the number of sound buffers that have been queued."	| n |	mutex ifNil: [^ 0].  "not recording"	mutex critical: [n := recordedBuffers size].	^ n! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:36'!bufferSize	^ bufferSize! !!SoundInputStream methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!bufferSize: aNumber	"Set the sound buffer size. Buffers of this size will be queued for the client to process."	bufferSize := aNumber truncated.! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:23'!isRecording	"Answer true if the sound input process is running."	^ recordProcess ~~ nil! !!SoundInputStream methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!nextBufferOrNil	"Answer the next input buffer or nil if no buffer is available."	| result |	mutex ifNil: [^ nil].  "not recording"	mutex critical: [		recordedBuffers size > 0			ifTrue: [result := recordedBuffers removeFirst]			ifFalse: [result := nil]].	^ result! !!SoundInputStream methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initialize	super initialize.	bufferSize := 1024.	mutex := nil.! !!SoundInputStream methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!startRecording	"Start the sound input process."	recordProcess ifNotNil: [self stopRecording].	recordedBuffers := OrderedCollection new: 100.	mutex := Semaphore forMutualExclusion.	super startRecording.	paused := false.! !!SoundInputStream methodsFor: 'recording controls' stamp: 'stephaneducasse 2/4/2006 20:41'!stopRecording	"Turn off the sound input process and close the driver."	super stopRecording.	recordedBuffers := nil.	mutex := nil.! !!SoundInputStream methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!allocateBuffer	"Allocate a new buffer and reset nextIndex. This message is sent by the sound input process."	currentBuffer := SoundBuffer newMonoSampleCount: bufferSize.	nextIndex := 1.! !!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24'!emitBuffer: buffer	"Queue a buffer for later processing. This message is sent by the sound input process."	mutex critical: [recordedBuffers addLast: buffer].! !AbstractSound subclass: #StreamingMonoSound	instanceVariableNames: 'stream volume repeat headerStart audioDataStart streamSamplingRate totalSamples codec mixer leftoverSamples lastBufferMSecs mutex'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!StreamingMonoSound commentStamp: '<historical>' prior: 0!I implement a streaming player for monophonic Sun (.au) and AIFF (.aif) audio files.Example of use:	(StreamingMonoSound onFileNamed: 'song.aif') play.!!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:12'!duration	"Answer the duration of this sound in seconds."	^ totalSamples asFloat / streamSamplingRate! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 10/18/2001 15:46'!repeat	"Answer the repeat flag."	^ repeat! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!repeat: aBoolean	"Set the repeat flag. If true, this sound will loop back to the beginning when it gets to the end."	repeat := aBoolean.! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:05'!soundPosition	"Answer the relative position of sound playback as a number between 0.0 and 1.0."	(stream isNil or: [stream closed]) ifTrue: [^ 0.0].	^ self currentSampleIndex asFloat / totalSamples! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!soundPosition: fraction	"Jump to the position the given fraction through the sound file. The argument is a number between 0.0 and 1.0."	| desiredSampleIndex |	(stream isNil or: [stream closed]) ifTrue: [^ self].	desiredSampleIndex := ((totalSamples * fraction) truncated max: 0) min: totalSamples.	codec		ifNil: [stream position: audioDataStart + (desiredSampleIndex * 2)]		ifNotNil: [self positionCodecTo: desiredSampleIndex].	leftoverSamples := SoundBuffer new.! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/20/2001 16:59'!streamSamplingRate	"Answer the sampling rate of the MP3 stream."	^ streamSamplingRate! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 9/26/2000 07:49'!volume	"Answer my volume."	^ volume! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:41'!volume: aNumber	"Set my volume to the given number between 0.0 and 1.0."	volume := aNumber.	self createMixer.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'stephaneducasse 2/4/2006 20:41'!saveAsFileNamed: newFileName compressionType: compressionTypeString	"Store this sound in a new file with the given name using the given compression type. Useful for converting between compression formats."	| outFile |	outFile := (FileStream newFileNamed: newFileName) binary.	self storeSunAudioOn: outFile compressionType: compressionTypeString.	outFile close.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'stephaneducasse 2/4/2006 20:41'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame outCodec compressed outSamplingRate audioWriter samplesRemaining inBuf outBuf counts byteCount |	self pause; reset.  "stop playing and return to beginning"	fmt := SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize := 64000.	samplesPerFrame := 1.	outCodec := SunAudioFileWriter codecForFormatCode: fmt.	outCodec ifNotNil: [		samplesPerFrame := outCodec samplesPerFrame.		inBufSize := inBufSize roundUpTo: (2 * samplesPerFrame).		compressed := ByteArray new:			(inBufSize // samplesPerFrame) * outCodec bytesPerEncodedFrame].	outSamplingRate := streamSamplingRate.	streamSamplingRate > 22050 ifTrue: [		streamSamplingRate = 44100 ifFalse: [self error: 'unexpected MP3 sampling rate'].		outSamplingRate := 22050].	"write audio header"	audioWriter := SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: totalSamples during: [:bar |			samplesRemaining := totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				self loadBuffersForSampleCount: (inBufSize min: samplesRemaining).				inBuf := mixer sounds first samples.				outSamplingRate < streamSamplingRate					ifTrue: [outBuf := inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf := inBuf].				outCodec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts := outCodec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount := counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining := samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!StreamingMonoSound methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!initStream: aStream headerStart: anInteger	"Initialize for streaming from the given stream. The audio file header starts at the given stream position."	stream := aStream.	volume := 1.0.	repeat := false.	headerStart := anInteger.	self reset.! !!StreamingMonoSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!closeFile	"Close my stream, if it responds to close."	stream ifNotNil: [		(stream respondsTo: #close) ifTrue: [stream close]].	mixer := nil.	codec := nil.! !!StreamingMonoSound methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!extractFrom: startSecs to: endSecs	"Extract a portion of this sound between the given start and end times. The current implementation only works if the sound is uncompressed."	| emptySound first last sampleCount byteStream sndBuf |	codec ifNotNil: [^ self error: 'only works on uncompressed sounds'].	emptySound := SampledSound samples: SoundBuffer new samplingRate: streamSamplingRate.	first := (startSecs * streamSamplingRate) truncated max: 0.	last := ((endSecs * streamSamplingRate) truncated min: totalSamples) - 1.	first >= last ifTrue: [^ emptySound].	codec ifNotNil: [self error: 'extracting from compressed sounds is not supported'].	sampleCount := last + 1 - first.	stream position: audioDataStart + (2 * first).	byteStream := ReadStream on: (stream next: 2 * sampleCount).	sndBuf := SoundBuffer newMonoSampleCount: sampleCount.	1 to: sampleCount do: [:i | sndBuf at: i put: byteStream int16].	^ SampledSound samples: sndBuf samplingRate: streamSamplingRate! !!StreamingMonoSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!millisecondsSinceStart	"Answer the number of milliseconds of this sound started playing."	| mSecs |	(stream isNil or: [stream closed]) ifTrue: [^ 0].	mSecs := self currentSampleIndex * 1000 // streamSamplingRate.	(self isPlaying and: [lastBufferMSecs > 0]) ifTrue: [		"adjust mSecs by the milliseconds since the last buffer"		mutex critical: [			mSecs := self currentSampleIndex * 1000 // streamSamplingRate.			mSecs := mSecs + ((Time millisecondClockValue - lastBufferMSecs) max: 0)]].	^ mSecs + 350 - (2 * SoundPlayer bufferMSecs)! !!StreamingMonoSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index"	self repeat ifTrue: [  "loop if necessary"		(totalSamples - self currentSampleIndex) < n ifTrue: [self startOver]].	mutex critical: [		lastBufferMSecs := Time millisecondClockValue.		self loadBuffersForSampleCount: (n * streamSamplingRate) // SoundPlayer samplingRate.		mixer playSampleCount: n into: aSoundBuffer startingAt: startIndex].! !!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 10/21/2001 09:45'!reset	super reset.	self startOver.	self createMixer.! !!StreamingMonoSound methodsFor: 'playing' stamp: 'stephaneducasse 2/4/2006 20:41'!samplesRemaining	"Answer the number of samples remaining to be played."	| result |	(stream isNil or: [stream closed]) ifTrue: [^ 0].	self repeat ifTrue: [^ 1000000].	result := (totalSamples - self currentSampleIndex) max: 0.	result <= 0 ifTrue: [self closeFile].	^ result! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!createMixer	"Create a mixed sound consisting of sampled sounds with one sound buffer's worth of samples."	| snd |	mixer := MixedSound new.	snd := SampledSound		samples: (SoundBuffer newMonoSampleCount: 2)  "buffer size will be adjusted dynamically"		samplingRate: streamSamplingRate.	mixer add: snd pan: 0.5 volume: volume.! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!currentSampleIndex	"Answer the index of the current sample."	| bytePosition frameIndex |	bytePosition := stream position - audioDataStart.	codec		ifNil: [^ bytePosition // 2]		ifNotNil: [			frameIndex := bytePosition // codec bytesPerEncodedFrame.			^ (frameIndex * codec samplesPerFrame) - leftoverSamples monoSampleCount].! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!loadBuffer: aSoundBuffer compressedSampleCount: sampleCount	"Load the given sound buffer from the compressed sample stream."	"Details: Most codecs decode in multi-sample units called 'frames'. Since the requested sampleCount is typically not an even multiple of the frame size, we need to deal with partial frames. The unused samples from a partial frame are retained until the next call to this method."	| n samplesNeeded frameCount encodedBytes r decodedCount buf j |	"first, use any leftover samples"	n := self loadFromLeftovers: aSoundBuffer sampleCount: sampleCount.	samplesNeeded := sampleCount - n.	samplesNeeded <= 0 ifTrue: [^ self].	"decode an integral number of full compression frames"	frameCount := samplesNeeded // codec samplesPerFrame.	encodedBytes := stream next: (frameCount * codec bytesPerEncodedFrame).	r := codec decodeFrames: frameCount from: encodedBytes at: 1 into: aSoundBuffer at: n + 1.	decodedCount := r last.	decodedCount >= samplesNeeded ifTrue: [^ self].	"decode one last compression frame to finish filling the buffer"	buf := SoundBuffer newMonoSampleCount: codec samplesPerFrame.	encodedBytes := stream next: codec bytesPerEncodedFrame.	codec decodeFrames: 1 from: encodedBytes at: 1 into: buf at: 1.	j := 0.	(n + decodedCount + 1) to: sampleCount do: [:i |		aSoundBuffer at: i put: (buf at: (j := j + 1))].	"save the leftover samples"	leftoverSamples := buf copyFrom: (j + 1) to: buf monoSampleCount.! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 08:03'!loadBuffer: aSoundBuffer uncompressedSampleCount: sampleCount	"Load the given sound buffer from the uncompressed sample stream."	"read directly into the sample buffer; count is in 32-bit words"	stream next: sampleCount // 2 into: aSoundBuffer startingAt: 1.	aSoundBuffer restoreEndianness.	"read the final sample if sampleCount is odd:"	sampleCount odd ifTrue: [aSoundBuffer at: sampleCount put: stream int16].! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!loadBuffersForSampleCount: count	"Load the sound buffers from the stream."	| snd buf sampleCount |	snd := mixer sounds first.	buf := snd samples.	buf monoSampleCount = count ifFalse: [		buf := SoundBuffer newMonoSampleCount: count.		snd setSamples: buf samplingRate: streamSamplingRate].	sampleCount := count min: (totalSamples - self currentSampleIndex).	sampleCount < count ifTrue: [buf primFill: 0].	codec		ifNil: [self loadBuffer: buf uncompressedSampleCount: sampleCount]		ifNotNil: [self loadBuffer: buf compressedSampleCount: sampleCount].	mixer reset.! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!loadFromLeftovers: aSoundBuffer sampleCount: sampleCount	"Load the given sound buffer from the samples leftover from the last frame. Answer the number of samples loaded, which typically is less than sampleCount."	| leftoverCount n |	leftoverCount := leftoverSamples monoSampleCount.	leftoverCount = 0 ifTrue: [^ 0].	n := leftoverCount min: sampleCount.	1 to: n do: [:i | aSoundBuffer at: i put: (leftoverSamples at: i)].	n < sampleCount		ifTrue: [leftoverSamples := SoundBuffer new]		ifFalse: [leftoverSamples := leftoverSamples copyFrom: n + 1 to: leftoverSamples size].	^ n! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!positionCodecTo: desiredSampleIndex	"Position to the closest frame before the given sample index when using a codec. If using the ADPCM codec, try to ensure that it is in sync with the compressed sample stream."	| desiredFrameIndex desiredPosition tmpStream tmpCodec byteBuf bufFrames sampleBuf frameCount n startOffset |	(codec isKindOf: ADPCMCodec) ifFalse: [		"stateless codecs (or relatively stateless ones, like GSM: just jump to frame boundary"		desiredFrameIndex := desiredSampleIndex // codec samplesPerFrame.		stream position: audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).		codec reset.		^ self].	"compute the desired stream position"	desiredFrameIndex := desiredSampleIndex // codec samplesPerFrame.	desiredPosition := audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).	"copy stream and codec"	(stream isKindOf: FileStream)		ifTrue: [tmpStream := (FileStream readOnlyFileNamed: stream name) binary]		ifFalse: [tmpStream := stream deepCopy].	tmpCodec := codec copy reset.	"reset the codec and start back about 30 seconds to try to get codec in sync"	startOffset := ((desiredFrameIndex - 80000) max: 0) * codec bytesPerEncodedFrame.	tmpStream position: audioDataStart + startOffset.	"decode forward to the desired position"	byteBuf := ByteArray new: (32000 roundTo: codec bytesPerEncodedFrame).	bufFrames := byteBuf size // codec bytesPerEncodedFrame.	sampleBuf := SoundBuffer newMonoSampleCount: bufFrames * codec samplesPerFrame.	frameCount := (desiredPosition - tmpStream position) // codec bytesPerEncodedFrame.	[frameCount > 0] whileTrue: [		n := bufFrames min: frameCount.		tmpStream next: n * codec bytesPerEncodedFrame into: byteBuf startingAt: 1.		tmpCodec decodeFrames: n from: byteBuf at: 1 into: sampleBuf at: 1.		frameCount := frameCount - n].	codec := tmpCodec.	stream position: tmpStream position.	(tmpStream isKindOf: FileStream) ifTrue: [tmpStream close].! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!readAIFFHeader	"Read an AIFF file header from stream."	| aiffReader |	aiffReader := AIFFFileReader new.	aiffReader readFromStream: stream mergeIfStereo: false skipDataChunk: true.	aiffReader channelCount = 1 ifFalse: [self error: 'not monophonic'].	aiffReader bitsPerSample = 16 ifFalse: [self error: 'not 16-bit'].	audioDataStart := headerStart + aiffReader channelDataOffset.	streamSamplingRate := aiffReader samplingRate.	totalSamples := aiffReader frameCount min: (stream size - audioDataStart) // 2.	codec := nil.! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!readHeader	"Read the sound file header from my stream."	| id |	stream position: headerStart.	id := (stream next: 4) asString.	stream position: headerStart.	id = '.snd' ifTrue: [^ self readSunAudioHeader].	id = 'FORM' ifTrue: [^ self readAIFFHeader].	self error: 'unrecognized sound file format'.! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!readSunAudioHeader	"Read a Sun audio file header from my stream."	| id headerBytes dataBytes format channelCount |	id := (stream next: 4) asString.	headerBytes := stream uint32.  "header bytes"	dataBytes := stream uint32.	format := stream uint32.	streamSamplingRate := stream uint32.	channelCount := stream uint32.	id = '.snd' ifFalse: [self error: 'not Sun audio format'].	dataBytes := dataBytes min: (stream size - headerBytes).	channelCount = 1 ifFalse: [self error: 'not monophonic'].	audioDataStart := headerStart + headerBytes.	codec := nil.	format = 1 ifTrue: [  "8-bit u-LAW"		codec := MuLawCodec new.		totalSamples := dataBytes.		^ self].	format = 3 ifTrue: [  "16-bit linear"		totalSamples := dataBytes // 2.		^ self].	format = 23 ifTrue: [  "ADPCM-4 bit (CCITT G.721)"		codec := ADPCMCodec new			initializeForBitsPerSample: 4 samplesPerFrame: 0.		totalSamples := (dataBytes // 4) * 8.		^ self].	format = 25 ifTrue: [  "ADPCM-3 bit (CCITT G.723)"		codec := ADPCMCodec new			initializeForBitsPerSample: 3 samplesPerFrame: 0.		totalSamples := (dataBytes // 3) * 8.		^ self].	format = 26 ifTrue: [  "ADPCM-5 bit (CCITT G.723)"		codec := ADPCMCodec new			initializeForBitsPerSample: 5 samplesPerFrame: 0.		totalSamples := (dataBytes // 5) * 8.		^ self].	format = 610 ifTrue: [  "GSM 06.10 (this format was added by Squeak)"		codec := GSMCodec new.		totalSamples := (dataBytes // 33) * 160.		^ self].	self error: 'unsupported Sun audio format ', format printString! !!StreamingMonoSound methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:41'!startOver	"Jump back to the first sample."	stream reopen; binary.	self readHeader.	stream position: audioDataStart.	leftoverSamples := SoundBuffer new.	lastBufferMSecs := 0.	mutex := Semaphore forMutualExclusion.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StreamingMonoSound class	instanceVariableNames: ''!!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!onFileNamed: fileName	"Answer an instance of me for playing the file with the given name."	| f |	f := FileDirectory default readOnlyFileNamed: fileName.	f ifNil: [^ self error: 'could not open ', fileName].	^ self new initStream: f headerStart: 0! !!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!onFileNamed: fileName headerStart: anInteger	"Answer an instance of me for playing audio data starting at the given position in the file with the given name."	| f |	f := FileDirectory default readOnlyFileNamed: fileName.	f ifNil: [^ self error: 'could not open ', fileName].	^ self new initStream: f headerStart: anInteger! !Object subclass: #SunAudioFileWriter	instanceVariableNames: 'stream headerStart'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!SunAudioFileWriter commentStamp: '<historical>' prior: 0!I encode monophonic sampled sounds in Sun audio (.au) file format. Sun audio files have a very simple format but can store both compressed and uncompressed sample data. I can write this format either directly into a file or onto any writable binary stream.!!SunAudioFileWriter methodsFor: 'initialization' stamp: 'stephaneducasse 2/4/2006 20:41'!setStream: aBinaryStream	"Initialize myself for writing on the given stream."	stream := aBinaryStream.	headerStart := aBinaryStream position.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 18:02'!appendBytes: aByteArray	"Append the given sample data to my stream."	stream nextPutAll: aByteArray.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!appendSamples: aSoundBuffer	"Append the given SoundBuffer to my stream."	| swapBytes s |	(stream isKindOf: StandardFileStream) ifTrue: [		"optimization: write sound buffer directly to file"		swapBytes := SmalltalkImage current  isLittleEndian.		swapBytes ifTrue: [aSoundBuffer reverseEndianness].  "make big endian"		stream next: (aSoundBuffer size // 2) putAll: aSoundBuffer startingAt: 1.  "size in words"		swapBytes ifTrue: [aSoundBuffer reverseEndianness].  "revert to little endian"		^ self].	"for non-file streams:"	s := WriteStream on: (ByteArray new: 2 * aSoundBuffer monoSampleCount).	1 to: aSoundBuffer monoSampleCount do: [:i | s int16: (aSoundBuffer at: i)].	self appendBytes: s contents.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 22:09'!closeFile	"Update the Sun audio file header to reflect the final size of the sound data. If my stream is a file stream, close it and, on a Macintosh, set the file type and creator to that used by SoundApp for Sun Audio files. (This does nothing on other platforms.)"	self ensureOpen.	self updateHeaderDataSize.	(stream isKindOf: StandardFileStream) ifTrue: [		stream close.		FileDirectory default setMacFileNamed: stream name type: 'ULAW' creator: 'SCPL'].! !!SunAudioFileWriter methodsFor: 'other' stamp: 'sd 1/30/2004 15:23'!ensureOpen	"Ensure that my stream is open."	stream closed ifTrue: [stream reopen; binary].! !!SunAudioFileWriter methodsFor: 'other' stamp: 'stephaneducasse 2/4/2006 20:41'!updateHeaderDataSize	"Update the Sun audio file header to reflect the final size of the sound data."	| byteCount |	byteCount := stream position - (headerStart + 24).	stream position: headerStart + 8.	stream uint32: byteCount.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 17:55'!writeHeaderSamplingRate: samplingRate	"Write a Sun audio file header for 16-bit linear format."	self writeHeaderSamplingRate: samplingRate format: 3.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 22:10'!writeHeaderSamplingRate: samplingRate format: audioFormat	"Write a Sun audio file header for the given sampling rate and format. Currently, only monophonic files are supported."	self ensureOpen.	stream position: headerStart.	stream nextPutAll: '.snd' asByteArray.	stream uint32: 24.	"header size in bytes"	stream uint32: 0.	"sample data size in bytes; fill in later"	stream uint32: audioFormat.	stream uint32: samplingRate truncated.	stream uint32: 1.	"channel count"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SunAudioFileWriter class	instanceVariableNames: ''!!SunAudioFileWriter class methodsFor: 'instance creation' stamp: 'stephaneducasse 2/4/2006 20:41'!onFileNamed: fileName	"Answer an instance of me on a newly created file with the given name."	| file |	file := (FileStream newFileNamed: fileName) binary.	^ self new setStream: file! !!SunAudioFileWriter class methodsFor: 'instance creation' stamp: 'jm 11/16/2001 17:50'!onStream: aBinaryStream	"Answer an instance of me on the given binary stream."	^ self new setStream: aBinaryStream! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'jm 11/21/2001 15:42'!codecForFormatCode: formatCode	"Answer the codec for the given Sun audio file format number."	formatCode = 1 ifTrue: [^ MuLawCodec new].	formatCode = 3 ifTrue: [^ nil].  "uncompressed"	formatCode = 23 ifTrue: [^ ADPCMCodec newBitsPerSample: 4].	formatCode = 25 ifTrue: [^ ADPCMCodec newBitsPerSample: 3].	formatCode = 26 ifTrue: [^ ADPCMCodec newBitsPerSample: 5].	formatCode = 610 ifTrue: [^ GSMCodec new].	self error: 'unsupported Sun audio format'! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'stephaneducasse 2/4/2006 20:41'!formatCodeForCompressionType: aString	"Answer the Sun audio file format number for the given compression type name."	| lowercase |	lowercase := aString asLowercase.	'mulaw' = lowercase ifTrue: [^ 1].	'none' = lowercase ifTrue: [^ 3].	'adpcm3' = lowercase ifTrue: [^ 25].	'adpcm4' = lowercase ifTrue: [^ 23].	'adpcm5' = lowercase ifTrue: [^ 26].	'gsm' = lowercase ifTrue: [^ 610].	self error: 'unknown compression style'! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'stephaneducasse 2/4/2006 20:41'!storeSampledSound: aSampledSound onFileNamed: fileName compressionType: aString	"Store the samples of the given sampled sound on a file with the given name using the given type of compression. See formatCodeForCompressionType: for the list of compression types."	| fmt codec f compressed |	fmt := self formatCodeForCompressionType: aString.	codec := self codecForFormatCode: fmt.	f := self onFileNamed: fileName.	f writeHeaderSamplingRate: aSampledSound originalSamplingRate format: fmt.	codec		ifNil: [f appendSamples: aSampledSound samples]		ifNotNil: [			compressed := codec encodeSoundBuffer: aSampledSound samples.			f appendBytes: compressed].	f closeFile.! !FMSound subclass: #UnloadedSound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!UnloadedSound commentStamp: '<historical>' prior: 0!Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnloadedSound class	instanceVariableNames: ''!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!default	"UnloadedSound default play"	| snd p |	snd := super new modulation: 1 ratio: 1.	p := OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !Envelope subclass: #VolumeEnvelope	instanceVariableNames: 'currentVol targetVol mSecsForChange'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t := (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i := self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol := points last y * decayScale.			mSecsForChange := 0.			nextRecomputeTime := mSecs + 1000000.			^ self].		targetVol := (points at: i) y * decayScale.		mSecsForChange := (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime := mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i := self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol := (points at: i) y.		mSecsForChange := ((points at: i) x - mSecs) max: 4.		nextRecomputeTime := mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime := loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol := (points at: loopEndIndex) y.		mSecsForChange := 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime := mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime := loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t := loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i := self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol := (points at: i) y.	mSecsForChange := ((points at: i) x - t) max: 4.	nextRecomputeTime := (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!reset	"Reset the state for this envelope."	super reset.	target initialVolume: points first y * scale.	nextRecomputeTime := 0.! !!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'jm 2/4/98 07:27'!updateSelector	"Needed by the envelope editor."	^ #volume:! !!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange := 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !!VolumeEnvelope methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:41'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale := aNumber asFloat.! !SoundCodec subclass: #WaveletCodec	instanceVariableNames: 'fwt samplesPerFrame nLevels alpha beta'	classVariableNames: ''	poolDictionaries: ''	category: 'Sound-Synthesis'!!WaveletCodec commentStamp: '<historical>' prior: 0!The Wavelet codec performs a wavelet transform on the original data.  It then achieves its compression by thresholding the transformed data, converting all values below a given magnitude to zero, and then run-coding the resulting data.  The run-coding provides automatic variable compression depending on the parameters chosen.As is, this codec achieves reasonable reproduction at 10:1 compression, although the quality from the GSMCodec is definitely better.  I feel that the quality would be comparable if uLaw scaling were introduced prior to thresholding.The nice thing about using wavelets is there are numerous factors to play with for better performance:	nLevels - the "order" of the transform performed	alpha and beta - these specify the wavelet shape (some are better for speech)	the actual threshold usedBy simply changing these parameters, one can easily vary the compression achieved from 5:1 to 50:1, and listen to the quality at each step.The specific format for an encoded buffer is as follows:	4 bytes: frameCount.	4 bytes: samplesPerFrame.	4 bytes: nLevels.	4 bytes: alpha asIEEE32BitWord.	4 bytes: beta asIEEE32BitWord.	frameCount occurrences of...		2 bytes: frameSize in bytes, not including these 2			may be = 0 for complete silence, meaning no scale even.		4 bytes: scale asIEEE32BitWord.		A series of 1- or 2-byte values encoded as follows:			0-111: 	a run of N+1 consecutive 0's;			112-127:	a run of (N-112)*256 + nextByte + 1 consecutive 0's;			128-255:	a 15-bit signed value = (N*256 + nextByte) - 32768 - 16384.!!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 14:22'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	^ 0! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'stephaneducasse 2/4/2006 20:41'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffArray scale i c nullCount samples sourceFrameEnd frameSize inStream val |	inStream := ReadStream on: srcByteArray from: srcIndex to: srcByteArray size.	"frameCount := " inStream nextNumber: 4.	samplesPerFrame := inStream nextNumber: 4.	nLevels := inStream nextNumber: 4.	alpha := Float fromIEEE32Bit: (inStream nextNumber: 4).	beta := Float fromIEEE32Bit: (inStream nextNumber: 4).	fwt ifNil:		["NOTE: This should read parameters from the encoded data"		fwt := FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	frameBase := dstIndex.	coeffArray := fwt coeffs.  "A copy that we can modify"	1 to: frameCount do:		[:frame | 		"Decode the scale for this frame"		frameSize := inStream nextNumber: 2.		sourceFrameEnd := frameSize + inStream position.		scale := Float fromIEEE32Bit: (inStream nextNumber: 4).		"Expand run-coded samples to scaled float values."		i := 5.		[i <= coeffArray size]			whileTrue:			[c := inStream next.			c < 128				ifTrue: [nullCount := c < 112							ifTrue: [c + 1]							ifFalse: [(c-112)*256 + inStream next + 1].						i to: i + nullCount - 1 do: [:j | coeffArray at: j put: 0.0].						i := i + nullCount]				ifFalse: [val := (c*256 + inStream next) - 32768 - 16384.						coeffArray at: i put: val * scale.						i := i + 1]].		"Copy float values into the wavelet sample array"					fwt coeffs: coeffArray.		"Compute the transform"		fwt transformForward: false.		"Determine the scale for this frame"		samples := fwt samples.		samples size = samplesPerFrame ifFalse: [self error: 'frame size error'].		1 to: samples size do:			[:j | dstSoundBuffer at: frameBase + j - 1 put: (samples at: j) asInteger].		inStream position = sourceFrameEnd ifFalse: [self error: 'frame size error'].		frameBase := frameBase + samplesPerFrame].	^ Array with: inStream position + 1 - srcIndex			with: frameBase - dstIndex! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'stephaneducasse 2/4/2006 20:41'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| frameBase coeffs maxVal minVal c scale nullCount frameI outFrameSize threshold sm outStream cMin val |	threshold := 2000.	fwt ifNil:		[samplesPerFrame := self samplesPerFrame.		nLevels := 8.		"Here are some sample mother wavelets, with the compression achieved on a		sample of my voice at a threshold of 2000:									compression achieved "		alpha := 0.0.  beta := 0.0.		"12.1"		alpha := 1.72.  beta := 1.51.	"14.0"		alpha := -1.86.  beta := -1.53.	"14.4"		alpha := 1.28.  beta := -0.86.	"15.9"		alpha := -1.15.  beta := 0.69.	"16.0"		fwt := FWT new.		fwt nSamples: samplesPerFrame nLevels: nLevels.		fwt setAlpha: alpha beta: beta].	(outStream := WriteStream on: dstByteArray from: dstIndex to: dstByteArray size)		nextNumber: 4 put: frameCount;		nextNumber: 4 put: samplesPerFrame;		nextNumber: 4 put: nLevels;		nextNumber: 4 put: alpha asIEEE32BitWord;		nextNumber: 4 put: beta asIEEE32BitWord.	frameBase := srcIndex.	1 to: frameCount do:		[:frame | 		"Copy float values into the wavelet sample array"				fwt samples: ((frameBase to: frameBase + samplesPerFrame-1) 				collect: [:i | (srcSoundBuffer at: i) asFloat]).		"Compute the transform"		fwt transformForward: true.		frameI := outStream position+1.  "Reserve space for frame size"		outStream nextNumber: 2 put: 0.		"Determine and output the scale for this frame"		coeffs := fwt coeffs.		maxVal := 0.0.  minVal := 0.0.		5 to: coeffs size do:			[:i | c := coeffs at: i.			c > maxVal ifTrue: [maxVal := c].			c < minVal ifTrue: [minVal := c]].		scale := (maxVal max: minVal negated) / 16000.0.  "Will scale all to -16k..16k: 15 bits"		outStream nextNumber: 4 put: scale asIEEE32BitWord.		"Copy scaled values, with run-coded sequences of 0's, to destByteArray"		nullCount := 0.		cMin := threshold / scale.		5 to: coeffs size do:			[:i | c := (coeffs at: i) / scale.			c abs < cMin			ifTrue: ["Below threshold -- count nulls."					nullCount := nullCount + 1]			ifFalse: ["Above threshold -- emit prior null count and this sample."					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1].						nullCount := 0].						val := c asInteger + 16384 + 32768.  "Map -16k..16k into 32k..64k"						outStream nextNumber: 2 put: val]].					nullCount > 0 ifTrue:						[nullCount <= 112						ifTrue: [outStream nextNumber: 1 put: nullCount-1]						ifFalse: [outStream nextNumber: 2 put: (112*256) + nullCount-1]].		outFrameSize := outStream position+1 - frameI - 2.  "Write frame size back at the beginning"		(WriteStream on: dstByteArray from: frameI to: dstByteArray size)			nextNumber: 2 put: outFrameSize.		frameBase := frameBase + samplesPerFrame]."This displays a temporary indication of compression achieved"sm := TextMorph new contents: (((frameBase - srcIndex) *2.0 / (outStream position+1 - dstIndex) truncateTo: 0.1) printString , ' : 1') asText allBold.sm position: Sensor cursorPoint + (-20@30).ActiveWorld addMorph: sm.World doOneCycleNow.sm delete.	outStream position > dstByteArray size ifTrue:		["The calling routine only provides buffer space for compression of 2:1 or better.  If you are just testing things, you can increase it to, eg, codeFrameSize := frameSize*3, which would be sufficient for a threshold of 0 (lossless conversion)."		self error: 'Buffer overrun'].	^ Array with: frameBase - srcIndex			with: outStream position+1 - dstIndex! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 16:49'!frameCount: aByteArray	"Compute the frame count for this byteArray.  This default computation will have to be overridden by codecs with variable frame sizes."	^ (ReadStream on: aByteArray) nextNumber: 4.! !!WaveletCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 14:17'!samplesPerFrame	"Answer the number of sound samples per compression frame."	^ 4096! !AbstractSound initialize!BaseSoundSystem initialize!FMSound initialize!LoopedSampledSound initialize!SampledSound initialize!SoundBuffer initialize!MuLawCodec initialize!SoundPlayer initialize!SoundRecorder initialize!