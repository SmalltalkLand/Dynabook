

----SNAPSHOT----(31 July 2020 07:37:54) build-0.109.image priorSource: 16638454!

----SNAPSHOT----(31 July 2020 07:39:15) build-0.109.image priorSource: 16640315!
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 07:40:56' prior: 50851606!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEvent with: evt copy.] fork.
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 07:42:42' prior: 50851666!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEventBase with: evt copy.] fork.
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:43:44'!
eventSpawnerProcess
| arr |
arr _ OrderedCollection new.
self when: #inputEventBase send: #add: to: arr.
! !

----SNAPSHOT----(31 July 2020 07:44:00) build-0.109.image priorSource: 16640397!
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 07:44:03' prior: 50851721!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEventBase with: evt copy.] "fork" value.
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:45:13' prior: 50851776!
eventSpawnerProcess
| arr |
arr _ OrderedCollection new.
self when: #inputEventBase send: #add: to: arr.
^[arr do: [:x|self triggerEvent: #inputEvent with: x]. arr _ OrderedCollection new] fork! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:47:43' prior: 50851840!
eventSpawnerProcess
| arr proc |
arr _ OrderedCollection new.
self when: #inputEventBase send: #add: to: arr.
proc _ [arr do: [:x|self triggerEvent: #inputEvent with: x]. arr _ OrderedCollection new] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase. ].
^proc! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:48:47' prior: 50851849!
eventSpawnerProcess
| arr proc |
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [arr do: [:x|self triggerEvent: #inputEvent with: x]. arr _ OrderedCollection new] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:49:18' prior: 50851863!
eventSpawnerProcess
| arr proc |
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [[arr do: [:x|self triggerEvent: #inputEvent with: x]. arr _ OrderedCollection new] repeat] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !

OrderedCollection!
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:53:30' prior: 50851880!
eventSpawnerProcess
| arr proc |
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [[[arr size = 0] whileFalse: [arr do: [:x|self triggerEvent: #inputEvent with: x. arr remove: x ifAbsent: []]]. arr _ OrderedCollection new] repeat] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:54:14' prior: 50851898!
eventSpawnerProcess
| arr proc |
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [[[arr size = 0] whileFalse: [arr do: [:x|self triggerEvent: #inputEvent with: x. arr remove: x ifAbsent: []]]] repeat] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !
!EventSensor class methodsFor: 'accessing' stamp: 'GDK 7/31/2020 07:58:05'!
usesSpawner
^false! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:58:24' prior: 50851917!
eventSpawnerProcess
| arr proc |
self class.
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [[[arr size = 0] whileFalse: [arr do: [:x|self triggerEvent: #inputEvent with: x. arr remove: x ifAbsent: []]]] repeat] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !
!EventSensor methodsFor: 'private' stamp: 'GDK 7/31/2020 07:58:51' prior: 50851939!
eventSpawnerProcess
| arr proc |
self class usesSpawner ifFalse: [^[] fork].
arr _ OrderedCollection new.
self triggerEvent: #terminateEventSpawner.
self when: #inputEventBase send: #add: to: arr.
proc _ [[[arr size = 0] whileFalse: [arr do: [:x|self triggerEvent: #inputEvent with: x. arr remove: x ifAbsent: []]]] repeat] fork.
self when: #terminateEventSpawner send: #value to: [proc terminate. self removeActionsWithReceiver: arr forEvent: #inputEventBase.  self removeActionsForEvent: #terminateEventSpawner].
^proc! !

----SNAPSHOT----(31 July 2020 07:59:16) build-0.109.image priorSource: 16644204!
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 07:59:18' prior: 50851785!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEventBase with: evt copy.] perform: #value.
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !

----SNAPSHOT----(31 July 2020 08:00:01) build-0.109.image priorSource: 16650411!
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 08:00:03' prior: 50851979!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEventBase with: evt copy.] perform: (self class usesSpawner ifTrue: [#value] ifFalse: [#fork]).
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !
!EventSensor methodsFor: 'private-I/O' stamp: 'GDK 7/31/2020 08:00:37' prior: 50852037!
processSensorEvent: evt discardingMouseEvents: discardMouseEvents
	"Process a single event. This method is run at high priority."
	| type |
	type _ evt at: 1.

	"Check if the event is a user interrupt"
	(type = EventSensor eventTypeKeyboard and: [ (evt at: 4) = 0 and: [
		((evt at: 3) bitOr: (((evt at: 5) bitAnd: 8) bitShift: 8)) = interruptKey]])
			 ifTrue: [
				"interrupt key is meta - not reported as event"
				^interruptSemaphore signal].

	"Store the event in the queue if there's any"
	type = EventSensor eventTypeMouse ifTrue: [
		"Only swap secondary and tertiary buttons if there is no command or option modifier keys.
		This swap is done so a 3-button mouse  is
			left -> mouseButton1 (select)
			center -> mouseButton3 (halo)
			right -> mouseButton2 (menu).
		This is only needed on the Mac, Window VM does this mapping by default.
		We avoid ding the swap if there are modifier keys, because in that case the buttons were generated by the VM as follows:
			left -> mouseButton1
			macOption + left -> mouseButton3
			command + left -> mouseButton2,
		but Mac users are already used to 
			macOption + left -> menu
			command + left -> halo.
		See #installMouseDecodeTable"
		((evt at: 6) anyMask: 12) ifFalse: [
			evt at: 5 put: (ButtonDecodeTable at: (evt at: 5) + 1)]].
	
	(discardMouseEvents and: [ type = EventSensor eventTypeMouse ]) ifFalse: [
		self queueEvent: evt ].
[self triggerEvent: #inputEventBase with: evt copy.self class usesSpawner ifFalse: [self triggerEvent: #inputEvent with: evt copy]] perform: (self class usesSpawner ifTrue: [#value] ifFalse: [#fork]).
	"Update state for InputSensor."
	type = EventSensor eventTypeMouse ifTrue: [
		self processMouseSensorEvent: evt ].
	type = EventSensor eventTypeKeyboard ifTrue: [
		self processKeyboardSensorEvent: evt ]! !