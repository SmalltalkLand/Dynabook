"MC2-Preload-Squeak310-cwp.1timestamp: 4 August 2008 10:38:38 pmauthor: 'Colin Putney <cputney@wiresong.ca>'Everything needed to load Monticello 2.0 in Squeak 3.10."!Object subclass: #OBAnnouncement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!Object subclass: #OBAnnouncer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBAnnouncer instVarNames includes: 'subscriptions') ifFalse:	[OBAnnouncer addInstVarName: 'subscriptions']!!OBAnnouncer methodsFor: 'subscription'!announce: anObject	| ann |	ann _ anObject asAnnouncement.	subscriptions keysAndValuesDo:		[:class :action |		(ann isKindOf: class) ifTrue: [action valueWithArguments: (Array with: ann)]].	^ ann! !!OBAnnouncer methodsFor: 'initialize-release'!initialize	subscriptions _ IdentityDictionary new.! !!OBAnnouncer methodsFor: 'subscription'!observe: aClass do: aValuable 	| actions |	actions _ subscriptions at: aClass ifAbsent: [ActionSequence new].	subscriptions at: aClass put: (actions copyWith: aValuable).! !!OBAnnouncer methodsFor: 'subscription'!observe: aClass send: aSelector to: anObject	self		observe: aClass		do: (MessageSend receiver: anObject selector: aSelector)! !!OBAnnouncer methodsFor: 'subscription'!unsubscribe: anObject	subscriptions keysAndValuesDo:		[:class :actions |		subscriptions at: class put: (actions reject: [:ea | ea receiver == anObject])].	subscriptions keysAndValuesRemove: [:key :value | value isEmpty]! !!OBAnnouncer class methodsFor: 'instance creation'!current	^ OBAnnouncerRequest signal! !!OBAnnouncer class methodsFor: 'instance creation'!new	^ self basicNew initialize! !Notification subclass: #OBAnnouncerRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!TestCase subclass: #OBAnnouncerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBAnnouncerTest instVarNames includes: 'announcer') ifFalse:	[OBAnnouncerTest addInstVarName: 'announcer']!!OBAnnouncerTest methodsFor: 'tests' stamp: 'cwp 6/3/2006 21:21'!testBlock	| announcement |	announcer _ OBAnnouncer new.	announcer		observe: OBSelectionChanged		do: [:arg | announcement _ arg].	announcer announce: OBSelectionChanged.	self assert: (announcement isKindOf: OBSelectionChanged)! !!OBAnnouncerTest methodsFor: 'tests' stamp: 'cwp 6/3/2006 21:21'!testInstance	| announcement |	announcer _ OBAnnouncer new.	announcer		observe: OBSelectionChanged		do: [:arg | announcement _ arg].	announcer announce: OBSelectionChanged new.	self assert: (announcement isKindOf: OBSelectionChanged)! !!OBAnnouncerTest methodsFor: 'tests' stamp: 'cwp 6/3/2006 21:22'!testMessage	| announcement |	announcer _ OBAnnouncer new.	announcer		observe: OBSelectionChanged		send: #value:		to: [:ann | announcement _ ann].	announcer announce: OBSelectionChanged.	self assert: (announcement isKindOf: OBSelectionChanged)! !TestCase subclass: #OBBarMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!(OBBarMorphTest instVarNames includes: 'bar') ifFalse:	[OBBarMorphTest addInstVarName: 'bar']!!OBBarMorphTest methodsFor: 'simulating' stamp: 'cwp 3/11/2007 15:51'!push: aString	| button |	button _ bar submorphs detect: [:b | b label contents = aString].	button performAction! !Object subclass: #OBBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!!OBBrowser commentStamp: 'cwp 1/7/2005 23:17' prior: 0!OBBrowser is the core of OmniBrower. It's the root object for each browser and the model for the SystemWindows which display them. Its main responsibily is managing panels, particularly passing update messages between them.On the class side, OBBrowser provides some default settings for creating and opening browsers. Subclasses can override these settings to acheive customized behavior.iVars:panels	- A collection of objects which manage submorphs of the browser's SystemWindow.cVars:MetaGraphs - A dictionary matching names to metagraphs!(OBBrowser instVarNames includes: 'panels') ifFalse:	[OBBrowser addInstVarName: 'panels']!(OBBrowser instVarNames includes: 'announcer') ifFalse:	[OBBrowser addInstVarName: 'announcer']!(OBBrowser instVarNames includes: 'cmdFactories') ifFalse:	[OBBrowser addInstVarName: 'cmdFactories']!!OBBrowser methodsFor: 'accessing'!addPanel: aPanel	panels add: aPanel.	aPanel browser: self.! !!OBBrowser methodsFor: 'updating'!announce: anObject	^ self announcer announce: anObject! !!OBBrowser methodsFor: 'accessing'!announcer	^ announcer! !!OBBrowser methodsFor: 'building'!buildGroup: aCollection on: aBuilder 	^aBuilder verticalGroupWith: [aCollection do: [:ea | ea buildOn: aBuilder]]! !!OBBrowser methodsFor: 'building'!buildOn: aBuilder 	| group |	^aBuilder window: self		with: 			[group := OrderedCollection with: panels first.			panels allButFirst do: 					[:panel | 					group last vResizing = #spaceFill 						ifTrue: 							[self buildGroup: group on: aBuilder.							group := OrderedCollection new].					group add: panel].			self buildGroup: group on: aBuilder]! !!OBBrowser methodsFor: 'opening'!close	^ OBCloseRequest signal: self! !!OBBrowser methodsFor: 'accessing'!cmdFactories	^ cmdFactories! !!OBBrowser methodsFor: 'initializing'!commandSelectors	| all obsolete commands |	all _ self class allSelectors.	obsolete _ Set new.	all do: [:ea | (ea beginsWith: 'obsolete') ifTrue: [obsolete add: (self perform: ea)]].	commands _ all select: [:ea | ea beginsWith: 'cmd'].	^ commands reject: [:ea | obsolete includes: ea]! !!OBBrowser methodsFor: 'accessing'!currentNode	^self navigationPanel currentNode! !!OBBrowser methodsFor: 'accessing'!currentOrRootNode	^self navigationPanel currentOrRootNode! !!OBBrowser methodsFor: 'building'!defaultBackgroundColor	^ Color gray veryMuchLighter! !!OBBrowser methodsFor: 'accessing'!defaultLabel	^ self class titleForRoot: self root! !!OBBrowser methodsFor: 'updating'!dontTranscribe	self announcer unsubscribe: self.	self subscribe.! !!OBBrowser methodsFor: 'initializing'!initialize	panels _ OrderedCollection new.	announcer _ OBAnnouncer new.	cmdFactories _ #().	self subscribe.! !!OBBrowser methodsFor: 'initializing'!initializeCommands		cmdFactories _ Array streamContents: 		[:stream | 		(self commandSelectors) do: 			[:selector | 			| result |			result := self perform: selector.			result isCollection 				ifTrue: [stream nextPutAll: result]				ifFalse: [stream nextPut: result]]].! !!OBBrowser methodsFor: 'navigating'!jumpTo: aNode 	self navigationPanel jumpTo: aNode! !!OBBrowser methodsFor: 'navigating'!jumpToRoot	^self navigationPanel jumpToRoot! !!OBBrowser methodsFor: 'callbacks'!labelString	| label |	label := self navigationPanel labelString.	^label 		ifNil: [self defaultLabel]		ifNotNil: [self defaultLabel , ': ' , label]! !!OBBrowser methodsFor: 'accessing'!navigationPanel	^ panels 		detect: [:ea | ea isNavigation] 		ifNone: [self error: 'No navigation panel configured']! !!OBBrowser methodsFor: 'callbacks'!okToChange	^ (self announcer announce: OBAboutToChange) isVetoed not! !!OBBrowser methodsFor: 'opening'!open	^ OBBrowseRequest signal: self! !!OBBrowser methodsFor: 'accessing'!panels	^ panels! !!OBBrowser methodsFor: 'updating'!relabel: ann	self changed: #relabel.! !!OBBrowser methodsFor: 'navigating'!root	^self navigationPanel root! !!OBBrowser methodsFor: 'updating'!scanNodeCommands: ann 	(cmdFactories select: [:ea | ea takesNodes]) 		do: [:ea | ann addFactory: ea]! !!OBBrowser methodsFor: 'updating'!scanTextCommands: ann 	(cmdFactories select: [:ea | ea takesText]) do: [:ea | ann addFactory: ea]! !!OBBrowser methodsFor: 'accessing'!selectionPath	^self navigationPanel selectionPath! !!OBBrowser methodsFor: 'initializing'!setMetaNode: aMetaNode node: aNode 	self navigationPanel setMetaNode: aMetaNode node: aNode.	self initializeCommands! !!OBBrowser methodsFor: 'updating'!signalRefresh	self announcer announce: OBRefreshRequired! !!OBBrowser methodsFor: 'updating'!subscribe	(self announcer)		observe: OBSelectionChanged			send: #relabel:			to: self;		observe: OBNodeCommandScan			send: #scanNodeCommands:			to: self;		observe: OBTextCommandScan			send: #scanTextCommands:			to: self! !!OBBrowser methodsFor: 'updating'!transcribe	self announcer observe: OBAnnouncement do: [:ann | Transcript cr; show: ann].! !!OBBrowser class methodsFor: 'configuration'!defaultMetaNode	self subclassResponsibility! !!OBBrowser class methodsFor: 'configuration'!defaultRootNode	self subclassResponsibility! !!OBBrowser class methodsFor: 'configuration'!definitionPanel	^ OBDefinitionPanel new! !!OBBrowser class methodsFor: 'configuration'!maxPanes	^ self paneCount! !!OBBrowser class methodsFor: 'instance creation'!metaNode: metaNode node: rootNode 	^ self metaNode: metaNode root: rootNode selection: nil panels: self panels! !!OBBrowser class methodsFor: 'instance creation'!metaNode: metaNode root: rootNode selection: selectedNode	^ self metaNode: metaNode root: rootNode selection: selectedNode panels: self panels! !!OBBrowser class methodsFor: 'instance creation'!metaNode: metaNode root: rootNode selection: selectedNode panels: panels	| browser |	browser _ self basicNew initialize.	panels do: [:ea | browser addPanel: ea].	browser setMetaNode: metaNode node: rootNode.	selectedNode ifNotNil: [browser jumpTo: selectedNode].	^ browser! !!OBBrowser class methodsFor: 'configuration'!minPanes	^ self paneCount! !!OBBrowser class methodsFor: 'configuration'!navigationPanel	^ OBColumnPanel minPanes: self minPanes maxPanes: self maxPanes! !!OBBrowser class methodsFor: 'instance creation'!new	^ self 		metaNode: self defaultMetaNode		root: self defaultRootNode		selection: nil		panels: self panels! !!OBBrowser class methodsFor: 'auto opening'!open	^ self new open! !!OBBrowser class methodsFor: 'auto opening'!openRoot: aNode	^ (self root: aNode) open! !!OBBrowser class methodsFor: 'auto opening'!openRoot: rootNode selection: selectedNode	^ (self root: rootNode selection: selectedNode) open! !!OBBrowser class methodsFor: 'configuration'!optionalButtonPanel	^ OBPlatform current optionalButtons ifTrue: [OBFixedButtonPanel new]! !!OBBrowser class methodsFor: 'configuration'!optionalButtons	^ #()! !!OBBrowser class methodsFor: 'configuration'!paneCount	^ 4! !!OBBrowser class methodsFor: 'configuration'!panels	^ (Array with: self navigationPanel with: self optionalButtonPanel with: self definitionPanel)		reject: [:ea | ea isNil]! !!OBBrowser class methodsFor: 'instance creation'!root: aNode 	^ self root: aNode selection: nil! !!OBBrowser class methodsFor: 'instance creation'!root: rootNode selection: selectedNode	^ self metaNode: self defaultMetaNode root: rootNode selection: selectedNode panels: self panels! !!OBBrowser class methodsFor: 'instance creation'!selection: selectedNode	^ self root: self defaultRootNode selection: selectedNode! !!OBBrowser class methodsFor: 'configuration'!title	^ 'OmniBrowser'! !!OBBrowser class methodsFor: 'configuration'!titleForRoot: aNode	^ self title! !TestCase subclass: #OBBrowserCommandsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBBrowserCommandsTest instVarNames includes: 'browser') ifFalse:	[OBBrowserCommandsTest addInstVarName: 'browser']!!OBBrowserCommandsTest methodsFor: 'tests' stamp: 'cwp 3/13/2007 00:46'!test01ScanFindsCommandCreationMethods	| called scan |	called := false.	browser := OBFakeCommandBrowser withAction: [called := true].	scan := browser announce: OBNodeCommandScan.	(scan commandsOn: nil for: nil) first execute.	self assert: called! !!OBBrowserCommandsTest methodsFor: 'tests' stamp: 'cwp 9/18/2007 22:19'!test02CommandSelectorsFindsCommands	browser := OBFakeCommandBrowser new.	self assert: (browser commandSelectors includes: #cmdPluggable)	! !!OBBrowserCommandsTest methodsFor: 'tests' stamp: 'cwp 9/18/2007 22:25'!test03CommandSelectorsFindsCommands	browser := OBFakeCommandBrowser new.	self deny: (browser commandSelectors includes: #cmdObsolete)	! !TestCase subclass: #OBBrowserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBBrowserTest instVarNames includes: 'model') ifFalse:	[OBBrowserTest addInstVarName: 'model']!(OBBrowserTest instVarNames includes: 'widget') ifFalse:	[OBBrowserTest addInstVarName: 'widget']!!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 9/14/2005 22:22'!assertAListIncludes: anArrayOfStrings	self listMorphs 			detect: [:m | | list |					list _ m getListDelicately collect: [:ea | ea  asString withBlanksTrimmed].					list includesAllOf: anArrayOfStrings]			ifNone: [self assert: false].! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 3/14/2004 13:10'!assertAListMatches: strings	| list |	self listMorphs			detect:	[:m | 					list _ m getListDelicately.					(list size = strings size) and: [list includesAllOf: strings]]			ifNone: [self assert: false].! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/10/2007 00:27'!assertButtonSelected: aString	| button |	button _ (self morphsOfClass: OBFakeButton) 				detect: [:m | m label contents = aString]				ifNone: [self signalFailure: 'No button labeled ', aString].	self assert: button isOn! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 8/19/2007 23:46'!assertCurrentItemIs: expected	| actual |	actual _ self currentItem withBlanksTrimmed.	self assert: actual = expected! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 3/14/2004 12:47'!assertListAt: index contains: items	| list |	list _ self listItemsAt: index.	self assert: (list size = items size).	self assert: (list includesAllOf: items).! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 9/14/2005 23:05'!assertListAt: index includes: items	| list |	list _ (self listItemsAt: index) collect: [:ea | ea asString withBlanksTrimmed].	self assert: (list includesAllOf: items).! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 1/23/2004 22:35'!assertMenuContains: aString	| item |	item _ self menuItemNamed: aString.	self assert: item notNil! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/9/2007 23:15'!assertNoButtonsVisible	self 		assert: ((widget findDeeplyA: OBFakeScroller) 				findDeeplyA: OBFakeButton) isNil! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/9/2007 01:00'!assertSelectedTextIs: aString 	| text selection |	widget := self textMorph.	text := widget text.	selection := widget selectionInterval.	self assert: (text atAll: selection) asString = aString! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 3/16/2004 20:33'!assertTextIs: aString	| actual |	actual _ self textMorph text.	self assert: actual = aString.! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/9/2007 00:56'!assertTextIsSelected	self assert: self textMorph getSelection size = self textMorph text size! !!OBBrowserTest methodsFor: 'configuration' stamp: 'cwp 8/22/2007 23:14'!browserClass	self subclassResponsibility! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/9/2007 23:51'!clickButtonLabeled: aString	| button |	button _ (self morphsOfClass: OBFakeButton) 				detect: [:m | m label contents = aString]				ifNone: [self signalFailure: 'No button labeled ', aString].	button click! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 9/14/2005 22:22'!currentItem	^ self currentList selection asString! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 5/13/2004 10:59'!currentList	^ self listMorphs reversed 						detect: [:list | list selection notNil]						ifNone: [self signalFailure: 'No item is currently selected']! !!OBBrowserTest methodsFor: 'asserting' stamp: 'cwp 3/14/2004 13:11'!denyAListIncludes: anArrayOfStrings	self listMorphs 			detect: [:m | m getListDelicately includesAllOf: anArrayOfStrings]			ifNone: [^ self].	self assert: false.! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 12/17/2003 15:08'!deselect: aString	| listMorph |	listMorph _ self findListContaining: aString.	listMorph changeModelSelection: 0.! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 2/28/2004 13:50'!drag: nodeName	| item list |	item _ StringMorph contents: nodeName asString.	list _ self findListContaining: nodeName.	^ list model dragPassengerFor: item inMorph: list! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 2/28/2004 13:50'!drag: passangerName to: targetName	| passanger |	passanger _ self drag: passangerName.	self drop: passanger on: targetName! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/13/2007 22:45'!drop: aPassenger on: targetName	| list |	list _ self findListContaining: targetName.	self assert: list notNil.	self assert: (list canDrop: aPassenger on: targetName).	list drop: aPassenger on: targetName.! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/8/2007 02:24'!editText: aString	self textMorph text: aString! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 9/14/2005 09:00'!findListContaining: aString	^ self listMorphs 		detect: [:m | | list |				list _ m getListDelicately collect: [:ea | ea asString withBlanksTrimmed].				list includes: aString] 		ifNone: [nil]! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/8/2007 01:44'!forceLayout	widget update! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 3/14/2004 13:11'!listItemsAt: index	^ (self listMorphs 		at: index 		ifAbsent: [self signalFailure: 'List ', index asString, ' does not exist'])			getListDelicately	! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 7/8/2007 01:39'!listMorphs	^ self morphsOfClass: OBFakeList! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 1/26/2004 21:53'!menuItemNamed: aString	| lists current |	lists _ self listMorphs.	current _ lists reversed detect: [:list | list selection notNil].	^ (current getMenu: true) itemWithWording: aString.! !!OBBrowserTest methodsFor: 'running' stamp: 'avi 9/17/2005 01:39'!metagraph	^ self browserClass defaultMetaNode! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 7/7/2007 22:12'!morphNamed: aString 	^widget findDeepSubmorphThat: [:m | m knownName = aString]		ifAbsent: [self signalFailure: aString , 'not found']! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 7/8/2007 01:37'!morphsOfClass: aClass 	| found |	found := OrderedCollection new.	widget withAllChildrenDo: [:m | (m isMemberOf: aClass) ifTrue: [found add: m]].	^found! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 3/14/2004 13:14'!mouseMoveEventIn: name	| rect plm |	plm _ self findListContaining: name.	rect _ plm listMorph rectForRow: (plm getListDelicately indexOf: name).	^ MouseMoveEvent new		setType: #mouseEnter		startPoint: rect center + (rect width @ 0)		endPoint: rect center		trail: #()		buttons: 4		hand: ActiveHand		stamp: Time millisecondClockValue! !!OBBrowserTest methodsFor: 'configuration' stamp: 'cwp 8/22/2007 23:18'!node	self subclassResponsibility! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 9/14/2005 09:01'!select: aString	"We don't use #getListDelicately because the user would have to scroll through the list	to find the item we're selecting, thus triggering updates to the list."		| listMorph list |	listMorph _ self findListContaining: aString.	self assert: listMorph notNil.	listMorph model okToChange ifFalse: [^ self].	list _ listMorph getListObtrusively collect: [:ea | ea asString withBlanksTrimmed].	listMorph changeModelSelection: (list indexOf: aString)! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/8/2007 21:19'!selectMenuItem: aString	| item |	item _ self menuItemNamed: aString.	item ifNil: [self signalFailure: 'Menu item ''', aString, ''' does not exist.'].	item click! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 3/14/2004 13:46'!selectSequence: aCollection	| plm |	aCollection withIndexDo: [:item :index | 					plm _ self listMorphs at: index.					plm changeModelSelection: (plm getListObtrusively indexOf: item)]! !!OBBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/8/2007 20:56'!setText: aString	| textMorph |	textMorph _ self textMorph.	textMorph 		text: aString asText;		accept.	! !!OBBrowserTest methodsFor: 'running' stamp: 'cwp 7/8/2007 01:43'!setUp	model := self browserClass metaNode: self metagraph node: self node.	widget := OBFakeBuilder build: model.	self forceLayout! !!OBBrowserTest methodsFor: 'examining' stamp: 'cwp 7/8/2007 01:46'!textMorph	^ (self morphsOfClass: OBFakeText) last! !!OBBrowserTest class methodsFor: 'testing' stamp: 'cwp 11/2/2006 00:13'!isAbstract	^ self name = #OBBrowserTest! !Object subclass: #OBBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!(OBBuilder instVarNames includes: 'current') ifFalse:	[OBBuilder addInstVarName: 'current']!!OBBuilder methodsFor: 'building'!button: aModel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'accessing'!current: aWidget	current _ aWidget! !!OBBuilder methodsFor: 'accessing'!current: anObject do: aBlock	| saved |	[saved _ current.	current _ anObject.	aBlock value]		ensure: [current _ saved].	^ anObject! !!OBBuilder methodsFor: 'building'!fixedButtonBar: aPanel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!horizontalGroupWith: aBlock	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!pane: aColumn with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!radioButtonBar: aPanel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'accessing'!root	^ current! !!OBBuilder methodsFor: 'building'!scroller: aPanel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!textarea: aPanel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!textfield: aModel with: aBlock 	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!verticalGroupWith: aBlock	self subclassResponsibility! !!OBBuilder methodsFor: 'building'!window: aBrowser with: aBlock 	self subclassResponsibility! !!OBBuilder class methodsFor: 'as yet unclassified'!build: aModel	| builder |	builder _ self new.	^ aModel buildOn: builder.	! !TestCase subclass: #OBBuilderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBBuilderTest instVarNames includes: 'model') ifFalse:	[OBBuilderTest addInstVarName: 'model']!!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/8/2007 01:29'!activate	! !!OBBuilderTest methodsFor: 'accessing' stamp: 'cwp 3/15/2007 22:35'!announcer	^ OBAnnouncer new! !!OBBuilderTest methodsFor: 'building' stamp: 'cwp 3/13/2007 22:23'!browser	^ OBBrowser metaNode: OBFakeNode metagraph node: OBFakeNode new.! !!OBBuilderTest methodsFor: 'building' stamp: 'cwp 7/8/2007 01:20'!build: aModel	^ self builderClass build: aModel! !!OBBuilderTest methodsFor: 'building' stamp: 'cwp 3/13/2007 22:25'!buildNavigationPanel	model _ self browser.	^ self build: model navigationPanel.	! !!OBBuilderTest methodsFor: 'building' stamp: 'cwp 3/13/2007 22:26'!buildWindow	model _ self browser.	^ self build: model.! !!OBBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:16'!button	^OBButtonModel withLabel: 'test' inBar: self! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 5/18/2007 23:20'!childNodes	^ #(a b c) collect: [:ea | (OBFake2Node tree: ea) metaNode: self metaNode]! !!OBBuilderTest methodsFor: 'accessing' stamp: 'cwp 5/10/2007 23:17'!columnWithFilter	^ OBColumn 		inPanel: self 		metaNode: self metaNode		node: self! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/8/2007 01:29'!displayString	^ 'test'! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/8/2007 01:29'!isEnabled: aButton	^ true! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/8/2007 01:29'!isSelected: aButton	^ false! !!OBBuilderTest methodsFor: 'emulating' stamp: 'dkh 6/1/2007 10:06'!left	^ Array with: self! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/14/2007 10:43'!listForNode: aNode	^ #(a b c)! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 5/18/2007 23:15'!metaNode	^ (OBMetaNode named: 'testing')		childAt: #left put: (OBMetaNode named: 'Left');		childAt: #right put: (OBMetaNode named: 'Right');		addFilter: OBModalFilter new;		yourself! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 3/15/2007 22:36'!metaNode: aMetanode! !!OBBuilderTest methodsFor: 'emulating' stamp: 'dkh 6/1/2007 10:06'!right	^ Array with: self! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/14/2007 10:41'!selectedNode	^ OBFakeNode new! !!OBBuilderTest methodsFor: 'emulating' stamp: 'cwp 7/8/2007 01:28'!selection	^ 1! !!OBBuilderTest methodsFor: 'accessing' stamp: 'cwp 7/14/2007 10:40'!switch	model := OBSwitch inColumn: self.	model filter: self.	^ model! !RectangleMorph subclass: #OBButtonBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!(OBButtonBar instVarNames includes: 'model') ifFalse:	[OBButtonBar addInstVarName: 'model']!!OBButtonBar methodsFor: 'updating' stamp: 'dc 9/8/2007 15:02'!addButtonFor: aCommand       self addMorphBack: ((self buttonFor: aCommand)								position: self position;								yourself)! !!OBButtonBar methodsFor: 'visual' stamp: 'cwp 3/11/2007 20:55'!adoptPaneColor: aColor	self submorphs do: [:ea | ea onColor: aColor offColor: aColor whiter]! !!OBButtonBar methodsFor: 'updating' stamp: 'dc 9/27/2007 14:46'!buttonFor: aCommand	| buttonColor |	buttonColor _ model color duller.	^ (PluggableButtonMorph		on: aCommand		getState: #isActive		action: (aCommand isActive ifTrue: [#execute] ifFalse: [#yourself])		label: #buttonLabel)			onColor: buttonColor offColor: buttonColor whiter;			hResizing: #spaceFill;			vResizing: #spaceFill;			styleWith: OBMorphBuilder new;			setBalloonText:  aCommand longDescription;			yourself! !!OBButtonBar methodsFor: 'initialize-release' stamp: 'cwp 7/21/2007 22:32'!initGeometry	self		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		hResizing: #spaceFill;		vResizing: #spaceFill;		rubberBandCells: true;		styleWith: OBMorphBuilder new;		yourself! !!OBButtonBar methodsFor: 'accessing' stamp: 'cwp 3/11/2007 15:56'!model	^ model! !!OBButtonBar methodsFor: 'accessing' stamp: 'cwp 3/11/2007 15:26'!model: aModel	model ifNotNil: [model removeDependent: self].	model _ aModel.	model addDependent: self.! !!OBButtonBar methodsFor: 'visual' stamp: 'cwp 3/11/2007 20:34'!noteNewOwner: aMorph	| window |	window := aMorph containingWindow.	window ifNotNil: [self adoptPaneColor: window paneColor]! !!OBButtonBar methodsFor: 'building' stamp: 'cwp 7/21/2007 21:35'!styleWith: aBuilder	aBuilder styleButtonBar: self! !!OBButtonBar methodsFor: 'updating' stamp: 'cwp 3/11/2007 15:58'!update: aSymbol	aSymbol == #commands ifTrue: [self updateCommands]! !!OBButtonBar methodsFor: 'updating' stamp: 'cwp 3/11/2007 19:27'!updateCommands	self removeAllMorphs.	model commands do: [:ea | self addButtonFor: ea].! !!OBButtonBar class methodsFor: 'as yet unclassified' stamp: 'cwp 3/11/2007 16:39'!on: aModel	^ self new 		model: aModel;		initGeometry;		update: #commands.! !Object subclass: #OBButtonModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBButtonModel commentStamp: 'cwp 3/5/2004 12:15' prior: 0!An OBButtonModel serves as a model for PluggableButtonMorphs used OBRadioButtonBar. OBRadioButtonBar cannot be a direct model for its PBMs, since it can contain a variable number of buttons.iVars:bar		- the OBRadioButton bar to which this button belongslabel	- the label of the button!(OBButtonModel instVarNames includes: 'bar') ifFalse:	[OBButtonModel addInstVarName: 'bar']!(OBButtonModel instVarNames includes: 'label') ifFalse:	[OBButtonModel addInstVarName: 'label']!!OBButtonModel methodsFor: 'accessing' stamp: 'cwp 2/24/2004 18:29'!bar: aRadioButtonBar	bar _ aRadioButtonBar! !!OBButtonModel methodsFor: 'building' stamp: 'cwp 7/25/2007 23:55'!buildOn: aBuilder 	^aBuilder button: self with: []! !!OBButtonModel methodsFor: 'testing' stamp: 'cwp 11/27/2004 19:09'!isEnabled	^ bar isEnabled: self! !!OBButtonModel methodsFor: 'callbacks' stamp: 'cwp 2/24/2004 18:42'!isSelected	^ bar isSelected: self! !!OBButtonModel methodsFor: 'accessing' stamp: 'cwp 3/2/2004 21:46'!label	^ label! !!OBButtonModel methodsFor: 'accessing' stamp: 'cwp 2/24/2004 18:29'!label: aString	label _ aString! !!OBButtonModel methodsFor: 'callbacks' stamp: 'cwp 2/28/2006 10:45'!labelMorph	^ (StringMorph 		contents: self label 		font: TextStyle defaultFont)			color: (self isEnabled ifTrue: [Color black] ifFalse: [Color gray]);			yourself! !!OBButtonModel methodsFor: 'callbacks' stamp: 'cwp 2/24/2004 19:30'!push	bar push: self.! !!OBButtonModel methodsFor: 'accessing' stamp: 'cwp 11/27/2004 00:50'!selectionChanged	self changed: #isSelected.	self changed: #labelMorph! !!OBButtonModel class methodsFor: 'as yet unclassified' stamp: 'cwp 8/29/2004 13:31'!offColor	^ Color lightGray twiceLighter! !!OBButtonModel class methodsFor: 'as yet unclassified' stamp: 'cwp 8/29/2004 13:30'!onColor	^ Color lightGray lighter! !!OBButtonModel class methodsFor: 'as yet unclassified' stamp: 'cwp 2/24/2004 18:35'!withLabel: aString inBar: aRadioButtonBar	^ self new label: aString; bar: aRadioButtonBar! !TestCase subclass: #OBCollectionNodeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBCollectionNodeTest methodsFor: 'tests' stamp: 'dkh 6/1/2007 10:07'!testAncestryOfDescendent	| node |	node := OBCollectionNode on: (Array with: (OBClassNode on: self class)).	self		assert: (node				isAncestorOf: (OBMethodNode on: #testAncestryOfDescendent inClass: self class))! !!OBCollectionNodeTest methodsFor: 'tests' stamp: 'dkh 6/1/2007 10:07'!testAncestryOfNodeInCollection	| node |	node := OBCollectionNode on: (Array with: (OBClassNode on: self class)).	self		assert: (node				isAncestorOf: (OBClassNode on: self class))! !Object subclass: #OBColumn	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!!OBColumn commentStamp: 'cwp 1/7/2005 23:19' prior: 0!An OBColumn manages a list of nodes, which it displays in a PluggableListMorph in the pane scroller at the top of the browser. All instances of OBColumn belong to an OBColumnPanel. It's main responsibility is keeping its list - and those of its neighbours - up to date. Each column has a MetaNode, which provides the list contents. It uses a filter to meditate between its self and the MetaNode.iVars:panel		- the panel which owns the columnfilter		- the filter which manages the column's MetaNode.parent		- the node selected in the column to the left of this columnchildren 	- the nodes which make up this column's listselection 	- the index of the node selected by the user!(OBColumn instVarNames includes: 'panel') ifFalse:	[OBColumn addInstVarName: 'panel']!(OBColumn instVarNames includes: 'switch') ifFalse:	[OBColumn addInstVarName: 'switch']!(OBColumn instVarNames includes: 'fan') ifFalse:	[OBColumn addInstVarName: 'fan']!(OBColumn instVarNames includes: 'selection') ifFalse:	[OBColumn addInstVarName: 'selection']!!OBColumn methodsFor: '*ob-morphic' stamp: 'cwp 7/13/2007 20:59'!acceptDroppingMorph: transferMorph event: evt inMorph: listMorph 	| target |	target := self nodeForDropEvent: evt inMorph: listMorph.	^self drop: transferMorph passenger on: target! !!OBColumn methodsFor: 'commands'!addCommandsToMenu: aMenu 	| scan nodes |	scan := self announce: OBNodeCommandScan.	nodes := self hasSelection				ifTrue: [{self parent. self selectedNode}]				ifFalse: [{self parent}].	scan 		populateMenu: aMenu		withNodes: nodes		forRequestor: self! !!OBColumn methodsFor: 'updating'!announce: anAnnouncement 	^ self browser announce: anAnnouncement! !!OBColumn methodsFor: 'accessing'!announcer	^ panel announcer! !!OBColumn methodsFor: 'accessing'!basicNext	^panel columnAfter: self! !!OBColumn methodsFor: 'accessing'!basicParent: aNode 	fan := OBFan parent: aNode.	self switchFilter: fan switchFilter! !!OBColumn methodsFor: 'accessing'!browser	^ panel browser! !!OBColumn methodsFor: 'building'!buildOn: aBuilder 	^aBuilder pane: self with: [switch buildOn: aBuilder]! !!OBColumn methodsFor: 'callbacks'!canDrop: passenger on: node 	^node notNil and: [node wantsDroppedNode: passenger]! !!OBColumn methodsFor: 'accessing'!children	^ fan children! !!OBColumn methodsFor: 'updating'!childrenChanged: announcement	(self parent = announcement node) ifTrue:		[self refresh]! !!OBColumn methodsFor: 'updating'!clear	self switchFilter: nil.	fan _ OBFan new.	self clearSelection.	self changed: #list.	self changed: #selection! !!OBColumn methodsFor: 'selecting'!clearSelection	selection _ 0! !!OBColumn methodsFor: 'updating'!createNext	| nextMetaNode created |	nextMetaNode := self nextMetaNode.	created _ OBColumn inPanel: panel metaNode: nextMetaNode node: self selectedNode.	panel pushColumn: created.	^created! !!OBColumn methodsFor: 'printing'!descriptor	self isEmpty ifTrue: [^ 'empty'].	self hasSelection ifTrue: [^ self selectedNode name].	^ ''! !!OBColumn methodsFor: '*ob-morphic' stamp: 'avi 2/20/2004 13:45'!dragEnabled	^ true! !!OBColumn methodsFor: '*ob-morphic' stamp: 'cwp 7/13/2007 22:39'!dragPassengerFor: item inMorph: listMorph 	^ self nodeForItem: item contents asString! !!OBColumn methodsFor: '*ob-morphic' stamp: 'avi 2/20/2004 14:37'!dragTransferType	^ #OmniBrowser! !!OBColumn methodsFor: '*ob-morphic' stamp: 'avi 2/20/2004 14:36'!dragTransferTypeForMorph: listMorph	^ self dragTransferType! !!OBColumn methodsFor: 'callbacks'!drop: passenger on: target 	^ [target acceptDroppedNode: passenger] 		on: OBAnnouncerRequest		do: [:notification | notification resume: self announcer]! !!OBColumn methodsFor: '*ob-morphic' stamp: 'avi 2/20/2004 14:30'!dropEnabled	^ true! !!OBColumn methodsFor: 'selecting'!fan: aFan selection: index	fan _ aFan.	selection _ index.	self selectedNode ifNotNilDo: [:node | fan parent noteChild: node].	self switchFilter: fan switchFilter.	switch refresh.	self changed: #list! !!OBColumn methodsFor: 'testing'!hasSelection	^ self selection > 0! !!OBColumn methodsFor: 'callbacks'!iconAt: index 	^(fan children at: index) icon! !!OBColumn methodsFor: 'testing'!includesNode: aNode 	^fan children includes: aNode! !!OBColumn methodsFor: 'accessing'!isEmpty	^ fan parent isNil! !!OBColumn methodsFor: 'testing'!isSelected: aNode	^ self selectedNode == aNode! !!OBColumn methodsFor: 'accessing'!jumpTo: cNode 	cNode 		ifNil: 			[self clearSelection.			self changed: #list.			panel clearAfter: self]		ifNotNil: 			[fan parent noteChild: cNode.			self selectSilently: cNode.			panel selectionChangedIn: self.			switch currentNode: cNode.			self changed: #list]! !!OBColumn methodsFor: 'callbacks'!keystroke: aChar from: aMorph	| scan |	self isEmpty ifTrue: [^ self].		scan _ self announcer announce: OBNodeCommandScan.	scan processKeystroke: aChar withNode: self parent for: self.	self hasSelection ifTrue: [scan 								processKeystroke: aChar 								withNode: self selectedNode 								for: self].! !!OBColumn methodsFor: 'callbacks'!list	^ fan children collect: [:ea | self parent displayStringForChild: ea]! !!OBColumn methodsFor: 'callbacks'!listAt: index 	^self parent 		displayStringForChild: (fan children at: index ifAbsent: [^''])! !!OBColumn methodsFor: 'updating'!listChanged	self refreshAndSignal: true! !!OBColumn methodsFor: 'callbacks'!listSize	^fan children ifNil: [0] ifNotNil: [fan children size]! !!OBColumn methodsFor: 'callbacks'!menu: aMenu 	self isEmpty ifFalse: [self addCommandsToMenu: aMenu].	^aMenu! !!OBColumn methodsFor: 'accessing'!metaNode	^ self parent metaNode! !!OBColumn methodsFor: 'accessing'!next	^ self basicNext		ifNil: [(self hasSelection and: [self shouldBeLast not])				ifTrue: [self createNext]]	! !!OBColumn methodsFor: 'nodes'!nextMetaNode	^ self selectedNode metaNode! !!OBColumn methodsFor: 'updating'!nodeChanged: ann 	(fan children includes: ann node) ifTrue: [self changed: #list]! !!OBColumn methodsFor: 'updating'!nodeDeleted: announcement 	"This gets called if an action causes the currently selected node to be deleted."	self selectedNode = announcement node		ifTrue: 			[fan refresh.			self changed: #list.			self selection: 0]! !!OBColumn methodsFor: '*ob-morphic' stamp: 'dr 3/3/2008 16:32'!nodeForDropEvent: evt inMorph: pluggableListMorph 	| index item label |	index := pluggableListMorph rowAtLocation: evt position.	index = 0 ifTrue: [^nil].	item := pluggableListMorph listMorph item: index.	label := item contents asString withBlanksTrimmed.	^self children 		detect: [:child | child displayString asString withBlanksTrimmed = label]		ifNone: [nil]! !!OBColumn methodsFor: 'callbacks'!nodeForItem: aString 	^fan children 		detect: [:child | (self parent displayStringForChild: child) = aString]		ifNone: [aString]! !!OBColumn methodsFor: 'callbacks'!okToChange	^ (self announcer announce: OBAboutToChange) isVetoed not! !!OBColumn methodsFor: 'accessing'!parent	^ fan ifNotNil: [fan parent]! !!OBColumn methodsFor: 'accessing'!parent: aNode 	| cNode |	self basicParent: aNode.	cNode := fan autoSelection.	self jumpTo: cNode! !!OBColumn methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self descriptor.	aStream nextPut: $)! !!OBColumn methodsFor: 'updating'!refresh	self refreshAndSignal: false! !!OBColumn methodsFor: 'updating'!refresh: ann	self refreshAndSignal: false! !!OBColumn methodsFor: 'updating'!refreshAndSignal: aBoolean	| node shouldSignal |	shouldSignal _ aBoolean.	self isEmpty ifTrue: [^self].	node := self selectedNode.	fan refresh ifTrue:		[self selectSilently: node.		self hasSelection ifFalse: 			[shouldSignal _ true]].	shouldSignal ifTrue: [self signalSelectionChanged].	self changed: #list! !!OBColumn methodsFor: 'selecting'!select: aNode	fan children doWithIndex: [:child :i | child = aNode ifTrue: [^ self selection: i]].	self selection: nil! !!OBColumn methodsFor: 'selecting'!selectSilently: aNode 		selection := fan indexOf: aNode.	! !!OBColumn methodsFor: 'selecting'!selectedNode	^ fan children at: self selection ifAbsent: [].! !!OBColumn methodsFor: 'callbacks'!selection	^ selection ifNil: [0]! !!OBColumn methodsFor: 'callbacks'!selection: anInteger	selection _ anInteger.	self signalSelectionChanged.	self changed: #selection.	switch currentNode: self selectedNode! !!OBColumn methodsFor: 'updating'!selectionChanged: ann	! !!OBColumn methodsFor: 'initializing'!setPanel: aPanel 	panel _ aPanel.	switch _ OBSwitch inColumn: self.	self subscribe.	fan _ OBFan new.	self clearSelection! !!OBColumn methodsFor: 'initializing'!setPanel: aPanel metaNode: aMetanode node: aNode 	switch _ OBSwitch inColumn: self.	panel _ aPanel.	aNode metaNode: aMetanode.	self basicParent: aNode.	self clearSelection.	self subscribe.! !!OBColumn methodsFor: 'testing'!shouldBeLast	^ self hasSelection not or: [self nextMetaNode hasChildren not]! !!OBColumn methodsFor: 'updating'!signalSelectionChanged	self announcer announce: (OBSelectionChanged column: self)! !!OBColumn methodsFor: 'updating'!subscribe	self announcer 		observe: OBRefreshRequired send: #refresh: to: self;		observe: OBNodeChanged send: #nodeChanged: to: self;		observe: OBNodeDeleted send: #nodeDeleted: to: self;		observe: OBChildrenChanged send: #childrenChanged: to: self;		observe: OBSelectionChanged send: #selectionChanged: to: self.! !!OBColumn methodsFor: 'accessing'!switch	^ switch! !!OBColumn methodsFor: 'accessing'!switchFilter: aFilter	"We should only be sending #changed: if the filter is actually different	from the one the switch already has, but that causes some visually odd	behavior because of the way OBRadioButtonBar resizes its self when updating,	so for now we always just recreate the button bar."		switch filter: aFilter.	self changed: #switch! !!OBColumn methodsFor: 'testing'!wantsButton	^ switch isActive! !!OBColumn methodsFor: '*ob-morphic' stamp: 'cwp 7/13/2007 20:56'!wantsDroppedMorph: transferMorph event: evt inMorph: listMorph 	| node passenger |	(transferMorph isKindOf: TransferMorph) ifFalse: [^false].	node := self nodeForDropEvent: evt inMorph: listMorph.	transferMorph dragTransferType == self dragTransferType ifFalse: [^false].	passenger := transferMorph passenger.	^self canDrop: passenger on: node! !!OBColumn class methodsFor: 'instance creation'!inPanel: aBrowser	^ self new setPanel: aBrowser! !!OBColumn class methodsFor: 'instance creation'!inPanel: aPanel metaNode: aMetaNode node: aNode	^ self new			setPanel: aPanel			metaNode: aMetaNode			node: aNode! !TestCase subclass: #OBColumnPanelTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBColumnPanelTest instVarNames includes: 'announcer') ifFalse:	[OBColumnPanelTest addInstVarName: 'announcer']!!OBColumnPanelTest methodsFor: 'accessing' stamp: 'cwp 7/19/2007 01:08'!announcer	^ announcer ifNil: [announcer _ OBAnnouncer new]! !!OBColumnPanelTest methodsFor: 'tests' stamp: 'cwp 5/9/2007 00:44'!testJumpClearsSubsequentPanels	| root panel second first |	root _ OBFake2Node tree: #(a (b (c (d e (f (g h i)))) j)).	first _ OBFake2Node tree: #h.	second _ OBFake2Node tree: #b.	panel _ OBColumnPanel minPanes: 4 maxPanes: 4.	panel browser: self.	panel setMetaNode: OBFake2Node metagraph node: root.	panel jumpTo: first.	panel jumpTo: second.	self assert: panel columns third isEmpty.	self assert: panel columns fourth isEmpty.! !!OBColumnPanelTest methodsFor: 'tests' stamp: 'cwp 7/19/2007 01:07'!testJumpToFakeC	| root node panel |	root _ OBFakeNode parent: nil item: #a.	node _ OBFakeNode parent: (OBFakeNode parent: root item: #b) item: #c.	panel _ OBColumnPanel inBrowser: self.	panel setMetaNode: OBFakeNode metagraph node: root.	panel jumpTo: node.	self assert: panel selectedNode = node.! !!OBColumnPanelTest methodsFor: 'tests' stamp: 'cwp 5/9/2007 00:09'!testJumpToRootAsChild	| root node panel |	root _ OBFake2Node tree: #(b (a b c)).	node _ OBFake2Node tree: #b.	panel _ OBColumnPanel new.	panel browser: self.	panel setMetaNode: OBFake2Node metagraph node: root.	panel jumpTo: node.	self assert: panel selectedNode = node.	self assert: (panel columns indexOf: panel currentColumn) = 1! !TestCase subclass: #OBColumnTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBColumnTest instVarNames includes: 'announcer') ifFalse:	[OBColumnTest addInstVarName: 'announcer']!(OBColumnTest instVarNames includes: 'column') ifFalse:	[OBColumnTest addInstVarName: 'column']!!OBColumnTest methodsFor: 'support' stamp: 'cwp 11/2/2006 00:35'!addFactory: aBlock 	| factory |	factory := OBPluggableCommand action: aBlock.	announcer observe: OBNodeCommandScan do: [:ann | ann addFactory: factory].	^factory! !!OBColumnTest methodsFor: 'updating' stamp: 'cwp 10/14/2006 18:04'!announce: aClass 	^ announcer announce: aClass! !!OBColumnTest methodsFor: 'emulating' stamp: 'cwp 6/25/2006 00:04'!announcer	^ announcer! !!OBColumnTest methodsFor: 'emulating' stamp: 'cwp 6/25/2006 00:40'!browser	^ self! !!OBColumnTest methodsFor: 'emulating' stamp: 'cwp 7/17/2007 22:46'!clearAfter: aOBColumn 	! !!OBColumnTest methodsFor: 'support' stamp: 'cwp 7/17/2007 22:46'!parentNode	| node |	node _ OBFakeNode parent: nil item: #a.	node metaNode: OBFakeNode metagraph.	^ node! !!OBColumnTest methodsFor: 'support' stamp: 'cwp 7/17/2007 23:36'!parentNodeBrokenAutoselect	| node x |	node _ self parentNode.	x _ OBFakeNode metagraph.	node metaNode childAt: #noChildren put: x.	node metaNode autoSelect: x.	^ node! !!OBColumnTest methodsFor: 'emulating' stamp: 'cwp 6/25/2006 00:39'!parentNodeForColumn: aColumn	^ OBFakeNode parent: nil item: 'b'! !!OBColumnTest methodsFor: 'support' stamp: 'cwp 7/17/2007 23:08'!parentNodeWithAutoselect	| node x |	node _ self parentNode.	x _ OBFakeNode metagraph.	node metaNode childAt: #childX put: x.	node metaNode autoSelect: x.	^ node! !!OBColumnTest methodsFor: 'support' stamp: 'cwp 7/23/2007 01:41'!parentNodeWithIcon	| node filter |	node _ self parentNode.	filter _ OBPluggableFilter new.	filter icon: [:i :n | n item = #b ifTrue: [#test] ifFalse: [#blank]].	node metaNode children first addFilter: filter.	^ node! !!OBColumnTest methodsFor: 'emulating' stamp: 'cwp 7/17/2007 23:48'!selectionChangedIn: anOBColumn ! !!OBColumnTest methodsFor: 'support' stamp: 'cwp 6/25/2006 13:26'!setUp	announcer _ OBAnnouncer new.	column _ OBColumn 				inPanel: self 				metaNode: OBFakeNode metagraph				node: (OBFakeNode parent: nil item: 'a').	! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:35'!test01MenuIncludesCommands	| menu invoked |	invoked := false.	(self addFactory: [invoked := true]) label: 'test service'.	menu := MenuMorph new.	column menu: menu.	(menu itemWithWording: 'test service') doButtonAction.	self assert: invoked! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:35'!test02KeystrokeInvokesCommand	| invoked |	invoked := false.	(self addFactory: [invoked := true]) keystroke: $s.	column keystroke: $s from: nil.	self assert: invoked! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 7/17/2007 22:58'!test03SetParent	column parent: self parentNode.	self assert: column listSize = 3.	self assert: column selection = 0! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 7/17/2007 23:37'!test04AutoSelectNotFound	column parent: self parentNodeBrokenAutoselect.	self assert: column listSize = 3.	self assert: column selection = 0! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 7/17/2007 23:36'!test05AutoSelect	column parent: self parentNodeWithAutoselect.	self assert: column listSize = 4.	self assert: column selection = 4! !!OBColumnTest methodsFor: 'tests' stamp: 'cwp 7/23/2007 01:42'!test06Icon	column parent: self parentNodeWithIcon.	self assert: (column iconAt: 1) = #blank.	self assert: (column iconAt: 2) = #test.	self assert: (column iconAt: 3) = #blank.! !Object subclass: #OBCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Commands'!(OBCommand instVarNames includes: 'target') ifFalse:	[OBCommand addInstVarName: 'target']!(OBCommand instVarNames includes: 'requestor') ifFalse:	[OBCommand addInstVarName: 'requestor']!!OBCommand methodsFor: 'user interface'!addItemToMenu: aMenu	self isActive ifTrue:		[aMenu			add: self labelWithKeystroke			target: self 			selector: #execute			enabled: self isEnabled			icon: self icon]! !!OBCommand methodsFor: 'accessing'!buttonLabel	^ self label! !!OBCommand methodsFor: 'accessing'!cluster	^ nil! !!OBCommand methodsFor: 'accessing'!createCluster	^ OBCommandCluster label: self cluster! !!OBCommand methodsFor: 'execution'!execute	! !!OBCommand methodsFor: 'accessing'!group	^ #general! !!OBCommand methodsFor: 'accessing'!icon	^ nil! !!OBCommand methodsFor: 'testing'!isActive	^ false! !!OBCommand methodsFor: 'testing'!isEnabled	^ true! !!OBCommand methodsFor: 'accessing'!keystroke	^ nil! !!OBCommand methodsFor: 'accessing'!label	self subclassResponsibility! !!OBCommand methodsFor: 'accessing'!labelWithKeystroke	^ self keystroke		ifNil: [self label]		ifNotNil: [self label, ' (', self keystroke asString, ')']! !!OBCommand methodsFor: 'accessing'!longDescription	"Override this and return a string or a text for the fly-by-help (tooltip)"	^ nil! !!OBCommand methodsFor: 'accessing'!on: anObject for: aRequestor	^ self class on: anObject for: aRequestor! !!OBCommand methodsFor: 'user interface'!order	^ self label! !!OBCommand methodsFor: 'user interface'!perform: aSelector orSendTo: anObject	self perform: aSelector! !!OBCommand methodsFor: 'user interface'!select: aNode with: anAnnouncer	(anAnnouncer announce: OBAboutToChange)		isVetoed ifFalse: [anAnnouncer announce: (OBSelectingNode node: aNode)]! !!OBCommand methodsFor: 'initialize-release'!setTarget: anObject requestor: aRequestor	target _ anObject.	requestor _ aRequestor! !!OBCommand methodsFor: 'testing'!takesNodes	^ true! !!OBCommand methodsFor: 'testing'!takesText	^ false! !!OBCommand methodsFor: 'testing'!wantsButton	"Put this here for compatibility. Eventually this will be obsolete"	^ false! !!OBCommand class methodsFor: 'instance creation'!on: target for: requestor	^ self new setTarget: target requestor: requestor! !!OBCommand class methodsFor: 'testing'!takesNodes	^ true! !!OBCommand class methodsFor: 'testing'!takesText	^ false! !Object subclass: #OBCommandCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Commands'!(OBCommandCluster instVarNames includes: 'commands') ifFalse:	[OBCommandCluster addInstVarName: 'commands']!(OBCommandCluster instVarNames includes: 'label') ifFalse:	[OBCommandCluster addInstVarName: 'label']!!OBCommandCluster methodsFor: 'accessing'!addCommand: aCommand	commands add: aCommand! !!OBCommandCluster methodsFor: 'accessing'!addItemToMenu: aMenu	| submenu |	submenu _ aMenu addSubmenu: label enabled: self isEnabled.	self populateMenu: submenu! !!OBCommandCluster methodsFor: 'accessing'!group	^ #zclusters! !!OBCommandCluster methodsFor: 'accessing'!groupedCommands	| groups |	groups := commands 				groupBy: [:svc | svc group]				having: [:group | group isEmpty not].	groups := groups collect: [:ea | ea asArray sort: [:a :b | a label <= b label]].	^ groups asArray sort: [:a :b | a anyOne group <= b anyOne group]! !!OBCommandCluster methodsFor: 'accessing'!initialize	commands _ IdentitySet new! !!OBCommandCluster methodsFor: 'accessing'!isEnabled	^ commands anySatisfy: [:ea | ea isEnabled]! !!OBCommandCluster methodsFor: 'accessing'!label	^ label! !!OBCommandCluster methodsFor: 'accessing'!populateMenu: aMenu 	self groupedCommands			do: [:group | group do: [:cmd | cmd addItemToMenu: aMenu]]		separatedBy: [aMenu addLine]! !!OBCommandCluster methodsFor: 'initialize-release'!setLabel: aSymbol 	label _ aSymbol! !!OBCommandCluster class methodsFor: 'as yet unclassified'!label: aString	^ self new setLabel: aString! !TestCase subclass: #OBCommandTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBCommandTest instVarNames includes: 'service') ifFalse:	[OBCommandTest addInstVarName: 'service']!(OBCommandTest instVarNames includes: 'isSelected') ifFalse:	[OBCommandTest addInstVarName: 'isSelected']!!OBCommandTest methodsFor: 'support' stamp: 'cwp 11/1/2006 22:38'!command	^self factory on: nil for: nil! !!OBCommandTest methodsFor: 'support' stamp: 'cwp 11/1/2006 22:38'!executeOn: target for: requestor 	| command |	command := self factory on: target for: requestor.	^command execute! !!OBCommandTest methodsFor: 'support' stamp: 'cwp 11/1/2006 22:38'!isActiveOn: target for: requestor 	| command |	command := self factory on: target for: requestor.	^command isActive! !!OBCommandTest methodsFor: 'support' stamp: 'cwp 11/1/2006 22:38'!isEnabledOn: target for: requestor 	| command |	command := self factory on: target for: requestor.	^command isEnabled! !!OBCommandTest methodsFor: 'support' stamp: 'cwp 12/13/2007 23:32'!isSelected: aNode	^ isSelected ifNil: [false]! !!OBCommandTest methodsFor: 'tests' stamp: 'cwp 10/15/2006 16:42'!test01LabelIsString	self assert: self command label isString! !!OBCommandTest methodsFor: 'tests' stamp: 'cwp 10/15/2006 16:42'!test02HasCorrectKeystroke	self assert: self command keystroke isNil! !!OBCommandTest methodsFor: 'tests' stamp: 'cwp 10/15/2006 16:42'!test03DoesntWantButton	self deny: self command wantsButton! !!OBCommandTest class methodsFor: 'as yet unclassified' stamp: 'cwp 11/2/2006 00:13'!isAbstract	^ self name == #OBCommandTest! !!OBCommandTest class methodsFor: 'as yet unclassified' stamp: 'cwp 10/7/2006 11:15'!shouldInheritSelectors	^ true! !Object subclass: #OBDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Utilities'!!OBDefinition commentStamp: 'cwp 1/7/2005 23:38' prior: 0!The responsibility of a definition is to express a node's composition textually and respond to changes in the text by updating the node it represents. For example,a file browser might use a file definition to allow editing of a files contents.!!OBDefinition methodsFor: 'callbacks'!accept: aText notifying: aController	^ self text: aText! !!OBDefinition methodsFor: 'testing'!allowsEditing	^ true! !!OBDefinition methodsFor: 'updating'!asAnnouncement	^ OBDefinitionChanged definition: self! !!OBDefinition methodsFor: 'callbacks'!doItContext	^ nil! !!OBDefinition methodsFor: 'callbacks'!doItReceiver	| class |	class _ self selectedClass.	^ class		ifNotNil: [class theNonMetaClass]		ifNil: [FakeClassPool new]! !!OBDefinition methodsFor: 'testing'!isEditable	^ true! !!OBDefinition methodsFor: 'callbacks'!selectedClass	^ nil! !!OBDefinition methodsFor: 'callbacks'!selection	^ 1 to: 0! !!OBDefinition methodsFor: 'updating'!signalChange	OBAnnouncer current announce: (OBDefinitionChanged definition: self)! !!OBDefinition methodsFor: 'callbacks'!text	^ ''! !!OBDefinition methodsFor: 'callbacks'!text: aText	^ false! !!OBDefinition methodsFor: 'callbacks'!textSelection	^ self selection! !TestCase subclass: #OBDefinitionPanelTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBDefinitionPanelTest instVarNames includes: 'announcer') ifFalse:	[OBDefinitionPanelTest addInstVarName: 'announcer']!(OBDefinitionPanelTest instVarNames includes: 'panel') ifFalse:	[OBDefinitionPanelTest addInstVarName: 'panel']!!OBDefinitionPanelTest methodsFor: 'emulating' stamp: 'cwp 10/13/2006 09:30'!announce: aClass 	^ announcer announce: aClass! !!OBDefinitionPanelTest methodsFor: 'emulating' stamp: 'cwp 10/13/2006 00:09'!announcer	^ announcer! !!OBDefinitionPanelTest methodsFor: 'support' stamp: 'cwp 10/13/2006 00:18'!assertMenu: aMenu hasItemSending: aSelector	aMenu items anySatisfy: [:ea | ea selector = aSelector]! !!OBDefinitionPanelTest methodsFor: 'support' stamp: 'cwp 3/23/2007 23:59'!menu	^ (OBMorphBuilder build: panel) getMenu: false! !!OBDefinitionPanelTest methodsFor: 'emulating' stamp: 'cwp 11/2/2006 00:35'!scanCommands: ann 	ann 		addFactory: ((OBPluggableService action: 					[:node | 					self assert: (node isKindOf: OBTextSelection).					executed := true]) 				label: 'test')! !!OBDefinitionPanelTest methodsFor: 'support' stamp: 'cwp 10/13/2006 10:04'!setUp	announcer _ OBAnnouncer new.	panel _ OBDefinitionPanel inBrowser: self.	! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/23/2007 23:59'!test01MenuHasEditingItems	| menu |	menu _ self menu.	self assertMenu: menu hasItemSending: #find.	self assertMenu: menu hasItemSending: #findAgain.	self assertMenu: menu hasItemSending: #setSearchString.	self assertMenu: menu hasItemSending: #again.	self assertMenu: menu hasItemSending: #undo.	self assertMenu: menu hasItemSending: #copySelection.	self assertMenu: menu hasItemSending: #cut.	self assertMenu: menu hasItemSending: #paste.	self assertMenu: menu hasItemSending: #pasteRecent.	self assertMenu: menu hasItemSending: #accept.	self assertMenu: menu hasItemSending: #cancel.! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/23/2007 23:59'!test02MenuIncludesCommands	| menu |	announcer observe: OBTextCommandScan		do: [:ann | ann addFactory: (OBPluggableCommand new label: 'test')].	menu := self menu.	self deny: (menu itemWithWording: 'test') isNil! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/23/2007 23:59'!test03CommandsGetExecuted	| menu executed |	executed := false.	announcer observe: OBTextCommandScan		do: 			[:ann | 			ann 				addFactory: ((OBPluggableCommand action: [executed := true]) label: 'test')].	menu := self menu.	(menu itemWithWording: 'test') doButtonAction.	self assert: executed! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/23/2007 23:59'!test04InactiveCommandsAreHidden	| menu |	announcer observe: OBTextCommandScan		do: 			[:ann | 			ann 				addFactory: ((OBPluggableCommand action: [] active: [false]) label: 'test')].	menu := self menu.	self assert: (menu itemWithWording: 'test') isNil! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/3/2007 22:37'!test05SilentChangeAllowedIfNotDirty	| ann |	ann _ announcer announce: OBAboutToChangeSilently.	self deny: ann isVetoed.! !!OBDefinitionPanelTest methodsFor: 'tests' stamp: 'cwp 3/24/2007 00:00'!test06SilentChangeVetoedIfDirty	| ann morph |	morph _ OBMorphBuilder build: panel.	morph hasUnacceptedEdits: true.	ann _ announcer announce: OBAboutToChangeSilently.	self assert: ann isVetoed.! !Object subclass: #OBFakeMenu	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeMenu instVarNames includes: 'target') ifFalse:	[OBFakeMenu addInstVarName: 'target']!(OBFakeMenu instVarNames includes: 'items') ifFalse:	[OBFakeMenu addInstVarName: 'items']!!OBFakeMenu methodsFor: 'emulating' stamp: 'cwp 7/8/2007 02:19'!add: aString target: anObject selector: aSymbol enabled: aBoolean icon: icon	items add: (OBFakeMenuItem				label: aString				target: anObject				selector: aSymbol				enabled: aBoolean				icon: icon)! !!OBFakeMenu methodsFor: 'emulating' stamp: 'cwp 7/8/2007 02:21'!addLine	! !!OBFakeMenu methodsFor: 'emulating' stamp: 'cwp 10/8/2007 01:55'!addSubmenu: aString enabled: aBoolean 	| submenu |	submenu := self class new.	items add: (OBFakeMenuItem 				label: aString				enabled: aBoolean				submenu: submenu).	^submenu! !!OBFakeMenu methodsFor: 'emulating' stamp: 'cwp 7/8/2007 02:06'!defaultTarget: anObject	target _ anObject! !!OBFakeMenu methodsFor: 'initialize-release' stamp: 'cwp 7/8/2007 02:07'!initialize	items _ OrderedCollection new! !!OBFakeMenu methodsFor: 'emulating' stamp: 'cwp 7/8/2007 02:19'!itemWithWording: aString	^ items detect: [:ea | ea label = aString] ifNone: [nil]! !!OBFakeMenu methodsFor: 'accessing' stamp: 'cwp 7/8/2007 02:07'!items	^ items! !Object subclass: #OBFakeMenuItem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeMenuItem instVarNames includes: 'enabled') ifFalse:	[OBFakeMenuItem addInstVarName: 'enabled']!(OBFakeMenuItem instVarNames includes: 'icon') ifFalse:	[OBFakeMenuItem addInstVarName: 'icon']!(OBFakeMenuItem instVarNames includes: 'label') ifFalse:	[OBFakeMenuItem addInstVarName: 'label']!(OBFakeMenuItem instVarNames includes: 'selector') ifFalse:	[OBFakeMenuItem addInstVarName: 'selector']!(OBFakeMenuItem instVarNames includes: 'target') ifFalse:	[OBFakeMenuItem addInstVarName: 'target']!(OBFakeMenuItem instVarNames includes: 'submenu') ifFalse:	[OBFakeMenuItem addInstVarName: 'submenu']!!OBFakeMenuItem methodsFor: 'simulating' stamp: 'cwp 7/8/2007 21:27'!click	(enabled and: [selector notNil]) ifTrue: 		[target perform: selector]! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!icon	^icon! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!icon: anObject	icon := anObject! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!isEnabled	^ enabled! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!isEnabled: aBoolean	enabled _ aBoolean! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!label	^label! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!label: anObject	label := anObject! !!OBFakeMenuItem methodsFor: 'printing' stamp: 'cwp 7/8/2007 20:52'!printOn: aStream	aStream		nextPutAll: 'Item';		nextPut: $<;		print: label;		nextPut: $>.! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!selector	^selector! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!selector: anObject	selector := anObject! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 9/30/2007 17:49'!submenu	^submenu! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 9/30/2007 17:49'!submenu: anObject	submenu := anObject! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!target	^ target! !!OBFakeMenuItem methodsFor: 'accessing' stamp: 'cwp 7/8/2007 21:18'!target: anObject	target _ anObject! !!OBFakeMenuItem class methodsFor: 'instance creation' stamp: 'cwp 10/8/2007 01:56'!label: aString enabled: aBoolean submenu: aMenu 	^(self new)		label: aString;		isEnabled: aBoolean;		submenu: aMenu;		yourself! !!OBFakeMenuItem class methodsFor: 'instance creation' stamp: 'cwp 7/8/2007 02:19'!label: aString target: anObject selector: aSymbol enabled: aBoolean icon: icon 	^ self new		label: aString;		target: anObject;		selector: aSymbol;		isEnabled: aBoolean;		icon: icon;		yourself! !TestCase subclass: #OBFakeMenuTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Tests'!!OBFakeMenuTest methodsFor: 'as yet unclassified' stamp: 'cwp 9/30/2007 17:35'!testAddItem	| menu |	menu _ OBFakeMenu new.	menu		add: 'test item' 		target: self 		selector: #clickTestItem 		enabled: true 		icon: #blank.	self deny: (menu itemWithWording: 'test item') isNil.! !!OBFakeMenuTest methodsFor: 'as yet unclassified' stamp: 'cwp 9/30/2007 17:44'!testAddSubmenu	| menu submenu |	menu _ OBFakeMenu new.	submenu _ menu addSubmenu: 'test item' enabled: true.	self assert: menu class == submenu class.		! !Object subclass: #OBFakeWidget	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeWidget instVarNames includes: 'model') ifFalse:	[OBFakeWidget addInstVarName: 'model']!(OBFakeWidget instVarNames includes: 'children') ifFalse:	[OBFakeWidget addInstVarName: 'children']!!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/8/2007 00:50'!addChild: aWidget	children add: aWidget! !!OBFakeWidget methodsFor: 'simulating' stamp: 'cwp 7/8/2007 01:46'!basicUpdate! !!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/8/2007 00:51'!children	^ children! !!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/9/2007 23:16'!findDeeplyA: aClass	self withAllChildrenDo: [:ea | (ea isMemberOf: aClass) ifTrue: [^ ea]].	^ nil! !!OBFakeWidget methodsFor: 'initialize-release' stamp: 'cwp 7/8/2007 00:50'!initialize	children _ OrderedCollection new! !!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/7/2007 23:57'!model	^ model! !!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/7/2007 23:55'!model: aModel	model ifNotNil: [model removeDependent: self].	model _ aModel.	model addDependent: self.! !!OBFakeWidget methodsFor: 'printing' stamp: 'cwp 7/10/2007 00:11'!printDebugIdOn: aStream	aStream print: self identityHash! !!OBFakeWidget methodsFor: 'printing' stamp: 'cwp 7/9/2007 23:54'!printOn: aStream	aStream		nextPutAll: (self class name allButFirst: 2);		nextPut: $<.	self printDebugIdOn: aStream.	aStream nextPut: $>.! !!OBFakeWidget methodsFor: 'simulating' stamp: 'cb 8/7/2007 12:28'!setBalloonText: stringOrText self setBalloonText: stringOrText maxLineLength: 20. ! !!OBFakeWidget methodsFor: 'simulating' stamp: 'cb 8/7/2007 12:27'!setBalloonText: stringOrText maxLineLength: aLength "as a Fake widget is a morph, it should accep a balloon message"! !!OBFakeWidget methodsFor: 'simulating' stamp: 'cwp 7/8/2007 01:46'!update	self basicUpdate.	children do: [:ea | ea update]	! !!OBFakeWidget methodsFor: 'accessing' stamp: 'cwp 7/8/2007 01:38'!withAllChildrenDo: aBlock	aBlock value: self.	children do: [:ea | ea withAllChildrenDo: aBlock]! !!OBFakeWidget class methodsFor: 'as yet unclassified' stamp: 'cwp 7/7/2007 23:54'!model: anObject	^ self new model: anObject! !Object subclass: #OBFan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!(OBFan instVarNames includes: 'parent') ifFalse:	[OBFan addInstVarName: 'parent']!(OBFan instVarNames includes: 'children') ifFalse:	[OBFan addInstVarName: 'children']!!OBFan methodsFor: 'accessing'!allChildren	^ parent metaNode allChildrenForNode: parent.! !!OBFan methodsFor: 'selecting'!ancestorOf: aNode from: aCollection in: aBlock	aCollection doWithIndex:		[:node :index |		(node isAncestorOf: aNode using: node metaNode ancestrySelector)			ifTrue: [aBlock value: index. ^ node]].	^ nil! !!OBFan methodsFor: 'selecting'!ancestorOf: aNode in: aBlock 	| ancestor |	ancestor := self ancestorOf: aNode from: children in: aBlock.	ancestor ifNil: 		[ancestor := parent childAncestorOf: aNode indexIn: aBlock.		self refresh].	ancestor ifNil: [aBlock value: 0].	^ancestor! !!OBFan methodsFor: 'accessing'!autoSelection	| auto |	auto := parent metaNode autoSelect.	^auto 		ifNotNil: [children detect: [:ea | ea metaNode == auto] ifNone: [nil]]! !!OBFan methodsFor: 'accessing'!children	^ children ifNil: [#()]! !!OBFan methodsFor: 'selecting'!indexOf: aNode 	| index |	index := children indexOf: aNode.	index = 0 ifTrue: 		[index := self children indexOf: 			(self children 				detect: [:ea | ea name = aNode name] 				ifNone: [nil])].	^index! !!OBFan methodsFor: 'accessing'!parent	^ parent! !!OBFan methodsFor: 'accessing'!refresh	| oldChildren |	oldChildren _ children.	children _ parent childNodes.	^ children ~= oldChildren! !!OBFan methodsFor: 'initialize-release'!setParent: aNode 	self setParent: aNode children: aNode childNodes! !!OBFan methodsFor: 'initialize-release'!setParent: aNode children: aCollection 	parent _ aNode.	children _ aCollection.! !!OBFan methodsFor: 'accessing'!switchFilter	^ parent metaNode switchFilter! !!OBFan class methodsFor: 'as yet unclassified'!parent: aNode	^ self new setParent: aNode! !!OBFan class methodsFor: 'as yet unclassified'!parent: aNode children: aCollection 	^ self new setParent: aNode children: aCollection! !TestCase subclass: #OBFanTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBFanTest methodsFor: 'support' stamp: 'cwp 8/20/2007 15:31'!filterNodes: aCollection showingB: aBoolean	^ aBoolean 		ifTrue: [aCollection]		ifFalse: [aCollection reject: [:ea | ea name first = $b]]! !!OBFanTest methodsFor: 'tests' stamp: 'cwp 8/19/2007 22:48'!testAncestorOfIn	| root twig leaf ancestor |	root _ OBFakeNode parent: nil item: #a.	root metaNode: OBFakeNode metagraph.	twig _ OBFakeNode parent: root item: #b.	leaf _ OBFakeNode parent: twig item: #c.	ancestor _ root asFan ancestorOf: leaf in: [:i | self assert: i = 2].	self assert: ancestor = twig! !!OBFanTest methodsFor: 'tests' stamp: 'cwp 8/19/2007 22:49'!testAncestorOfSelf	| root leaf ancestor |	root _ OBFake2Node tree: #(b (a b c)).	leaf _ OBFake2Node tree: #b.	root metaNode: OBFake2Node metagraph.	ancestor _  root asFan ancestorOf: leaf in: [:i | self assert: i = 2].	self assert: ancestor = leaf! !!OBFanTest methodsFor: 'tests' stamp: 'cwp 8/20/2007 15:59'!testAncestorWithFilter	| root leaf ancestor filter parent child show fan |	show _ false.	root _ OBFake2Node tree: #(r ((a ()) (b (d e f)) c)).	leaf _ OBFake2Node tree: #e.	filter _ OBPluggableFilter new			nodes: [:nodes :ignored | self filterNodes: nodes showingB: show];			note: [:p :c | parent _ p. child _ c. show _ true];			yourself.	root metaNode: (OBFake2Node metagraph addFilter: filter).	fan _ root asFan.	ancestor _  fan ancestorOf: leaf in: [:i | self assert: i = 2].	self assert: ancestor name = #b.	self assert: parent == root.	self assert: child == ancestor.	self assert: (fan children at: 2) == ancestor! !Object subclass: #OBFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Filters'!!OBFilter commentStamp: 'cwp 3/4/2004 21:53' prior: 0!A browser's metagraph defines the way in which the user may traverse the graph of objects which make up the browser's domain. But it's not always desirable to have all the nodes made available by the metagraph to be visible in the browser. An filter provides a strategy for filtering out some of the nodes from the display. OBFilter provides a "null" filter - one that does no filtering at all - and serves as a superclass for other filters. !(OBFilter instVarNames includes: 'metaNode') ifFalse:	[OBFilter addInstVarName: 'metaNode']!!OBFilter methodsFor: 'user interface'!buildOn: aBuilder	! !!OBFilter methodsFor: 'filtering'!displayString: aString forNode: aNode	^ aString! !!OBFilter methodsFor: 'filtering'!displayString: aString forParent: pNode child: cNode	^ aString! !!OBFilter methodsFor: 'filtering'!edgesFrom: aCollection forNode: aNode	^ aCollection! !!OBFilter methodsFor: 'filtering'!icon: aSymbol forNode: aNode	^ aSymbol! !!OBFilter methodsFor: 'accessing'!metaNode	^ metaNode! !!OBFilter methodsFor: 'filtering'!nodesFrom: aCollection forNode: aNode	^ aCollection! !!OBFilter methodsFor: 'filtering'!noteParent: pNode child: cNode! !!OBFilter methodsFor: 'initalizing'!setMetaNode: aMetaNode	metaNode _ aMetaNode! !!OBFilter methodsFor: 'testing'!wantsButton	^ false! !!OBFilter methodsFor: 'testing'!wantsSwitch	^ false! !RectangleMorph subclass: #OBGroupingMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBGroupingMorph methodsFor: 'as yet unclassified' stamp: 'cwp 12/9/2007 12:03'!addBorders	self borderWidth: 0.	self submorphs do:		[:morph |		morph class = self class			ifTrue: [morph addBorders]			ifFalse:				[morph adoptPaneColor: color.				morph 					borderWidth: 2; 					borderColor: #inset; 					color: Color transparent]]! !!OBGroupingMorph methodsFor: 'as yet unclassified' stamp: 'cwp 12/9/2007 10:50'!addMorph: aMorph frame: relFrame	"Stole this from SystemWindow"		| frame |	frame _ LayoutFrame new.	frame 		leftFraction: relFrame left; 		rightFraction: relFrame right; 		topFraction: relFrame top; 		bottomFraction: relFrame bottom.	self addMorph: aMorph fullFrame: frame.! !!OBGroupingMorph methodsFor: 'as yet unclassified' stamp: 'lr 1/22/2008 20:08'!initialize	super initialize.	self borderWidth: 0.	self color: Color transparent! !Notification subclass: #OBInteractionRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!!OBInteractionRequest commentStamp: 'cwp 12/7/2004 00:13' prior: 0!OBInteractionRequest is an abstract superclass for notifications that request some interaction with the user. It's useful for catching such notifications in an exception handler, while allowing other notifications to operate normally.!!OBInteractionRequest methodsFor: 'exceptionDescription'!defaultAction	^ self handleWith: OBPlatform current! !!OBInteractionRequest methodsFor: 'dispatching'!handleWith: anObject	self subclassResponsibility ! !!OBInteractionRequest methodsFor: 'testing'!isBrowseRequest	^ false! !TestCase subclass: #OBKeyBindingsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!(OBKeyBindingsTest instVarNames includes: 'ptm') ifFalse:	[OBKeyBindingsTest addInstVarName: 'ptm']!(OBKeyBindingsTest instVarNames includes: 'message') ifFalse:	[OBKeyBindingsTest addInstVarName: 'message']!!OBKeyBindingsTest methodsFor: 'asserting' stamp: 'cwp 10/31/2004 00:36'!assert: evt sends: aSelector	ptm keyStroke: evt.	self assert: message notNil.	self assert: message selector = aSelector.	self assert: message arguments size = 1.	self assert: message arguments first = #OBBrowser.! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/30/2004 23:58'!browseIt: aSelector	message _ self thisMessage.	^ true! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/31/2004 00:39'!implementorsOfIt: aSelector	message _ self thisMessage.	^ true! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:08'!ksCmdB	^ self modifier: 64 keycode: 98! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:08'!ksCmdM	^ self modifier: 64 keycode: 109! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:08'!ksCmdN	^ self modifier: 64 keycode: 110! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:09'!ksCmdShiftE	^ self modifier: 72 keycode: 69! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:09'!ksCmdShiftN	^ self modifier: 72 keycode: 78! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:09'!ksCmdShiftW	^ self modifier: 72 keycode: 87! !!OBKeyBindingsTest methodsFor: 'keystrokes' stamp: 'cwp 10/31/2004 01:07'!modifier: mod keycode: code	| string |	string := 'keystroke 988180 ', mod asString, ' ', code asString.	^ KeyboardEvent readFrom: string readStream! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/31/2004 00:49'!referencesToIt: aSelector	message := self thisMessage.	^ true! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/30/2004 23:26'!selection	^ 1 to: 9! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/31/2004 00:25'!sendersOfIt: aSelector	message := self thisMessage.	^ true! !!OBKeyBindingsTest methodsFor: 'running' stamp: 'cwp 10/30/2004 22:05'!setUp	ptm := (OBPluggableTextMorph			on: self			text: #text			accept: #accept:notifying:			readSelection: #selection			menu: #menu:shifted:)				font: Preferences standardCodeFont;				yourself! !!OBKeyBindingsTest methodsFor: 'tests' stamp: 'cwp 10/31/2004 00:33'!testBrowseIt	self assert: self ksCmdB sends: #browseIt:! !!OBKeyBindingsTest methodsFor: 'tests' stamp: 'cwp 10/31/2004 00:35'!testImplementorsOfIt	self assert: self ksCmdM sends: #implementorsOfIt:! !!OBKeyBindingsTest methodsFor: 'tests' stamp: 'cwp 10/31/2004 00:44'!testReferencesToIt	self assert: self ksCmdShiftN sends: #referencesToIt:! !!OBKeyBindingsTest methodsFor: 'tests' stamp: 'cwp 10/31/2004 00:35'!testSendersOfIt	self assert: self ksCmdN sends: #sendersOfIt:! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/30/2004 23:26'!text	^ 'OBBrowser'! !!OBKeyBindingsTest methodsFor: 'callbacks' stamp: 'cwp 10/30/2004 23:57'!thisMessage	| context args |	context := thisContext sender.	args := Array new: context size.	1 to: args size do: [:i | args at: i put: (context at: 1)].	^ Message 		selector: context method selector		arguments: args ! !LazyListMorph subclass: #OBLazyListMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBLazyListMorph commentStamp: 'dr 7/18/2007 14:28' prior: 0!I am an adapted version of LazyListMorph. I can display icons and colors for my elements.!!OBLazyListMorph methodsFor: 'drawing' stamp: 'dr 6/12/2007 17:16'!colorForRow: row     | item |	^(selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Color red ]		ifFalse: [ item := self getListItem: row. item isText ifTrue: [item colorAt: 1] ifFalse: [self color] ].! !!OBLazyListMorph methodsFor: 'drawing' stamp: 'cwp 7/24/2007 00:15'!display: item  atRow: row on: canvas	"display the given item at row row"	| drawBounds top icon |	drawBounds := self drawBoundsForRow: row.	drawBounds := drawBounds intersect: self bounds.	(listSource iconAt: row) ifNotNilDo: 		[:name |		icon _ OBMorphicIcons iconNamed: name.		top _ drawBounds top + (drawBounds height - icon height // 2).		canvas translucentImage: icon at: drawBounds left @ top.		drawBounds := drawBounds left: drawBounds left + icon width + 2].		item isText		ifTrue: [canvas drawString: item in: drawBounds font: (font emphasized: (item emphasisAt: 1)) color: (self colorForRow: row) ]		ifFalse: [canvas drawString: item in: drawBounds font: font color: (self colorForRow: row) ].! !Object subclass: #OBMetaEdge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!!OBMetaEdge commentStamp: 'cwp 1/7/2005 23:20' prior: 0!An OBMetaEdge is an edge in the browser's metagraph. It represents a message sent to a node to obtain further nodes. It is refered to by the "parent" metanode, and refers to the "child" metanode.iVars:label 		-  a string describing the metaNode, for filters which allow the user 			   to choose which edges to followselector	- when a node is selected by the user, this message will be 			  sent to it to obtain its childrenmetaNode 	- a MetaNode corresponding to the nodes answered by the above message		!(OBMetaEdge instVarNames includes: 'label') ifFalse:	[OBMetaEdge addInstVarName: 'label']!(OBMetaEdge instVarNames includes: 'selector') ifFalse:	[OBMetaEdge addInstVarName: 'selector']!(OBMetaEdge instVarNames includes: 'metaNode') ifFalse:	[OBMetaEdge addInstVarName: 'metaNode']!!OBMetaEdge methodsFor: 'accessing'!-> aNode	metaNode _ aNode! !!OBMetaEdge methodsFor: 'accessing'!/ aString	label _ aString! !!OBMetaEdge methodsFor: 'accessing'!label	^ label! !!OBMetaEdge methodsFor: 'accessing'!metaNode	^ metaNode! !!OBMetaEdge methodsFor: 'accessing'!nodesForParent: aNode	^ (aNode perform: selector) do: [:ea | ea metaNode: metaNode]! !!OBMetaEdge methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: selector printString, '->'. 	metaNode shortPrintOn: aStream.! !!OBMetaEdge methodsFor: 'accessing'!selector	^ selector! !!OBMetaEdge methodsFor: 'initializing'!setLabel: aString selector: aSelector metaNode: aMetaNode	label _ aString.	selector _ aSelector.	metaNode _ aMetaNode! !!OBMetaEdge class methodsFor: 'as yet unclassified'!label: aString selector: aSelector metaNode: aMetaNode	^ self new setLabel: aString selector: aSelector metaNode: aMetaNode! !!OBMetaEdge class methodsFor: 'as yet unclassified'!selector: aSymbol	^ self selector: aSymbol metaNode: nil! !!OBMetaEdge class methodsFor: 'as yet unclassified'!selector: aSelector metaNode: aMetaNode	^ self new setLabel: aSelector asString selector: aSelector metaNode: aMetaNode! !Object subclass: #OBMetaNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!!OBMetaNode commentStamp: 'cwp 1/7/2005 23:23' prior: 0!A MetaNode represents a hypothetical node in the browser's domain graph.iVars:filterClass			- the class used to filter this hypothetical node's childrencolumnClass		- the class of column used to display this node's childrenedges				- messages that could be sent to the node to obtain childrenactors				- providers of functionality for manipulating the nodedisplaySelector		- the message used to retreive a nodes display name!(OBMetaNode instVarNames includes: 'name') ifFalse:	[OBMetaNode addInstVarName: 'name']!(OBMetaNode instVarNames includes: 'filters') ifFalse:	[OBMetaNode addInstVarName: 'filters']!(OBMetaNode instVarNames includes: 'edges') ifFalse:	[OBMetaNode addInstVarName: 'edges']!(OBMetaNode instVarNames includes: 'autoSelect') ifFalse:	[OBMetaNode addInstVarName: 'autoSelect']!(OBMetaNode instVarNames includes: 'ancestrySelector') ifFalse:	[OBMetaNode addInstVarName: 'ancestrySelector']!(OBMetaNode instVarNames includes: 'displaySelector') ifFalse:	[OBMetaNode addInstVarName: 'displaySelector']!!OBMetaNode methodsFor: 'children'!- aSelector	^ edges add: (OBMetaEdge selector: aSelector).	! !!OBMetaNode methodsFor: 'accessing'!addFilter: aFilter	aFilter setMetaNode: self.	filters add: aFilter! !!OBMetaNode methodsFor: 'nodes'!allChildrenForNode: aNode	^ edges gather: [:edge | edge nodesForParent: aNode]! !!OBMetaNode methodsFor: 'accessing'!ancestrySelector	^ ancestrySelector ifNil: [#isDescendantOf:]! !!OBMetaNode methodsFor: 'accessing'!ancestrySelector: anObject	ancestrySelector _ anObject! !!OBMetaNode methodsFor: 'accessing'!autoSelect	^ autoSelect ifNotNil: [autoSelect metaNode]! !!OBMetaNode methodsFor: 'children'!autoSelect: aMetanode	autoSelect _ edges detect: [:ea | ea metaNode == aMetanode] ifNone: [nil]! !!OBMetaNode methodsFor: 'children'!childAt: aSelector labeled: aString put: aMetaNode	edges add: (OBMetaEdge label: aString selector: aSelector metaNode: aMetaNode)! !!OBMetaNode methodsFor: 'children'!childAt: aSelector put: aMetaNode	edges add: (OBMetaEdge selector: aSelector metaNode: aMetaNode)! !!OBMetaNode methodsFor: 'nodes'!childOf: parent ancestorOf: descendant indexIn: aBlock 	(self childsPerEdgeFor: parent) do: 		[ : childsPerEdge | 			childsPerEdge doWithIndex: 				[ :node :index | 					(node isAncestorOf: descendant using: node metaNode ancestrySelector)						ifTrue: [ filters do: [ : f | f noteParent: parent child: node ].					aBlock value: index.				 ^ node ] ] ].	^ nil! !!OBMetaNode methodsFor: 'children'!children	^ edges collect: [:edge | edge metaNode]! !!OBMetaNode methodsFor: 'nodes'!childrenForNode: aNode	| chosenEdges |	chosenEdges _ self edgesForNode: aNode.	^ chosenEdges gather: 		[:edge | 		filters 			inject: (edge nodesForParent: aNode)			into: [:list :filter | filter nodesFrom: list forNode: aNode]].! !!OBMetaNode methodsFor: 'children'!childsPerEdgeFor: aNode 	"collects all childs and returns an array with one list of childs per edge.	all filters are applied to the child lists."	^ edges		collect: [:edge | filters							inject: (edge nodesForParent: aNode)							into: [:list :filter | filter nodesFrom: list forNode: aNode]].! !!OBMetaNode methodsFor: 'accessing'!displaySelector	^ displaySelector ifNil: [displaySelector _ #name]! !!OBMetaNode methodsFor: 'accessing'!displaySelector: aSelector	displaySelector _ aSelector! !!OBMetaNode methodsFor: 'filtering'!displayStringForNode: aNode	^ filters		inject: (aNode perform: self displaySelector)		into: [:string :filter | filter displayString: string forNode: aNode]! !!OBMetaNode methodsFor: 'filtering'!displayStringForParent: pNode child: cNode	^ filters		inject: cNode displayString		into: [:string :filter | filter displayString: string forParent: pNode child: cNode]! !!OBMetaNode methodsFor: 'metagraph'!edges	^ edges! !!OBMetaNode methodsFor: 'accessing'!edgesForNode: aNode 	^ filters 		inject: edges 		into: [:list :filter | filter edgesFrom: list forNode: aNode].! !!OBMetaNode methodsFor: 'children'!hasChildren	^ edges isEmpty not! !!OBMetaNode methodsFor: 'filtering'!iconForNode: aNode	^ filters inject: nil into: [:icon :filter | filter icon: icon forNode: aNode]! !!OBMetaNode methodsFor: 'initializing'!initialize	filters _ OrderedCollection new.	edges _ OrderedCollection new.! !!OBMetaNode methodsFor: 'filtering'!metaNode	^ self! !!OBMetaNode methodsFor: 'accessing'!name	^ name ifNil: ['MetaNode']! !!OBMetaNode methodsFor: 'accessing'!name: aString	name _ aString! !!OBMetaNode methodsFor: 'nodes'!nodesForParent: aNode	^ edges gather: [:edge | edge nodesForParent: aNode]! !!OBMetaNode methodsFor: 'nodes'!noteParent: pNode child: cNode	filters do: [:ea | ea noteParent: pNode child: cNode]! !!OBMetaNode methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self name;cr.	edges do: [:e | e printOn: aStream. aStream cr].! !!OBMetaNode methodsFor: 'printing'!shortPrintOn: aStream	aStream nextPutAll: self name.! !!OBMetaNode methodsFor: 'filtering'!switchFilter	^ filters 		detect: [:ea | ea wantsSwitch]		ifNone: [nil]! !!OBMetaNode class methodsFor: 'instance creation'!named: aString	^ self new name: aString! !!OBMetaNode class methodsFor: 'instance creation'!new	^ self basicNew initialize! !TestCase subclass: #OBMetaNodeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBMetaNodeTest methodsFor: 'callbacks' stamp: 'cwp 5/4/2007 23:26'!children	^ #(a b c) collect: [:ea | OBFakeNode parent: nil item: ea]! !!OBMetaNodeTest methodsFor: 'callbacks' stamp: 'cwp 5/6/2007 01:12'!left	^ #(a b c) collect: [:ea | OBFakeNode parent: nil item: ea]! !!OBMetaNodeTest methodsFor: 'support' stamp: 'cwp 7/23/2007 00:57'!metaNodeFilter: aSelector do: aBlock	| metanode filter |	metanode _ OBMetaNode named: 'root'.	filter _ OBPluggableFilter new perform: aSelector with: aBlock.	metanode addFilter: filter.	^ metanode! !!OBMetaNodeTest methodsFor: 'callbacks' stamp: 'cwp 5/6/2007 01:13'!right	^ #(d e f) collect: [:ea | OBFakeNode parent: nil item: ea]! !!OBMetaNodeTest methodsFor: 'emulating' stamp: 'cwp 5/18/2007 00:32'!setMetaNode: aMetanode 	! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 5/6/2007 00:29'!testChildrenForNode	| root child nodes |	root _ OBMetaNode named: 'root'.	child _ OBMetaNode named: 'child'.	root - #children -> child. 		nodes _ root childrenForNode: self.	self assert: nodes size = 3.	self assert: (nodes allSatisfy: [:ea | ea class == OBFakeNode]).	self assert: (nodes collect: [:ea | ea item]) = #(a b c)! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 5/4/2007 23:13'!testConstruction	| root child |	root _ OBMetaNode named: 'root'.	child _ OBMetaNode named: 'child'.	root - #children -> child. 	self assert: root children anyOne == child.	self assert: root edges anyOne selector = #children.! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 5/4/2007 23:11'!testConstructionWithLabel	| root child edge |	root _ OBMetaNode named: 'root'.	child _ OBMetaNode named: 'child'.	root - #children / 'kids' -> child.	edge _ root edges anyOne.	self assert: root children anyOne == child.	self assert: edge selector = #children.	self assert: edge label = 'kids'! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 7/23/2007 00:55'!testFiltersCanAddIcon	| root result |	root _ self metaNodeFilter: #icon: do: [:icon :node | #testIcon].	result _ root iconForNode: self.	self assert: result = #testIcon! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 7/23/2007 01:01'!testFiltersCanAlterDisplayStrings	| root name result |	name _ 'this name was changed'.	root _ self metaNodeFilter: #nodeDisplay: do: [:string :node | name].		result _ root displayStringForNode: self.	self assert: result = name! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 7/23/2007 01:15'!testFiltersCanChooseEdges	| root nodes left right |	root _ self metaNodeFilter: #edges: do: [:edges :node | edges allButLast].	left _ OBMetaNode named: 'left'.	right _ OBMetaNode named: 'right'.	root - #left -> left.	root - #right -> right.		nodes _ root childrenForNode: self.	self assert: (nodes collect: [:ea | ea item]) = #(a b c)! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 7/23/2007 01:16'!testFiltersCanChooseNodes	| root nodes left right |	root _ self metaNodeFilter: #nodes: do: [:edges :node | edges allButLast].	left _ OBMetaNode named: 'left'.	right _ OBMetaNode named: 'right'.	root - #left -> left.	root - #right -> right.		nodes _ root childrenForNode: self.	self assert: (nodes collect: [:ea | ea item]) = #(a b d e)! !!OBMetaNodeTest methodsFor: 'tests' stamp: 'cwp 5/4/2007 23:28'!testNodesForParent	| root child nodes |	root _ OBMetaNode named: 'root'.	child _ OBMetaNode named: 'child'.	root - #children -> child. 		nodes _ root nodesForParent: self.	self assert: nodes size = 3.	self assert: (nodes allSatisfy: [:ea | ea class == OBFakeNode]).	self assert: (nodes collect: [:ea | ea item]) = #(a b c)! !Object subclass: #OBMorphicIcons	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Core'!(OBMorphicIcons classVarNames includes: 'Icons') ifFalse:	[OBMorphicIcons addClassVarName: 'Icons']!!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 10:27'!arrowDown	^ ((ColorForm	extent: 12@12	depth: 8	fromArray: #( 185273099 185273099 185273099 185273099 185273099 185273099 185273098 168430090 168495883 185273098 151587081 168495883 185273098 151191561 168495883 185207306 151388169 168430091 185207049 151257353 151587339 185272841 328199 151653131 185273098 150997001 168495883 185273099 168364298 185273099 185273099 185207307 185273099 185273099 185273099 185273099)	offset: 0@0)	colorsFromArray: #(#(0.573 0.804 0.369) #(0.565 0.768 0.412) #(0.577 0.804 0.372) #(0.561 0.804 0.326) #(0.588 0.831 0.345) #(0.6 0.844 0.353) #(0.565 0.804 0.329) #(0.545 0.772 0.349) #(0.486 0.682 0.353) #(0.388 0.561 0.271) #(1.0 1.0 1.0) #( )))! !!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 10:24'!arrowUp	^ ((ColorForm	extent: 12@12	depth: 8	fromArray: #( 185273099 185273099 185273099 185273099 185273099 185273099 185273099 185207307 185273099 185273099 168364298 185273099 185273098 150997001 168495883 185272841 328199 151653131 185207049 151257353 151587339 185207306 151388169 168430091 185273098 151191561 168495883 185273098 151587081 168495883 185273098 168430090 168495883 185273099 185273099 185273099)	offset: 0@0)	colorsFromArray: #(#(0.573 0.804 0.369) #(0.565 0.768 0.412) #(0.577 0.804 0.372) #(0.561 0.804 0.326) #(0.588 0.831 0.345) #(0.6 0.844 0.353) #(0.565 0.804 0.329) #(0.545 0.772 0.349) #(0.486 0.682 0.353) #(0.388 0.561 0.271) #(1.0 1.0 1.0) #( )))! !!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 10:34'!arrowUpAndDown	^ ((ColorForm	extent: 12@12	depth: 8	fromArray: #( 185273099 185207307 185273099 185273099 167772170 185273099 185273098 262400 168495883 185272832 67699971 658187 185204736 524800 2571 185207306 459776 168430091 185207306 394240 168430091 185204736 524800 2571 185272832 67699971 658187 185273098 262400 168495883 185273099 167772170 185273099 185273099 185207307 185273099)	offset: 0@0)	colorsFromArray: #(#(0.388 0.561 0.271) #(0.486 0.682 0.353) #(0.565 0.768 0.412) #(0.545 0.772 0.349) #(0.573 0.804 0.369) #(0.577 0.804 0.372) #(0.561 0.804 0.326) #(0.565 0.804 0.329) #(0.588 0.831 0.345) #(0.6 0.844 0.353) #(1.0 1.0 1.0) #( )))! !!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 10:34'!blank	^ Form extent: 12@12 depth: 8! !!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 19:32'!breakpoint	^ ((ColorForm	extent: 12@12	depth: 8	fromArray: #( 437918234 437918234 437918234 437654804 319885069 26 437590295 404100630 100859930 437524241 269290764 100860442 437327375 235736076 67305498 437261581 218893324 67305754 437130258 303174162 84082970 436931081 134678279 196890 437918234 437918234 196890 454761243 454761242 196890 454761243 454761242 196634 454761243 454761242 26)	offset: 0@0)	colorsFromArray: #(#(0.349 0.212 0.098) #(0.329 0.2 0.094) #(0.376 0.232 0.109) #(0.694 0.462 0.271) #(0.608 0.271 0.204) #(0.545 0.185 0.113) #(0.784 0.322 0.294) #(0.721 0.023 0.023) #(0.788 0.055 0.055) #(0.848 0.106 0.106) #(0.875 0.137 0.137) #(0.914 0.208 0.208) #(0.953 0.298 0.298) #(0.953 0.318 0.318) #(0.953 0.333 0.333) #(0.953 0.349 0.349) #(0.953 0.365 0.365) #(0.953 0.388 0.388) #(0.922 0.427 0.427) #(0.953 0.482 0.482) #(0.949 0.542 0.538) #(0.957 0.592 0.592) #(0.953 0.624 0.62) #(0.984 0.879 0.879) #(0.988 0.898 0.898) #(0.992 0.918 0.918) #(1.0 1.0 1.0) #( )))! !!OBMorphicIcons methodsFor: 'icons' stamp: 'lr 8/2/2007 19:32'!flag	^ ((ColorForm	extent: 12@12	depth: 8	fromArray: #( 437918234 437918234 437918234 436470535 101584139 387389210 436404481 17105924 303634202 436666638 218827016 35198490 437126412 185075720 1644314 437060363 168298504 1644570 436930320 269422351 370743322 437326099 320082453 387520538 437918234 437918234 387520538 454761243 454761242 387520538 454761243 454761242 387520282 454761243 454761242 387389210)	offset: 0@0)	colorsFromArray: #(#(0.22 0.396 0.585) #(0.898 0.945 0.996) #(0.228 0.498 0.761) #(0.608 0.796 0.98) #(0.635 0.804 0.98) #(0.655 0.819 0.98) #(0.47 0.729 0.973) #(0.542 0.768 0.977) #(0.251 0.631 0.961) #(0.267 0.639 0.961) #(0.275 0.643 0.961) #(0.286 0.647 0.961) #(0.302 0.659 0.965) #(0.326 0.667 0.965) #(0.353 0.678 0.965) #(0.396 0.714 0.965) #(0.419 0.729 0.969) #(0.239 0.686 0.93) #(0.243 0.624 0.772) #(0.236 0.682 0.851) #(0.228 0.667 0.788) #(0.224 0.616 0.671) #(0.384 0.228 0.082) #(0.349 0.212 0.098) #(0.329 0.2 0.094) #(0.694 0.462 0.271) #(1.0 1.0 1.0) #( )))! !!OBMorphicIcons class methodsFor: 'as yet unclassified' stamp: 'cwp 7/24/2007 00:01'!iconNamed: aSymbol	^ Icons at: aSymbol ifAbsentPut: [self new perform: aSymbol]! !!OBMorphicIcons class methodsFor: 'as yet unclassified' stamp: 'cwp 7/24/2007 00:02'!initialize	Icons _ IdentityDictionary new! !Object subclass: #OBNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!!OBNode commentStamp: 'cwp 3/4/2004 22:20' prior: 0!A node is a wrapper for an object in the browser's domain graph. OBNode is an abstract superclass for concrete nodes which might appear in the browser.iVars:metaNode - the MetaNode which produced this node!(OBNode instVarNames includes: 'metaNode') ifFalse:	[OBNode addInstVarName: 'metaNode']!!OBNode methodsFor: 'comparing'!= other	^ self class = other class and: [self name = other name]! !!OBNode methodsFor: 'public'!accept: aText notifying: aController	^ self text: aText! !!OBNode methodsFor: '*ob-morphic' stamp: 'cwp 3/2/2004 21:28'!acceptDroppedNode: aNode 	^ aNode perform: self dropSelector with: self! !!OBNode methodsFor: 'ancestry'!ancestrySelector	^ #isDescendantOf: ! !!OBNode methodsFor: 'updating'!announce: anObject	^ OBAnnouncer current ifNotNilDo: [:announcer | announcer announce: anObject]! !!OBNode methodsFor: 'updating'!announceChangedWith: anObject	anObject announce: (OBNodeChanged node: self)! !!OBNode methodsFor: 'updating'!announceChildrenChangedWith: anObject	anObject announce: (OBChildrenChanged node: self)! !!OBNode methodsFor: 'updating'!announceCreationWith: anObject	anObject announce: (OBNodeCreated node: self)! !!OBNode methodsFor: 'updating'!announceDeletionWith: anObject	anObject announce: (OBNodeDeleted node: self)! !!OBNode methodsFor: 'updating'!announceSelectionWith: anObject	(anObject announce: OBAboutToChange)		isVetoed ifFalse: [anObject announce: (OBSelectingNode node: self)]! !!OBNode methodsFor: '*ob-morphic' stamp: 'avi 2/20/2004 14:00'!asDraggableMorph	^(StringMorph contents: self name)		color: Color white;		yourself! !!OBNode methodsFor: 'converting'!asFan	^ OBFan parent: self! !!OBNode methodsFor: 'public'!childAncestorOf: aNode indexIn: aBlock 	^ self metaNode 		childOf: self		ancestorOf: aNode		indexIn: aBlock! !!OBNode methodsFor: 'public'!childNodes	^ metaNode childrenForNode: self! !!OBNode methodsFor: 'public'!definition	^ self! !!OBNode methodsFor: 'updating'!demandSelection	^ OBAnnouncer current announce: (OBNodeCreated node: self)! !!OBNode methodsFor: 'displaying'!displayString	^ metaNode displayStringForNode: self! !!OBNode methodsFor: 'displaying'!displayStringForChild: aNode	^ metaNode displayStringForParent: self child: aNode! !!OBNode methodsFor: '*ob-morphic' stamp: 'cwp 3/2/2004 21:29'!dropSelector	"Override in subclasses"		^ #dropOnNode: ! !!OBNode methodsFor: 'comparing'!hash	^ self name hash! !!OBNode methodsFor: 'displaying'!icon	^ metaNode iconForNode: self! !!OBNode methodsFor: 'accessing'!icons    ^#()! !!OBNode methodsFor: 'ancestry'!isAncestorOf: aNode	^ self isAncestorOf: aNode using: self ancestrySelector! !!OBNode methodsFor: 'ancestry'!isAncestorOf: aNode using: aSelector	^ aNode perform: aSelector with: self! !!OBNode methodsFor: 'ancestry'!isDescendantOf: aNode	^ false! !!OBNode methodsFor: 'accessing'!metaNode	^ metaNode! !!OBNode methodsFor: 'accessing'!metaNode: aMetaNode	metaNode _ aMetaNode! !!OBNode methodsFor: 'public'!name	self subclassResponsibility! !!OBNode methodsFor: 'public'!noteChild: aNode	metaNode noteParent: self child: aNode! !!OBNode methodsFor: 'utility'!referenceForMethod: selector ofClass: className	| classIsMeta symbol |	classIsMeta _ className endsWith: ' class'.	symbol _ classIsMeta ifTrue: [(className allButLast: 6) asSymbol] ifFalse: [className].	^ MethodReference new 		setClassSymbol: symbol		classIsMeta: classIsMeta		methodSymbol: selector		stringVersion: symbol, '>>', selector! !!OBNode methodsFor: 'updating'!signalChanged	self announce: (OBNodeChanged node: self)! !!OBNode methodsFor: 'updating'!signalChildrenChanged	self announce: (OBChildrenChanged node: self)! !!OBNode methodsFor: 'updating'!signalDeletion	self announce: (OBNodeDeleted node: self)! !!OBNode methodsFor: 'updating'!signalSelection	(self announce: OBAboutToChange)		isVetoed ifFalse: [self announce: (OBSelectingNode node: self)]! !!OBNode methodsFor: 'public'!text	^ ''! !!OBNode methodsFor: 'public'!text: aText	^ false! !!OBNode methodsFor: 'public'!textSelection	^ 1 to: 0! !!OBNode methodsFor: 'displaying'!title	^ nil! !!OBNode methodsFor: '*ob-morphic' stamp: 'cwp 3/2/2004 21:28'!wantsDroppedNode: aNode	^ aNode respondsTo: self dropSelector! !!OBNode class methodsFor: 'as yet unclassified'!fromAssociation: anAssociationNode	^ self on: anAssociationNode value! !TestCase subclass: #OBOpenTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBOpenTest instVarNames includes: 'browser') ifFalse:	[OBOpenTest addInstVarName: 'browser']!!OBOpenTest methodsFor: 'actions' stamp: 'cwp 12/5/2004 15:54'!create: aBlock	self 		shouldnt: [browser _ aBlock value]		raise: OBBrowseRequest! !!OBOpenTest methodsFor: 'actions' stamp: 'cwp 12/5/2004 15:52'!open: aBlock	[aBlock value]		on: OBBrowseRequest		do: [:n | browser _ n browser].	self assert: browser notNil! !!OBOpenTest class methodsFor: 'testing' stamp: 'cwp 12/5/2004 15:55'!isAbstract	^ self name = #OBOpenTest! !RectangleMorph subclass: #OBPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBPane commentStamp: 'cwp 1/7/2005 23:24' prior: 0!An OBPane is the visual representation of a column in a browser. It contains a morph to display nodes (typically a PluggableListMorph) and (optionally) a morph for communicating with the column's filter. It's main responsibility is to lay out its submorphs as the filter controls are added and removed.iVars:model	- the OBColumn that controls the node list displayed in this panelist		- the morph which displays the node list, usually a PluggableListMorphbutton	- the morph which controls the column's filter, usually an OBRadioButtonBar.!(OBPane instVarNames includes: 'model') ifFalse:	[OBPane addInstVarName: 'model']!(OBPane instVarNames includes: 'list') ifFalse:	[OBPane addInstVarName: 'list']!(OBPane instVarNames includes: 'button') ifFalse:	[OBPane addInstVarName: 'button']!!OBPane methodsFor: 'updating' stamp: 'cwp 11/2/2004 00:53'!addButton: aButton	self hasButton ifTrue: [self removeMorph: button].	button _ aButton.	button height: self defaultButtonHeight.	self 		addMorph: button;		adjustList;		adjustButton! !!OBPane methodsFor: 'updating' stamp: 'cwp 3/14/2007 23:33'!addList: aListMorph	list _ aListMorph.	self addMorph: list.	list bounds: self innerBounds.! !!OBPane methodsFor: 'updating' stamp: 'cwp 5/17/2007 23:56'!adjustButton	| inner |	self hasButton ifTrue: 		[inner _ self innerBounds.		button bounds: (inner withTop: inner bottom - button height)]! !!OBPane methodsFor: 'updating' stamp: 'cwp 3/14/2007 23:26'!adjustList	self hasButton		ifFalse: [self list bounds: self innerBounds]		ifTrue: [self list bounds: (self innerBounds withHeight: (self height - self buttonHeight))]! !!OBPane methodsFor: 'geometry' stamp: 'cwp 2/12/2004 18:32'!bounds: aRectangle	super bounds: aRectangle.	self adjustList.	self adjustButton.! !!OBPane methodsFor: 'accessing' stamp: 'cwp 3/14/2007 23:28'!button	^ button! !!OBPane methodsFor: 'constructing' stamp: 'cwp 5/18/2007 00:02'!buttonFor: aSwitch	^ aSwitch buildOn: OBMorphBuilder new 	! !!OBPane methodsFor: 'constructing' stamp: 'cwp 11/2/2004 00:57'!buttonHeight	^ self hasButton		ifTrue: [button height]		ifFalse: [self defaultButtonHeight]! !!OBPane methodsFor: 'constructing' stamp: 'cwp 11/2/2004 01:10'!defaultButtonHeight	^ 23! !!OBPane methodsFor: 'testing' stamp: 'cwp 2/12/2004 18:35'!hasButton	^ button notNil! !!OBPane methodsFor: 'initialization' stamp: 'cwp 3/14/2007 23:42'!initGeometry	self			hResizing: #spaceFill;		vResizing: #spaceFill;		clipSubmorphs: true;		color: Color transparent;		cellInset: 0;		borderWidth: 0;		layoutPolicy: ProportionalLayout new.		! !!OBPane methodsFor: 'accessing' stamp: 'cwp 3/14/2007 23:42'!list	^ list! !!OBPane methodsFor: 'initialization' stamp: 'cwp 2/12/2004 18:44'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!OBPane methodsFor: 'constructing' stamp: 'cwp 11/27/2004 21:19'!noteNewOwner: aMorph	self containingWindow ifNotNilDo: [:window | self adoptPaneColor: window paneColor]! !!OBPane methodsFor: 'updating' stamp: 'cwp 2/12/2004 20:29'!removeButton	self hasButton 		ifTrue: [self removeMorph: button.				button _ nil.				self adjustList]! !!OBPane methodsFor: 'updating' stamp: 'cwp 5/18/2007 23:09'!update: aSelector	aSelector = #switch ifFalse: [^ self].	self hasButton = model wantsButton ifTrue: [^ self].	model wantsButton		ifTrue: [self addButton: (self buttonFor: model switch)]		ifFalse: [self removeButton]! !TestCase subclass: #OBPaneLayoutTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 11/2/2004 00:37'!buttonMorph	^ RectangleMorph new		color: Color red;		yourself! !!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 5/3/2007 21:08'!dragEnabled	^ false! !!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 5/3/2007 21:08'!dropEnabled	^ false! !!OBPaneLayoutTest methodsFor: 'emulating' stamp: 'cwp 5/31/2007 21:00'!isActive	^ true! !!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 5/3/2007 21:11'!list	^ #('a' 'b' 'c')! !!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 11/2/2004 00:34'!listMorph	^ RectangleMorph new! !!OBPaneLayoutTest methodsFor: 'callbacks' stamp: 'cwp 5/3/2007 21:07'!selection	^ 0! !!OBPaneLayoutTest methodsFor: 'testing' stamp: 'cwp 5/21/2007 22:24'!testButtonPlacement	| pane button builder |	builder _ OBMorphBuilder new.	pane :=  builder column: self with: [builder switch: self with: []].	pane bounds: (0@0 corner: 200@400).	button := pane submorphs at: 1.	self assert: button top = 377.	self assert: button bottom = 400.	self assert: button left = pane left.	self assert: button right = pane right.! !RectangleMorph subclass: #OBPaneScroller	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBPaneScroller commentStamp: 'cwp 3/5/2004 12:13' prior: 0!Instances of OBPaneScroller contain the panes which represent columns in a browser. Their primary responsibilities are laying out panes to fit the space available and scrolling them horizontally when there isn't sufficient space. iVars:sizing		- The number of panes which should exactly fit the available space.		   	   During layout, the  width of the panes is determined accordingly.transform	- A TransformMorph used for scrollingscrollBar	- An OBHorizontalScrollBar used for scrolling!(OBPaneScroller instVarNames includes: 'model') ifFalse:	[OBPaneScroller addInstVarName: 'model']!(OBPaneScroller instVarNames includes: 'sizing') ifFalse:	[OBPaneScroller addInstVarName: 'sizing']!(OBPaneScroller instVarNames includes: 'panes') ifFalse:	[OBPaneScroller addInstVarName: 'panes']!(OBPaneScroller instVarNames includes: 'transform') ifFalse:	[OBPaneScroller addInstVarName: 'transform']!(OBPaneScroller instVarNames includes: 'scrollBar') ifFalse:	[OBPaneScroller addInstVarName: 'scrollBar']!!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/8/2004 11:10'!adjustPaneHeight	"This gets called after the scrollbar has been shown or hidden, to move the bottom	of the panes to the right place."		transform bounds: self innerBounds.	transform submorphsDo: [:m | m bounds: (m bounds withHeight: self paneHeight)]		! !!OBPaneScroller methodsFor: 'private' stamp: 'cwp 3/25/2007 00:16'!basicUpdatePanes	| builder |	builder _ OBMorphBuilder new.	panes := model 		ifNil: [Array new]		ifNotNil: [model columns collect: [:ea | ea buildOn: builder]].			self clearPanes.	panes do: [:ea | self pushPane: ea].! !!OBPaneScroller methodsFor: 'private' stamp: 'cwp 11/23/2004 01:14'!basicUpdateSizing	model ifNil: [sizing := 1] ifNotNil: [sizing := model sizing]! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 11/21/2004 23:45'!bounds: aRectangle	super bounds: aRectangle.	self layoutWidgets.	self layoutPanes.	self setScrollDeltas.! !!OBPaneScroller methodsFor: 'panes' stamp: 'cwp 12/6/2003 17:06'!clearPanes	transform removeAllMorphs! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/26/2004 23:14'!computeMorphWidths	| paneWidths widths |	paneWidths _ self paneWidthsToFit: self totalPaneWidth.	widths _ OrderedCollection new.	paneWidths do: [:w | widths add: w] separatedBy: [widths add: self separatorWidth].	^ widths asArray! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/8/2004 11:06'!doLayout	self layoutWidgets.	self layoutPanes.	self hideOrShowScrollBar.	self setScrollDeltas.	self scrollToRight.! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 2/8/2004 10:44'!hideOrShowScrollBar	self isScrollable ifTrue: [self showScrollBar] ifFalse: [self hideScrollBar]! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 2/8/2004 11:10'!hideScrollBar	self removeMorph: scrollBar.	self adjustPaneHeight.! !!OBPaneScroller methodsFor: 'initialization' stamp: 'cwp 5/28/2007 01:30'!initialize	super initialize.	self 		color: Color white;		borderWidth: 0;		vResizing: #spaceFill;		hResizing: #spaceFill.	self 		initializeTransform;		initializeScrollbar.! !!OBPaneScroller methodsFor: 'initialization' stamp: 'cwp 2/8/2004 11:01'!initializeScrollbar	scrollBar _ OBScrollBar new model: self slotName: 'scrollBar'.	scrollBar 		borderWidth: 0;		borderColor: #inset;		height: self scrollBarHeight.	self resizeScrollBar.! !!OBPaneScroller methodsFor: 'initialization' stamp: 'cwp 2/8/2004 10:52'!initializeTransform	transform _ TransformMorph new.	transform		color: Color transparent;		borderWidth: 0;		vResizing: #spaceFill;		hResizing: #spaceFill;		disableTableLayout;		bounds: super innerBounds.	self addMorphBack: transform.! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/8/2004 10:54'!innerBounds	| rect |	rect _ super innerBounds.	^ self scrollBarIsVisible		ifTrue: [rect withHeight: rect height - self scrollBarHeight - 1]		ifFalse: [rect]! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 2/8/2004 10:42'!isScrollable	^ self leftoverScrollRange > 0! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/8/2004 01:22'!layoutPanes	| widths rect |	widths _ self computeMorphWidths.	rect _ 0@0 extent: (0 @ self paneHeight).	transform submorphs 					with: widths 					do: [:m :w | 						rect _ rect withWidth: w.						m bounds: rect.						rect _ rect translateBy: (w@0)]						! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 8/25/2003 22:13'!layoutWidgets	| inner outer |	outer _ super innerBounds.	inner _ self innerBounds.	transform bounds: inner.	scrollBar bounds: ((inner left @ inner bottom + 1)						corner: outer bottomRight)! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 8/25/2003 21:04'!leftoverScrollRange	^ (self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0! !!OBPaneScroller methodsFor: 'accessing' stamp: 'cwp 11/17/2004 22:03'!model	^model! !!OBPaneScroller methodsFor: 'accessing' stamp: 'cwp 11/17/2004 22:11'!model: anObject	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model := anObject! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 11/17/2004 23:09'!paneCount	^ self panes size! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 12/6/2003 17:08'!paneHeight	^ transform bounds height! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/26/2004 23:14'!paneWidthsToFit: limit	| padded |	padded _ Array new: self paneCount.	padded atAllPut: (limit / self sizing) floor.	(1 to: limit - padded sum) do: [:i | padded at: i put: (padded at: i) + 1].	^ padded		! !!OBPaneScroller methodsFor: 'accessing' stamp: 'cwp 11/17/2004 23:09'!panes	^ panes ifNil: [self updatePanes. panes]! !!OBPaneScroller methodsFor: 'panes' stamp: 'cwp 11/23/2004 01:22'!popPanes: count	count * 2 timesRepeat: [transform removeMorph: transform lastSubmorph].	panes removeLast: count! !!OBPaneScroller methodsFor: 'panes' stamp: 'cwp 11/17/2004 22:46'!pushPane: aMorph	aMorph 		borderWidth: 0;		hResizing: #rigid;		vResizing: #rigid;		layoutInset: 0.	transform hasSubmorphs ifTrue: [transform addMorphBack: self separator].	transform addMorphBack: aMorph.! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/8/2004 11:03'!resizeScrollBar	| inner outer |	outer _ super innerBounds.	inner _ outer withHeight: outer height - self scrollBarHeight - 1.	scrollBar bounds: ((inner left @ inner bottom + 1)						corner: outer bottomRight)! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 8/24/2003 14:29'!scrollBarHeight	^ 12! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 2/8/2004 10:56'!scrollBarIsVisible	^ submorphs includes: scrollBar! !!OBPaneScroller methodsFor: 'updating' stamp: 'cwp 11/21/2004 13:51'!scrollBarValue: value	transform hasSubmorphs ifFalse: [^ self].	transform offset: (self leftoverScrollRange * value) rounded @ 0.! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 8/23/2003 16:21'!scrollDeltaWidth	^ 1! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 12/8/2003 21:42'!scrollToRight	^ scrollBar setValue: 1.! !!OBPaneScroller methodsFor: 'panes' stamp: 'cwp 7/21/2007 22:32'!separator	^ BorderedSubpaneDividerMorph vertical		color: model defaultBackgroundColor duller;		styleWith: OBMorphBuilder new;		yourself! !!OBPaneScroller methodsFor: 'defaults' stamp: 'cwp 7/21/2007 22:45'!separatorWidth	^ OBMorphBuilder new style39 ifTrue: [3] ifFalse: [4]! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 8/25/2003 21:14'!setScrollDeltas	| range interval value |	transform hasSubmorphs ifFalse: [scrollBar interval: 1.0. ^ self].	range _ self leftoverScrollRange.	range = 0 ifTrue: [^ scrollBar interval: 1.0; setValue: 0].	interval _ ((self innerBounds width) / self totalScrollRange) asFloat.	value _ (transform offset x / range min: 1.0) asFloat.	scrollBar interval: interval.	scrollBar setValue: value.! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 2/8/2004 11:11'!showScrollBar	self scrollBarIsVisible ifTrue: [^ self].	self resizeScrollBar.	self addMorphFront: scrollBar.	self adjustPaneHeight.	! !!OBPaneScroller methodsFor: 'accessing' stamp: 'cwp 11/22/2004 23:19'!sizing	^ sizing ifNil: [self updateSizing]! !!OBPaneScroller methodsFor: 'layout' stamp: 'cwp 2/25/2004 20:23'!totalPaneWidth	^ self innerBounds width - ((self sizing - 1) * self separatorWidth)! !!OBPaneScroller methodsFor: 'scrolling' stamp: 'cwp 8/25/2003 19:27'!totalScrollRange	| submorphBounds |	submorphBounds := transform localSubmorphBounds ifNil: [^ 0].	^ submorphBounds width! !!OBPaneScroller methodsFor: 'updating' stamp: 'cwp 3/25/2007 00:23'!update: aSymbol	aSymbol = #sizing ifTrue: [^ self updateSizing].	aSymbol = #columns ifTrue: [^ self updatePanes].! !!OBPaneScroller methodsFor: 'updating' stamp: 'cwp 11/23/2004 01:34'!updatePanes	| count |	model ifNil: [panes := Array new. ^ self].	count := panes ifNotNil: [panes size] ifNil: [0].	self basicUpdatePanes.	self basicUpdateSizing.		self layoutPanes.	panes size = count		ifFalse: [self hideOrShowScrollBar.				self setScrollDeltas].	panes size > count ifTrue: [self scrollToRight].	^ panes! !!OBPaneScroller methodsFor: 'updating' stamp: 'cwp 11/23/2004 01:14'!updateSizing	| old |	old := sizing.	self basicUpdateSizing.	sizing = old ifFalse: [self layoutPanes].	^sizing! !!OBPaneScroller class methodsFor: 'as yet unclassified' stamp: 'cwp 11/17/2004 22:01'!withModel: aModel	^ self new model: aModel! !TestCase subclass: #OBPaneScrollerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!(OBPaneScrollerTest instVarNames includes: 'paneCount') ifFalse:	[OBPaneScrollerTest addInstVarName: 'paneCount']!(OBPaneScrollerTest instVarNames includes: 'scroller') ifFalse:	[OBPaneScrollerTest addInstVarName: 'scroller']!!OBPaneScrollerTest methodsFor: 'actions' stamp: 'cwp 3/25/2007 00:30'!buildOn: aBuilder	^ RectangleMorph new		bounds: (10@10 corner: 20@20);		yourself! !!OBPaneScrollerTest methodsFor: 'callbacks' stamp: 'cwp 3/25/2007 00:31'!columns	^ ((1 to: paneCount) collect: [:i | self]) asOrderedCollection! !!OBPaneScrollerTest methodsFor: 'actions' stamp: 'cwp 11/2/2004 00:00'!createPane	^ RectangleMorph new		bounds: (10@10 corner: 20@20);		yourself! !!OBPaneScrollerTest methodsFor: 'actions' stamp: 'cwp 11/21/2004 22:40'!createScroller	scroller := OBPaneScroller withModel: self.	scroller bounds: (10 @ 420 extent: 600 @ 160)! !!OBPaneScrollerTest methodsFor: 'callbacks' stamp: 'cwp 11/21/2004 12:55'!panes	^ ((1 to: paneCount) collect: [:i | self createPane]) asOrderedCollection! !!OBPaneScrollerTest methodsFor: 'callbacks' stamp: 'cwp 11/23/2004 01:37'!reclaimPanes	^ scroller panes size - 4! !!OBPaneScrollerTest methodsFor: 'callbacks' stamp: 'cwp 11/17/2004 23:39'!sizing	^ 4! !!OBPaneScrollerTest methodsFor: 'tests' stamp: 'cwp 11/21/2004 22:40'!testPaneHeightNoScrollBar	paneCount := 4.	self createScroller.	self assert: scroller paneHeight = 160! !!OBPaneScrollerTest methodsFor: 'tests' stamp: 'cwp 11/21/2004 22:40'!testPaneHeightWithScrollBar	paneCount := 5.	self createScroller.	self assert: scroller paneHeight = 147! !!OBPaneScrollerTest methodsFor: 'tests' stamp: 'cwp 5/31/2007 21:10'!testPaneReclamation	paneCount := 6.	self createScroller.	scroller submorphs first setValue: 0.2.	paneCount := 4.	scroller update: #columns.	self assert: scroller panes size = 4! !!OBPaneScrollerTest methodsFor: 'tests' stamp: 'cwp 11/21/2004 23:11'!testResizeUpdatesPaneHeight	paneCount := 4.	self createScroller.	self assert: scroller panes first height = 160.	scroller bounds: (scroller bounds outsetBy: 1).	self assert: scroller panes first height = 162! !!OBPaneScrollerTest methodsFor: 'tests' stamp: 'cwp 11/21/2004 23:09'!testResizeUpdatesPaneWidth	paneCount := 4.	self createScroller.	self assert: scroller panes first width = 147.	scroller bounds: (scroller bounds outsetBy: 2).	self assert: scroller panes first width = 148! !Object subclass: #OBPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Panels'!!OBPanel commentStamp: 'cwp 1/7/2005 23:23' prior: 0!A panel is an object that manages part of the browser's window. It provides a protocol for receiving notifications when the current domain node changes, and reacts to these changes.!(OBPanel instVarNames includes: 'browser') ifFalse:	[OBPanel addInstVarName: 'browser']!!OBPanel methodsFor: 'updating'!announce: aClass 	^ self browser announce: aClass! !!OBPanel methodsFor: 'accessing'!announcer	^ browser announcer! !!OBPanel methodsFor: 'accessing'!browser	^ browser! !!OBPanel methodsFor: 'accessing'!browser: aBrowser	browser _ aBrowser.	self subscribe! !!OBPanel methodsFor: 'testing'!isNavigation	^ false! !!OBPanel methodsFor: 'updating'!subscribe! !!OBPanel class methodsFor: 'instance creation'!inBrowser: aBrowser	^ self new browser: aBrowser! !Object subclass: #OBPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!(OBPlatform classVarNames includes: 'Current') ifFalse:	[OBPlatform addClassVarName: 'Current']!!OBPlatform class methodsFor: 'preferences'!addPreference: aSymbol categories: anArray default: aBoolean balloonHelp: aString 	^ self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!annotationPanes	^self subclassResponsibility! !!OBPlatform class methodsFor: 'menu icons'!blankMenuIcon	^self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!chasingBrowsers	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!classNamed: className	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!classNames	^self subclassResponsibility! !!OBPlatform class methodsFor: 'as yet unclassified'!current	^ Current ifNil: [self default]! !!OBPlatform class methodsFor: 'as yet unclassified'!current: aPlatform	Current _ aPlatform! !!OBPlatform class methodsFor: 'as yet unclassified'!default	| classes |	classes _ self subclasses.	^ classes isEmpty		ifTrue: [self error: 'No platform available']		ifFalse: [classes anyOne default]! !!OBPlatform class methodsFor: 'preferences'!defaultAnnotationRequests	^self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!enableGently: attribute	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!hasClassNamed: aSymbol	^self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!lexiconWindowColor	^ self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!menuWithIcons	^self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!mercuryPanel	^ self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!messageListWindowColor	^ self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!optionalButtons	^self subclassResponsibility! !!OBPlatform class methodsFor: 'preferences'!setPreference: attribute toValue: value	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!smalltalkAssociationAt: aSymbol	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!smalltalkAt: aSymbol	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!smalltalkAt: aGlobalName ifAbsent: aBlock 	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!smalltalkAt: aGlobalName ifPresent: aBlock 	^self subclassResponsibility! !!OBPlatform class methodsFor: 'smalltalk'!smalltalkEnvironment	^self subclassResponsibility! !!OBPlatform class methodsFor: 'menu icons'!tryIcons: anArray	^self subclassResponsibility! !TestCase subclass: #OBPluggableCommandTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBPluggableCommandTest methodsFor: 'emulating' stamp: 'cwp 7/9/2006 12:52'!height	^ 16! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:39'!test01ExecuteEvaluatesAction	| called factory command |	called _ false.	factory _ OBPluggableCommand action: [called _ true].	command _ factory on: nil for: nil.	command execute.	self assert: called.! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:39'!test02ActionCanBeAMessageSend	| called factory send command |	called _ false.	send _ MessageSend receiver: [called _ true] selector: #value.	factory _ OBPluggableCommand action: send.	command _ factory on: nil for: nil.	command execute.	self assert: called.! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:40'!test03ActionReceivesRequestor	| factory requestor command |	requestor _ nil.	factory _ OBPluggableCommand action: [:arg1 :arg2 | requestor _ arg2].	command _ factory on: nil for: self.	command execute.	self assert: requestor == self.! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:40'!test03ActionRecievesNode	| factory node command |	node _ nil.	factory _ OBPluggableCommand action: [:arg1 :arg2 | node _ arg1].	command _ factory on: self for: nil.	command execute.	self assert: node == self.! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:40'!test04ConditionExecutesByDefault	| factory command |	factory _ OBPluggableCommand action: [].	command _ factory on: nil for: nil.	self assert: command isActive	! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:40'!test06MenuItemExecutesAction	| menu factory called command |	called _ false.	menu _ MenuMorph new.	factory _ OBPluggableCommand action: [called _ true].	command _ factory on: nil for: nil.	command addItemToMenu: menu.	menu items first doButtonAction.	self assert: called! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:40'!test07MenuItemEnabledByDefault	| menu factory command |	menu _ MenuMorph new.	factory _ OBPluggableCommand new.	command _ factory on: nil for: nil.	command addItemToMenu: menu.	self assert: menu items first isEnabled! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:41'!test08MenuItemReflectsCondition		| factory command |	factory _ OBPluggableCommand new enabled: [false].	command _ factory on: nil for: self.	self deny: (command isEnabled).	! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:41'!test09MenuReflectsLabel	| menu factory command |	menu _ MenuMorph new.	factory _ OBPluggableCommand new label: 'a fine factory'.	command _ factory on: nil for: self.	command addItemToMenu: menu.	self assert: menu items first contents = 'a fine factory'! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:41'!test10MenuDisplaysKeystroke	| menu factory command |	menu _ MenuMorph new.	factory _ OBPluggableCommand new 				label: 'a fine factory';				keystroke: $f.	command _ factory on: nil for: self.	command addItemToMenu: menu.	self assert: menu items first contents = 'a fine factory (f)'! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 7/1/2007 17:15'!test11MenuDisplaysIcon	| menu factory pref command |	pref _ OBPlatform current menuWithIcons.	[OBPlatform current enableGently: #menuWithIcons.	menu _ MenuMorph new.	factory _ OBPluggableCommand new 				label: 'a fine factory';				icon: #deleteIcon.	command _ factory on: nil for: self.	command addItemToMenu: menu.	self assert: menu lastItem icon notNil]		ensure: [OBPlatform current setPreference: #menuWithIcons toValue: pref]! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:42'!test13CommandIsMenuOnlyByDefault	| factory |	factory := OBPluggableCommand new.	self deny: factory wantsButton! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:42'!test14CommandWithButtonLabelWantsButton	| factory |	factory := OBPluggableCommand new.	factory buttonLabel: 'serv'.	self assert: factory wantsButton! !!OBPluggableCommandTest methodsFor: 'tests' stamp: 'cwp 11/2/2006 00:42'!test15CondReceivesRequestor	| factory requestor command |	requestor _ nil.	factory _ OBPluggableCommand action: [] active: [:n :r | requestor _ r].	command _ factory on: factory for: self.	command isActive.	self assert: requestor == self! !!OBPluggableCommandTest methodsFor: 'emulating' stamp: 'cwp 7/9/2006 12:52'!width	^ 16! !PluggableListMorph subclass: #OBPluggableListMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBPluggableListMorph commentStamp: 'dr 7/18/2007 14:27' prior: 0!I am a special kind of PluggableListMorph and provides methods to access icons for list elements. I use OBLazyListMorph as listMorphClass!!OBPluggableListMorph methodsFor: 'model access' stamp: 'cwp 7/24/2007 00:12'!iconAt: index	^ model iconAt: index! !!OBPluggableListMorph methodsFor: 'list management' stamp: 'dr 4/24/2007 16:39'!listMorphClass    ^OBLazyListMorph! !!OBPluggableListMorph methodsFor: 'as yet unclassified' stamp: 'cwp 7/5/2007 23:31'!mouseUp: event	"Override a change in PLM that breaks OmniBrowser. This version of the method	is from Squeak 3.7 and was originally stamped: 'ls 6/22/2001 22:49'"	| row |	row _ self rowAtLocation: event position.	"aMorph ifNotNil: [aMorph highlightForMouseDown: false]."	model okToChange ifFalse:		[^ self].	(autoDeselect == false and: [row == 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])		ifTrue: [self changeModelSelection: 0]		ifFalse: [self changeModelSelection: row].	Cursor normal show.! !PluggableTextMorph subclass: #OBPluggableTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBPluggableTextMorph commentStamp: 'cwp 12/7/2004 00:04' prior: 0!This is a trivial subclass of PluggableTextMorph. It overrides initialization methods to use an OBTextMorph rather than a regular TextMorph!!OBPluggableTextMorph methodsFor: 'menu' stamp: 'cwp 10/13/2006 20:05'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	aMenu _ model menu: menu shifted: shiftKeyState selection: self selectionNode.	aTitle ifNotNil:  [aMenu addTitle: aTitle].	^ aMenu! !!OBPluggableTextMorph methodsFor: 'event handling' stamp: 'cwp 10/30/2004 23:07'!keyStroke: evt	^ textMorph keyStroke: evt! !!OBPluggableTextMorph methodsFor: 'access' stamp: 'cwp 10/14/2006 21:30'!selectionNode	^ OBTextSelection on: self selectionInterval inText: self text. ! !!OBPluggableTextMorph methodsFor: 'model access' stamp: 'cwp 10/30/2004 22:57'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ OBTextMorph new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !RectangleMorph subclass: #OBRadioButtonBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBRadioButtonBar commentStamp: 'cwp 1/7/2005 23:27' prior: 0!An OBRadioButtonBar is similar to a PluggableListMorph except that it displays a row of buttons rather than a vertical list. Clicking on a button selects it.model				- the model for this button barbuttons			- a collection of OBButtonModels, which are derived from the model's listselection			- the index of the currently selected buttongetListSelector	 	- the message for getting the list of labels for the buttonsgetSelectionSelector	- the message for getting the index of the currently selected itemsetSelectionSelector	- the message for informing the model that a button has been clicked!(OBRadioButtonBar instVarNames includes: 'model') ifFalse:	[OBRadioButtonBar addInstVarName: 'model']!(OBRadioButtonBar instVarNames includes: 'buttons') ifFalse:	[OBRadioButtonBar addInstVarName: 'buttons']!(OBRadioButtonBar instVarNames includes: 'getListSelector') ifFalse:	[OBRadioButtonBar addInstVarName: 'getListSelector']!(OBRadioButtonBar instVarNames includes: 'selection') ifFalse:	[OBRadioButtonBar addInstVarName: 'selection']!(OBRadioButtonBar instVarNames includes: 'getSelectionSelector') ifFalse:	[OBRadioButtonBar addInstVarName: 'getSelectionSelector']!(OBRadioButtonBar instVarNames includes: 'setSelectionSelector') ifFalse:	[OBRadioButtonBar addInstVarName: 'setSelectionSelector']!!OBRadioButtonBar methodsFor: 'constructing' stamp: 'cwp 5/18/2007 22:12'!adoptPaneColor: aColor	color _ aColor.	self updateSubmorphColor! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 2/24/2004 18:53'!getSelectionIndex	^ model perform: getSelectionSelector! !!OBRadioButtonBar methodsFor: 'initialize-release' stamp: 'cwp 7/21/2007 22:33'!initGeometry	self		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		hResizing: #spaceFill;		vResizing: #spaceFill;		rubberBandCells: true;		styleWith: OBMorphBuilder new! !!OBRadioButtonBar methodsFor: 'callbacks' stamp: 'dr 7/19/2007 15:17'!isEnabled: aButton	^model isEnabled: aButton! !!OBRadioButtonBar methodsFor: 'callbacks' stamp: 'cwp 2/24/2004 18:54'!isSelected: aButton	^ (buttons at: selection ifAbsent: [^ false]) == aButton! !!OBRadioButtonBar methodsFor: 'accessing' stamp: 'cwp 11/27/2004 02:09'!list	buttons ifNil: 			[| labels |			labels := model perform: getListSelector.			buttons := Array new: labels size.			labels withIndexDo: 					[:label :index | 					buttons at: index put: (OBButtonModel withLabel: label inBar: self)].			selection := self getSelectionIndex.			self].	^buttons collect: [:b | b label]! !!OBRadioButtonBar methodsFor: 'accessing' stamp: 'cwp 3/11/2007 15:33'!model: aModel	model ifNotNil: [model removeDependent: self].	model _ aModel.	model addDependent: self.! !!OBRadioButtonBar methodsFor: 'constructing' stamp: 'cwp 11/27/2004 21:02'!noteNewOwner: aMorph	| window |	window := aMorph containingWindow.	window ifNotNil: [self adoptPaneColor: window paneColor]! !!OBRadioButtonBar methodsFor: 'initialize-release' stamp: 'cwp 2/25/2004 00:36'!on: aModel list: listSelector selected: selectionGetter changeSelected: selectionSetter 	self model: aModel.	selection _ 0.	getListSelector _ listSelector.	getSelectionSelector _ selectionGetter.	setSelectionSelector _ selectionSetter.	self initGeometry.	self updateList.! !!OBRadioButtonBar methodsFor: 'callbacks' stamp: 'cwp 2/24/2004 18:47'!push: aButton	| index |	index _ buttons indexOf: aButton.	model perform: setSelectionSelector with: index.! !!OBRadioButtonBar methodsFor: 'constructing' stamp: 'cwp 7/21/2007 21:54'!styleWith: aBuilder	aBuilder styleButtonBar: self! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 2/25/2004 00:35'!update: aSymbol	aSymbol = getListSelector ifTrue: [self updateList. ^ self].	aSymbol = getSelectionSelector ifTrue: [self updateSelection]! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 11/27/2004 17:58'!updateButtons	| labels |	labels := model perform: getListSelector.	buttons := Array new: labels size.	labels withIndexDo: 			[:label :index | 			buttons at: index put: (OBButtonModel withLabel: label inBar: self)].	selection := self getSelectionIndex! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 11/27/2004 17:58'!updateList	self 		updateButtons; 		updateMorphs! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 5/18/2007 22:16'!updateMorphs	self removeAllMorphs.	buttons do: [:button | self addMorphBack: (OBMorphBuilder build: button)].	self updateSubmorphColor ! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 2/24/2004 19:39'!updateSelection	| oldSelection |	oldSelection _ selection.	selection _ self getSelectionIndex.	self withButtonAt: oldSelection do: [:button | button selectionChanged].	self withSelectedButtonDo: [:button | button selectionChanged]! !!OBRadioButtonBar methodsFor: 'constructing' stamp: 'cwp 5/18/2007 22:17'!updateSubmorphColor	self submorphs do: [:ea | ea onColor: color darker offColor: color lighter]! !!OBRadioButtonBar methodsFor: 'constructing' stamp: 'cwp 5/18/2007 22:12'!updateSubmorphs	self submorphs do: [:ea | ea onColor: color darker offColor: color lighter]! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 7/9/2007 23:39'!withButtonAt: index do: aBlock	^ aBlock value: (buttons at: index ifAbsent: [^ self]) ! !!OBRadioButtonBar methodsFor: 'updating' stamp: 'cwp 2/24/2004 19:38'!withSelectedButtonDo: aBlock	^ self withButtonAt: selection do: aBlock! !!OBRadioButtonBar class methodsFor: 'as yet unclassified' stamp: 'cwp 2/22/2004 16:44'!on: aModel list: listSelector selected: selectionSelector changeSelected: changedSelector 	^ self new			on: aModel			list: listSelector			selected: selectionSelector			changeSelected: changedSelector! !TestCase subclass: #OBRescueFilterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBRescueFilterTest instVarNames includes: 'children') ifFalse:	[OBRescueFilterTest addInstVarName: 'children']!(OBRescueFilterTest instVarNames includes: 'filter') ifFalse:	[OBRescueFilterTest addInstVarName: 'filter']!!OBRescueFilterTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/17/2007 01:07'!nodes: aCollection	| nodes |	nodes _ aCollection collect: [:ea | OBFakeNode parent: nil item: ea].	^ filter nodesFrom: nodes forNode: self! !!OBRescueFilterTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/17/2007 02:19'!testDisplayStrings	| label |	filter := OBRescueFilter new.	self nodes: #(a b c).	self nodes: #(a c).	label := filter displayString: 'b' forParent: self child: (OBFakeNode parent: nil item: #b).	self assert: label isText.	self assert: ((label attributesAt: 1) anySatisfy: [:ea | ea = TextEmphasis struckOut])! !!OBRescueFilterTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/17/2007 01:08'!testRescue	| first second |	filter := OBRescueFilter new.	first := self nodes: #(a b c).	second := self nodes: #(a c).	self assert: first asSet = second asSet! !!OBRescueFilterTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/17/2007 01:40'!testSecondRescue	| second third |	filter := OBRescueFilter new.	self nodes: #(a b c).	second := self nodes: #(a c).	third := self nodes: #(a c).	self assert: second asSet = third asSet.! !!OBRescueFilterTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/17/2007 02:19'!testUnrescue	| third first |	filter := OBRescueFilter new.	first := self nodes: #(a b c).	self nodes: #(a c).	third := self nodes: #(a b c).	self assert: first = third.! !Slider subclass: #OBScrollBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBScrollBar commentStamp: 'cwp 3/5/2004 12:01' prior: 0!This class is a relic. It was originally created to work around bugs in ScrollBar which prevented it from working correctly in horizontal orientation. At some point the bugs should be fixed, and ScrollBar should be used instead.!(OBScrollBar instVarNames includes: 'upButton') ifFalse:	[OBScrollBar addInstVarName: 'upButton']!(OBScrollBar instVarNames includes: 'nextPageDirection') ifFalse:	[OBScrollBar addInstVarName: 'nextPageDirection']!(OBScrollBar instVarNames includes: 'currentScrollDelay') ifFalse:	[OBScrollBar addInstVarName: 'currentScrollDelay']!(OBScrollBar instVarNames includes: 'downButton') ifFalse:	[OBScrollBar addInstVarName: 'downButton']!(OBScrollBar instVarNames includes: 'pagingArea') ifFalse:	[OBScrollBar addInstVarName: 'pagingArea']!(OBScrollBar instVarNames includes: 'scrollDelta') ifFalse:	[OBScrollBar addInstVarName: 'scrollDelta']!(OBScrollBar instVarNames includes: 'pageDelta') ifFalse:	[OBScrollBar addInstVarName: 'pageDelta']!(OBScrollBar instVarNames includes: 'interval') ifFalse:	[OBScrollBar addInstVarName: 'interval']!(OBScrollBar instVarNames includes: 'menuSelector') ifFalse:	[OBScrollBar addInstVarName: 'menuSelector']!(OBScrollBar instVarNames includes: 'timeOfMouseDown') ifFalse:	[OBScrollBar addInstVarName: 'timeOfMouseDown']!(OBScrollBar instVarNames includes: 'timeOfLastScroll') ifFalse:	[OBScrollBar addInstVarName: 'timeOfLastScroll']!(OBScrollBar classVarNames includes: 'CachedImages') ifFalse:	[OBScrollBar addClassVarName: 'CachedImages']!(OBScrollBar classVarNames includes: 'UpArrow') ifFalse:	[OBScrollBar addClassVarName: 'UpArrow']!(OBScrollBar classVarNames includes: 'UpArrow8Bit') ifFalse:	[OBScrollBar addClassVarName: 'UpArrow8Bit']!!OBScrollBar methodsFor: 'accessing' stamp: 'md 2/24/2006 16:12'!adoptPaneColor: aColor	"Adopt the given pane color"	aColor ifNil:[^self].	self sliderColor: aColor.! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:06'!buttonExtent	^ bounds isWide		ifTrue: [11 @ self innerBounds height]		ifFalse: [self innerBounds width @ 11]! !!OBScrollBar methodsFor: 'accessing' stamp: 'cwp 11/23/2003 18:06'!cachedImageAt: aKey ifAbsentPut: aBlock	CachedImages ifNil: [CachedImages _ Dictionary new].	^CachedImages at: aKey ifAbsentPut: aBlock! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!doScrollByPage	"Scroll automatically while mouse is down"	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!doScrollDown	"Scroll automatically while mouse is down"	(self waitForDelay1: 200 delay2: 40) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!doScrollUp	"Scroll automatically while mouse is down"	(self waitForDelay1: 200 delay2: 40) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:06'!expandSlider	"Compute the new size of the slider (use the old sliderThickness as a minimum)."	| r |	r _ self totalSliderArea.	slider extent: (bounds isWide		ifTrue: [((r width * interval) asInteger max: self sliderThickness) @ slider height]		ifFalse: [slider width @ ((r height * interval) asInteger max: self sliderThickness)])! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:06'!extent: p        p x > p y                ifTrue: [super extent: (p max: 42@8)]                ifFalse: [super extent: (p max: 8@42)]! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!finishedScrolling	self stopStepping.	self scrollBarAction: nil.	self roundedScrollbarLook ifTrue:[		upButton borderStyle: (BorderStyle complexRaised width: upButton borderWidth).		downButton borderStyle: (BorderStyle complexRaised width: downButton borderWidth).	] ifFalse:[		downButton borderRaised.		upButton borderRaised.	].! !!OBScrollBar methodsFor: 'initialization' stamp: 'cwp 11/23/2003 18:07'!initialize	super initialize.	scrollDelta _ 0.02.	pageDelta _ 0.2.	self roundedScrollbarLook ifTrue:[		self borderStyle: ((BorderStyle complexFramed width: 2) "baseColor: Color gray")].! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: self thumbColor.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseUp send: #finishedScrolling to: self.	downButton addMorphCentered: (ImageMorph new image: 		(self 			cachedImageAt: (bounds isWide ifTrue: ['right'] ifFalse: ['down']) 			ifAbsentPut: [				self upArrow8Bit					rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi])					centerAt: 0@0			]		)	).	self roundedScrollbarLook ifTrue:[		downButton color: Color veryLightGray.		downButton borderStyle: (BorderStyle complexRaised width: 3).	] ifFalse:[		downButton setBorderWidth: 1 borderColor: #raised.	].	self addMorph: downButton.! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!initializeEmbedded: aBool	"aBool == true => inboard scrollbar	aBool == false => flop-out scrollbar"	self roundedScrollbarLook ifFalse:[^self].	aBool ifTrue:[		self borderStyle: (BorderStyle inset width: 2).		self cornerStyle: #square.	] ifFalse:[		self borderStyle: (BorderStyle width: 1 color: Color black).		self cornerStyle: #rounded.	].	self removeAllMorphs.	self initializeSlider.! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #scrollPageInit: to: self.	pagingArea on: #mouseUp send: #finishedScrolling to: self.	self addMorph: pagingArea.	self roundedScrollbarLook 		ifTrue:[pagingArea color: (Color gray: 0.9)].! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!initializeSlider	self roundedScrollbarLook ifTrue:[		self 			initializeUpButton;			initializeDownButton;			initializePagingArea.	] ifFalse:[		self initializeUpButton; 			initializeDownButton; 			initializePagingArea.	].	super initializeSlider.	self roundedScrollbarLook ifTrue:[		slider cornerStyle: #rounded.		slider borderStyle: (BorderStyle complexRaised width: 3).		sliderShadow cornerStyle: #rounded.	].	self sliderColor: self sliderColor.! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!initializeUpButton	upButton := self roundedScrollbarLook 				ifTrue:  					[RectangleMorph 						newBounds: (self innerBounds topLeft extent: self buttonExtent)]				ifFalse: 					[RectangleMorph 						newBounds: ((self innerBounds topLeft) extent: self buttonExtent)].	upButton color: self thumbColor.	upButton 		on: #mouseDown		send: #scrollUpInit		to: self.	upButton 		on: #mouseUp		send: #finishedScrolling		to: self.	upButton 		addMorphCentered: (ImageMorph new image: (self 						cachedImageAt: (bounds isWide ifTrue: ['left'] ifFalse: ['up'])						ifAbsentPut: 							[bounds isWide 								ifTrue: [self upArrow8Bit rotateBy: #left centerAt: 0 @ 0]								ifFalse: [self upArrow8Bit]])).	self roundedScrollbarLook 		ifTrue: 			[upButton color: Color veryLightGray.			upButton borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [upButton setBorderWidth: 1 borderColor: #raised].	self addMorph: upButton! !!OBScrollBar methodsFor: 'access' stamp: 'cwp 11/23/2003 18:06'!interval: d	"Supply an optional floating fraction so slider can expand to indicate range"	interval _ d min: 1.0.	self expandSlider.	self computeSlider.! !!OBScrollBar methodsFor: 'other events' stamp: 'cwp 11/23/2003 18:06'!menuButtonMouseDown: event	event hand showTemporaryCursor: nil.	self use: menuSelector orMakeModelSelectorFor: 'MenuButtonPressed:'		in: [:sel | menuSelector _ sel.  model perform: sel with: event]! !!OBScrollBar methodsFor: 'other events' stamp: 'cwp 11/23/2003 18:06'!mouseDownInSlider: event	interval = 1.0 ifTrue:		["make the entire scrollable area visible if a full scrollbar is clicked on"		self setValue: 0.		self model hideOrShowScrollBar].	super mouseDownInSlider: event! !!OBScrollBar methodsFor: 'access' stamp: 'cwp 11/23/2003 18:06'!pagingArea	^pagingArea! !!OBScrollBar methodsFor: 'scroll timing' stamp: 'cwp 11/23/2003 18:07'!resetTimer	timeOfMouseDown _ Time millisecondClockValue.	timeOfLastScroll _ timeOfMouseDown - 1000 max: 0.	nextPageDirection _ nil.	currentScrollDelay _ nil! !!OBScrollBar methodsFor: 'access' stamp: 'md 2/24/2006 21:25'!roundedScrollbarLook	"Rounded look currently only shows up in flop-out mode"	^false and: [self class alwaysShowFlatScrollbarForAlternativeLook not]! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollBarAction	^self valueOfProperty: #scrollBarAction! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollBarAction: aSymbol	self setProperty: #scrollBarAction toValue: aSymbol! !!OBScrollBar methodsFor: 'access' stamp: 'cwp 11/23/2003 18:06'!scrollDelta	^ scrollDelta! !!OBScrollBar methodsFor: 'access' stamp: 'cwp 11/23/2003 18:06'!scrollDelta: d1 pageDelta: d2	"Supply optional increments for better scrolling of, eg, text"	scrollDelta _ d1.	pageDelta _ d2.! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollDown	self flag: #obsolete.	downButton eventHandler: nil.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseUp send: #finishedScrolling to: self.	^self scrollDownInit! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollDown: count	self setValue: (value + (scrollDelta * count) + 0.000001 min: 1.0)! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollDownInit	downButton borderInset.	self resetTimer.	self scrollBarAction: #doScrollDown.	self startStepping.! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollPageInit: evt	self resetTimer.	self setNextDirectionFromEvent: evt.	self scrollBarAction: #doScrollByPage.	self startStepping.! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollUp	self flag: #obsolete.	upButton eventHandler: nil.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseUp send: #finishedScrolling to: self.	^self scrollUpInit! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollUp: count	self setValue: (value - (scrollDelta * count) - 0.000001 max: 0.0)! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!scrollUpInit	upButton borderInset.	self resetTimer.	self scrollBarAction: #doScrollUp.	self startStepping.! !!OBScrollBar methodsFor: 'scrolling' stamp: 'cwp 11/23/2003 18:06'!setNextDirectionFromEvent: event	nextPageDirection _ bounds isWide ifTrue: [		event cursorPoint x >= slider center x	]	ifFalse: [		event cursorPoint y >= slider center y	]! !!OBScrollBar methodsFor: 'model access' stamp: 'cwp 11/23/2003 18:06'!setValue: newValue	"Using roundTo: instead of truncateTo: ensures that scrollUp will scroll the same distance as scrollDown."	^ super setValue: (newValue roundTo: scrollDelta)! !!OBScrollBar methodsFor: 'access' stamp: 'md 2/24/2006 16:26'!sliderColor: aColor	"Change the color of the scrollbar to go with aColor."	| buttonColor |	super sliderColor: aColor.	buttonColor _ self thumbColor.	upButton color: buttonColor.	downButton color: buttonColor.	slider color: buttonColor.	self roundedScrollbarLook			ifTrue:				[self color: Color transparent.				pagingArea color: aColor muchLighter.				self borderStyle style == #simple 					ifTrue:[self borderColor: aColor darker darker]					ifFalse:[self borderStyle baseColor: aColor]]			ifFalse:				[pagingArea color: (aColor alphaMixed: 0.3 with: Color white).				self borderWidth: 0]! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:06'!sliderExtent	"The sliderExtent is now stored in the slider itself, not hardcoded as it is in the superclass."	^slider extent! !!OBScrollBar methodsFor: 'access' stamp: 'cwp 11/23/2003 18:06'!sliderShadowColor	^ self roundedScrollbarLook		ifTrue: [self sliderColor darker]		ifFalse: [super sliderShadowColor]! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:07'!sliderThickness	^ self roundedScrollbarLook ifTrue:[15] ifFalse:[super sliderThickness]! !!OBScrollBar methodsFor: 'stepping and presenter' stamp: 'cwp 11/23/2003 18:07'!step	| action |	action _ self scrollBarAction.	action ifNotNil:[self perform: action].! !!OBScrollBar methodsFor: 'testing' stamp: 'cwp 11/23/2003 18:06'!stepTime	^ currentScrollDelay ifNil: [300]! !!OBScrollBar methodsFor: 'access' stamp: 'md 2/24/2006 16:27'!thumbColor	"Problem: Part of the ScrollBar/Slider code uses 'slider' to mean the entire scrollbar/slider widget, and part of it uses 'slider' to mean only the draggable 'thumb'.  This should be cleaned up so that 'thumb' is used instead of 'slider' where appropriate.  For now, the meaning of thumbColor is clear, at least."	^self sliderColor alphaMixed: 0.7 with: (Color gray: 0.95).! !!OBScrollBar methodsFor: 'geometry' stamp: 'cwp 11/23/2003 18:07'!totalSliderArea	| upperBoundsButton |	upperBoundsButton _ upButton.	upButton bottom > upperBoundsButton bottom		ifTrue: [upperBoundsButton _ upButton].	^ bounds isWide		ifTrue: [upperBoundsButton bounds topRight corner: downButton bounds bottomLeft]		ifFalse: [upperBoundsButton bounds bottomLeft corner: downButton bounds topRight].! !!OBScrollBar methodsFor: 'initialize' stamp: 'cwp 11/23/2003 18:06'!upArrow8Bit	"convert to 8-bit and convert white to transparent to avoid gratuitous conversion every time we put one in an ImageMorph"	^UpArrow8Bit ifNil: [		UpArrow8Bit _ (ColorForm mappingWhiteToTransparentFrom: UpArrow) asFormOfDepth: 8	]! !!OBScrollBar methodsFor: 'scroll timing' stamp: 'cwp 11/23/2003 18:07'!waitForDelay1: delay1 delay2: delay2 	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll isNil ifTrue: [self resetTimer].	"Only needed for old instances"	now := Time millisecondClockValue.	(scrollDelay := currentScrollDelay) isNil 		ifTrue: [scrollDelay := delay1	"initial delay"].	currentScrollDelay := scrollDelay * 9 // 10 max: delay2.	"decrease the delay"	timeOfLastScroll := now.	^true! !!OBScrollBar methodsFor: 'testing' stamp: 'cwp 11/23/2003 18:06'!wantsSteps	^self scrollBarAction notNil! !!OBScrollBar class methodsFor: 'as yet unclassified' stamp: 'cwp 11/23/2003 18:07'!alwaysShowFlatScrollbarForAlternativeLook	"Set this value to true, if you want to see the flat scrollbar look in flop-out mode as well as inboard.  Otherwise the flop-out scrollbar will be rounded and inboard will be flat."	^ false! !!OBScrollBar class methodsFor: 'class initialization' stamp: 'cwp 11/23/2003 18:07'!initialize "ScrollBar initialize"	UpArrow _ Form		extent: 6@3		fromArray: #(2r11e28 2r1111e27 2r111111e26)		offset: 0@0.! !Object subclass: #OBSubtree	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Kernel'!(OBSubtree instVarNames includes: 'state') ifFalse:	[OBSubtree addInstVarName: 'state']!!OBSubtree methodsFor: 'as yet unclassified'!childOf: current ancestorOf: leaf indexOn: stream 	| fan |	fan := current asFan.	stream nextPut: fan.	^fan ancestorOf: leaf in: [:index | stream nextPut: index]! !!OBSubtree methodsFor: 'as yet unclassified'!initializeWithRoot: root leaf: leaf 	| current |	state := Array streamContents: 		[:stream | 		current := self childOf: root ancestorOf: leaf indexOn: stream.		[current isNil or: [current = leaf]] whileFalse:			[current := self childOf: current ancestorOf: leaf indexOn: stream].		current ifNotNil: 			[current metaNode hasChildren ifTrue: 				[stream nextPut: current asFan; nextPut: 0]]].	^ current ifNotNil: [self]	! !!OBSubtree methodsFor: 'as yet unclassified'!selectInColumns: aCollection	| column stream |	column _ aCollection first.	stream _ state readStream.	[stream atEnd] whileFalse:		[column fan: stream next selection: stream next.		column _ column next].	! !!OBSubtree methodsFor: 'as yet unclassified'!state	^ state! !!OBSubtree class methodsFor: 'as yet unclassified'!from: root to: leaf	^ self new initializeWithRoot: root leaf: leaf! !TestCase subclass: #OBSubtreeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 23:18'!test2Generations	| root leaf state |	root _ OBFakeNode parent: nil item: ''.	root metaNode: OBFakeNode metagraph.	leaf _ OBFakeNode parent: root item: #b.	state _ (OBSubtree from: root to: leaf) state.		self assert: state first parent = root.	self assert: state second = 2.	self assert: state third parent = leaf.	self assert: state fourth = 0! !!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 22:19'!test3Generations	| root twig leaf state |	root _ OBFakeNode parent: nil item: ''.	root metaNode: OBFakeNode metagraph.	twig _ OBFakeNode parent: root item: #a.	leaf _ OBFakeNode parent: twig item: #b.	state _ (OBSubtree from: root to: leaf) state.		self assert: state first parent = root.	self assert: state second = 1.	self assert: state third parent = twig.	self assert: state fourth = 2.	self assert: state fifth parent = leaf.	self assert: state sixth = 0! !!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 22:22'!test4Generations	| root twig leaf state branch |	root _ OBFakeNode parent: nil item: ''.	root metaNode: OBFakeNode metagraph.	branch _ OBFakeNode parent: root item: #a.	twig _ OBFakeNode parent: branch item: #b.	leaf _ OBFakeNode parent: twig item: #c.		state _ (OBSubtree from: root to: leaf) state.		self assert: state first parent = root.	self assert: state second = 1.	self assert: state third parent = branch.	self assert: state fourth = 2.	self assert: state fifth parent = twig.	self assert: state sixth = 3.	self assert: state seventh parent = leaf.	self assert: state eighth = 0! !!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 13:39'!testChildOfMatchingRoot	| root leaf subtree state |	root _ OBFake2Node tree: #(b (a b c)).	leaf _ OBFake2Node tree: #b.	root metaNode: OBFake2Node metagraph.	subtree _ OBSubtree from: root to: leaf.	state _ subtree instVarNamed: 'state'.		self assert: state size = 4.	self assert: state first parent = root.	self assert: state second = 2.	self assert: state third parent = leaf.	self assert: state fourth = 0.! !!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 13:39'!testChildOfRoot	| root leaf subtree state |	root _ OBFake2Node tree: #(b (a b c)).	leaf _ OBFake2Node tree: #b.	root metaNode: OBFake2Node metagraph.	subtree _ OBSubtree from: root to: leaf.	state _ subtree instVarNamed: 'state'.		self assert: state size = 4.	self assert: state first parent = root.	self assert: state second = 2.	self assert: state third parent = leaf.	self assert: state fourth = 0.! !!OBSubtreeTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/19/2007 23:49'!testNoAncestor	| root leaf subtree |	root _ OBFakeNode parent: nil item: ''.	root metaNode: OBFakeNode metagraph.	leaf _ OBFakeNode parent: root item: #x.	subtree _ OBSubtree from: root to: leaf.	self assert: subtree isNil.	! !Object subclass: #OBSwitch	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Utilities'!(OBSwitch instVarNames includes: 'column') ifFalse:	[OBSwitch addInstVarName: 'column']!(OBSwitch instVarNames includes: 'filter') ifFalse:	[OBSwitch addInstVarName: 'filter']!!OBSwitch methodsFor: 'as yet unclassified'!buildOn: aBuilder 	^aBuilder radioButtonBar: self with: []! !!OBSwitch methodsFor: 'updating'!currentNode: aNode	self changed: #list! !!OBSwitch methodsFor: 'accessing'!filter	^ filter! !!OBSwitch methodsFor: 'as yet unclassified'!filter: aFilter	filter _ aFilter.	filter ifNotNil:		[filter activate.		self changed: #list]! !!OBSwitch methodsFor: 'as yet unclassified'!isActive	^ filter notNil! !!OBSwitch methodsFor: 'testing'!isEnabled: aButtonModel    ^true! !!OBSwitch methodsFor: 'as yet unclassified'!list	^ filter 		ifNotNil: [filter listForNode: column selectedNode]		ifNil: [#()]! !!OBSwitch methodsFor: 'as yet unclassified'!refresh	self changed: #selection! !!OBSwitch methodsFor: 'as yet unclassified'!selection	^ filter 		ifNotNil: [filter selection]		ifNil: [0]! !!OBSwitch methodsFor: 'as yet unclassified'!selection: anInteger	filter ifNotNil: 		[filter selection: anInteger.		self changed: #selection.		column listChanged]! !!OBSwitch methodsFor: 'as yet unclassified'!setColumn: aColumn filter: aFilter	column _ aColumn.	filter _ aFilter.! !!OBSwitch class methodsFor: 'instance creation'!inColumn: aColumn 	^ self basicNew setColumn: aColumn filter: nil.! !TestCase subclass: #OBSwitchTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBSwitchTest instVarNames includes: 'selection') ifFalse:	[OBSwitchTest addInstVarName: 'selection']!!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 22:22'!activate	selection _ 1! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 7/14/2007 10:46'!list	^ #(a b c d e)! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 5/18/2007 00:25'!listChanged	! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 7/14/2007 10:45'!listForNode: aNode	^ self list! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 7/14/2007 10:45'!selectedNode	^ OBFakeNode new! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 21:59'!selection	^ selection! !!OBSwitchTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 22:15'!selection: anInteger	selection _ anInteger! !!OBSwitchTest methodsFor: 'support' stamp: 'cwp 7/14/2007 10:44'!switch	^ OBSwitch inColumn: self! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 5/17/2007 22:23'!testGetSelection	| switch |	switch _ OBSwitch new.	switch filter: self.	selection _ 2.	self assert: switch selection = 2! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 7/14/2007 10:44'!testList	| switch |	switch := self switch.	switch filter: self.	self assert: switch list = self list! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 5/17/2007 22:22'!testSendsActivateToFilter	| switch |	switch _ OBSwitch new.		selection _ 3.	switch filter: self.	self assert: selection = 1.! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 5/18/2007 00:24'!testSetSelection	| switch |	switch _ OBSwitch inColumn: self.	switch filter: self.	switch selection: 5.	self assert: selection = 5! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 5/17/2007 21:43'!testSwitchIsActiveWhenItHasAFilter	| switch |	switch _ OBSwitch new.	switch filter: self.	self assert: switch isActive! !!OBSwitchTest methodsFor: 'tests' stamp: 'cwp 5/17/2007 21:36'!testSwitchStartsInactive	| switch |	switch _ OBSwitch new.	self deny: switch isActive! !TextMorphForEditView subclass: #OBTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBTextMorph commentStamp: 'cwp 12/7/2004 00:07' prior: 0!This is a trivial subclass of TextMorph. It overrides editor creation to use OBTextMorphEditor rather than a regular TextMorphEditor.!!OBTextMorph methodsFor: 'private' stamp: 'cwp 10/30/2004 23:06'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ OBTextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!OBTextMorph methodsFor: 'private' stamp: 'dr 3/3/2008 16:38'!keyStroke: anEvent		(anEvent anyModifierKeyPressed or: [editView model isEditable])		ifTrue: [super keyStroke: anEvent]! !TextMorphEditor subclass: #OBTextMorphEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBTextMorphEditor commentStamp: 'cwp 1/7/2005 23:27' prior: 0!OBTextMorphEditor overrides the TextMorphEditors handling of command keys, passing them along to its model for processing, rather than hard-coding their implementations.!!OBTextMorphEditor methodsFor: 'actions' stamp: 'cwp 10/31/2004 01:52'!browseIt	| symbol |	self lineSelectAndEmptyCheck: [^ self].	(symbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self send: #browseIt: toModelWith: {symbol} orDo: [super browseIt]! !!OBTextMorphEditor methodsFor: 'actions' stamp: 'cwp 10/31/2004 00:40'!implementorsOfIt	"Open a senders browser on the selected selector"	| selector |	self lineSelectAndEmptyCheck: [^ self].	(selector _ self selectedSelector) == nil ifTrue: [^ view flash].	self send: #implementorsOfIt: toModelWith: {selector} orDo: [super sendersOfIt]! !!OBTextMorphEditor methodsFor: 'actions' stamp: 'cwp 10/31/2004 01:10'!referencesToIt	| selector |	self lineSelectAndEmptyCheck: [^ self].	(selector _ self selectedSelector) == nil ifTrue: [^ view flash].	self send: #referencesToIt: toModelWith: {selector} orDo: [super referencesToIt]! !!OBTextMorphEditor methodsFor: 'model access' stamp: 'cwp 10/31/2004 00:24'!send: aSelector toModelWith: args orDo: aBlock	self terminateAndInitializeAround:		[(model respondsTo: aSelector)			ifTrue: [(model perform: aSelector withArguments: args)						ifFalse: [view flash]]			ifFalse: aBlock]! !!OBTextMorphEditor methodsFor: 'actions' stamp: 'cwp 10/31/2004 00:26'!sendersOfIt	"Open a senders browser on the selected selector"	| selector |	self lineSelectAndEmptyCheck: [^ self].	(selector _ self selectedSelector) == nil ifTrue: [^ view flash].	self send: #sendersOfIt: toModelWith: {selector} orDo: [super sendersOfIt]! !Object subclass: #OBTextSelection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Utilities'!(OBTextSelection instVarNames includes: 'selection') ifFalse:	[OBTextSelection addInstVarName: 'selection']!(OBTextSelection instVarNames includes: 'text') ifFalse:	[OBTextSelection addInstVarName: 'text']!!OBTextSelection methodsFor: 'as yet unclassified'!fullText	^ text! !!OBTextSelection methodsFor: 'as yet unclassified'!hasSelector	^ self selector notNil! !!OBTextSelection methodsFor: 'as yet unclassified'!selector	^ self text asString findSelector! !!OBTextSelection methodsFor: 'as yet unclassified'!setSelection: anInterval inText: aString	selection _ anInterval.	text _ aString.! !!OBTextSelection methodsFor: 'as yet unclassified'!text	^ text atAll: selection! !!OBTextSelection class methodsFor: 'instance creation'!on: anOBPluggableTextMorph 	^ self new! !!OBTextSelection class methodsFor: 'instance creation'!on: anInterval inText: aString	^ self new setSelection: anInterval inText: aString! !!OBTextSelection class methodsFor: 'instance creation'!onAllOf: aString 	^ self on: (1 to: aString size) inText: aString! !TestCase subclass: #OBTextSelectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBTextSelectionTest methodsFor: 'tests' stamp: 'cwp 10/14/2006 20:17'!test01Text	| selection |	selection _ OBTextSelection on: (3 to: 5) inText: 'abcdefghijk'.	self assert: selection text = 'cde'.! !!OBTextSelectionTest methodsFor: 'tests' stamp: 'cwp 10/14/2006 20:17'!test02FullText	| selection |	selection _ OBTextSelection on: (3 to: 5) inText: 'abcdefghijk'.	self assert: selection fullText = 'abcdefghijk'.! !!OBTextSelectionTest methodsFor: 'tests' stamp: 'cwp 10/14/2006 20:26'!test03Selector	| selection text |	text _ 'self foo: #a bar: #b.  '.	selection _ OBTextSelection 					on: (1 to: text size) 					inText: text.	self assert: selection selector = #foo:bar:! !!Text methodsFor: '*omnibrowser-morphic'!colorAt: characterIndex    | textColor |     textColor _ (self attributesAt: characterIndex) detect: [:att | att isMemberOf: TextColor] ifNone: [TextColor black].    ^textColor color! !!Behavior methodsFor: '*omnibrowser-converting'!asAnnouncement	^ self new! !!MenuMorph methodsFor: '*ob-morphic' stamp: 'cwp 6/8/2007 20:45'!add: label target: anObject selector: aSelector enabled: aBoolean icon: aSymbol	self add: label target: anObject selector: aSelector.	self lastItem isEnabled: aBoolean.	Preferences menuWithIcons		ifTrue: [self lastItem icon: (self iconNamed: aSymbol)]! !!MenuMorph methodsFor: '*ob-morphic' stamp: 'cwp 9/30/2007 18:34'!addSubmenu: aString enabled: aBoolean	"Append the given submenu with the given label."	| item submenu |	item _ MenuItemMorph new.	submenu _ MenuMorph new.	item 		contents: aString;		isEnabled: aBoolean;		subMenu: submenu.	self addMorphBack: item.	^ submenu! !!MenuMorph methodsFor: '*ob-morphic' stamp: 'cwp 6/8/2007 20:41'!iconNamed: aSymbol	| sel |	aSymbol ifNil: [^ MenuIcons blankIcon].	sel _ (MenuIcons respondsTo: aSymbol)			ifTrue: [aSymbol]			ifFalse: [('small', aSymbol capitalized) asSymbol].	^ MenuIcons perform: sel! !!BorderedSubpaneDividerMorph methodsFor: '*ob-morphic' stamp: 'cwp 7/23/2007 02:09'!styleWith: aBuilder	self vResizing = #spaceFill 		ifTrue: [aBuilder styleVerticalDivider: self]		ifFalse: [aBuilder styleHorizontalDivider: self]! !!MessageSend methodsFor: '*omnibrowser-evaluating'!valueWithPossibleArgs: anArray	^ receiver 		perform: selector 		withArguments: (self collectArguments: anArray)! !!MenuIcons class methodsFor: '*omnibrowser-services'!tryIcons: anArray	| selector |	selector := anArray detect: [:ea | self respondsTo: ea] ifNone: [self blankIcon].	^ MenuIcons perform: selector! !!Object methodsFor: '*omnibrowser-converting'!asAnnouncement	^ self! !!PluggableButtonMorph methodsFor: '*ob-tests-core' stamp: 'cwp 2/24/2004 19:07'!isOn	^ self color = onColor! !!PluggableButtonMorph methodsFor: '*ob-morphic' stamp: 'cwp 7/21/2007 21:18'!styleWith: aBuilder	aBuilder styleButton: self! !!LazyListMorph methodsFor: '*ob-tests-core' stamp: 'cwp 2/28/2006 18:47'!rectForRow: index	"return a rectangle containing the row at index"		| top |	top _ self top + (index - 1 * font height).	^ (self left @ top) extent: self width @ font height! !!PluggableListMorph methodsFor: '*ob-tests-core' stamp: 'cwp 3/14/2004 13:09'!getListDelicately	| lazy |	lazy _ self listMorph.	^ (1 to: lazy getListSize) collect: [:i | lazy item: i].	! !!PluggableListMorph methodsFor: '*ob-tests-core' stamp: 'cwp 3/14/2004 13:47'!getListObtrusively	| lazy |	lazy _ self listMorph.	^ (1 to: lazy getListSize) collect: [:i | lazy getListItem: i].	! !OBAnnouncement subclass: #OBAboutToChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBAboutToChange instVarNames includes: 'veto') ifFalse:	[OBAboutToChange addInstVarName: 'veto']!!OBAboutToChange methodsFor: 'vetos'!isVetoed	^ veto notNil! !!OBAboutToChange methodsFor: 'vetos'!veto	veto _ true! !OBAnnouncement subclass: #OBAboutToChangeSilently	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBAboutToChangeSilently instVarNames includes: 'veto') ifFalse:	[OBAboutToChangeSilently addInstVarName: 'veto']!!OBAboutToChangeSilently methodsFor: 'vetos'!isVetoed	^ veto notNil! !!OBAboutToChangeSilently methodsFor: 'vetos'!veto	veto _ true! !OBInteractionRequest subclass: #OBBrowseRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!!OBBrowseRequest commentStamp: 'cwp 12/7/2004 00:10' prior: 0!This notification is raised whenever a browser needs to be opened. The default action is to open a SystemWindow in Morphic, but it can be caught in situations where that's not appropriate. The OB test suite uses this extensively. !(OBBrowseRequest instVarNames includes: 'browser') ifFalse:	[OBBrowseRequest addInstVarName: 'browser']!!OBBrowseRequest methodsFor: 'accessing'!browser	^ browser! !!OBBrowseRequest methodsFor: 'accessing'!browser: aBrowser	browser _ aBrowser! !!OBBrowseRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleBrowseRequest: self! !!OBBrowseRequest methodsFor: 'testing'!isBrowseRequest	^ true! !!OBBrowseRequest class methodsFor: 'exceptionInstantiator'!signal: aBrowser	^ (self new browser: aBrowser) signal! !OBBarMorphTest subclass: #OBButtonBarTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!(OBButtonBarTest instVarNames includes: 'received') ifFalse:	[OBButtonBarTest addInstVarName: 'received']!!OBButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 3/11/2007 16:52'!cmd1	received _ #cmd1! !!OBButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 3/11/2007 17:30'!cmd3	received = #cmd3! !!OBButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 3/11/2007 21:03'!color	^ Color red! !!OBButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 5/2/2007 23:07'!commands	^ 	{(OBPluggableCommand action: [self cmd1])			buttonLabel: 'Command 1'.		(OBPluggableCommand action: [self cmd3])			buttonLabel: 'Command 3'.		(OBPluggableCommand action: [self cmd4])			buttonLabel: 'Command 4';			active: [false]}! !!OBButtonBarTest methodsFor: 'running' stamp: 'cwp 3/11/2007 17:02'!openBarInWorld	bar openInWorld.	self changed: #commands.	bar bounds: (100@100 corner: 400@140).! !!OBButtonBarTest methodsFor: 'running' stamp: 'cwp 3/11/2007 15:56'!setUp	bar _ OBButtonBar on: self.				! !!OBButtonBarTest methodsFor: 'testing' stamp: 'cwp 3/11/2007 17:02'!testLayout	| rects |		"This is an ugly hack. I can't figure out how else to force a layout."	self openBarInWorld.	bar delete.	rects _ bar submorphs collect: [:b | b bounds].	self assert: rects first left = bar left.	self assert: rects first right = rects second left.	self assert: rects second right = rects third left.	self assert: rects third right = bar right.! !!OBButtonBarTest methodsFor: 'testing' stamp: 'cwp 3/11/2007 16:53'!testPush1	self push: 'Command 1'.	self assert: received = #cmd1! !!OBButtonBarTest methodsFor: 'testing' stamp: 'cwp 3/11/2007 17:06'!testPush4	self push: 'Command 4'.	self assert: received isNil! !!OBButtonBarTest class methodsFor: 'as yet unclassified' stamp: 'cwp 3/11/2007 17:03'!openBar	self new setUp; openBarInWorld! !OBAnnouncement subclass: #OBChildrenChanged	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBChildrenChanged instVarNames includes: 'node') ifFalse:	[OBChildrenChanged addInstVarName: 'node']!!OBChildrenChanged methodsFor: 'as yet unclassified'!node	^ node! !!OBChildrenChanged methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBChildrenChanged class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBInteractionRequest subclass: #OBChoiceRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!!OBChoiceRequest commentStamp: 'cwp 3/5/2004 12:26' prior: 0!This notification is used to ask the user for to choose from a list of alternatives. Its defaultAction is to open a PopUpMenu. Test cases an intercept the notification and respond programmatically.prompt	- A string describing the choice the user is asked to make.labels	- A list of strings describing the alternatives.values	- When the user chooses an alternative, the corresponding item from this list is returned!(OBChoiceRequest instVarNames includes: 'prompt') ifFalse:	[OBChoiceRequest addInstVarName: 'prompt']!(OBChoiceRequest instVarNames includes: 'labels') ifFalse:	[OBChoiceRequest addInstVarName: 'labels']!(OBChoiceRequest instVarNames includes: 'values') ifFalse:	[OBChoiceRequest addInstVarName: 'values']!(OBChoiceRequest instVarNames includes: 'lines') ifFalse:	[OBChoiceRequest addInstVarName: 'lines']!!OBChoiceRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleChoiceRequest: self! !!OBChoiceRequest methodsFor: 'accessing'!labels	^ labels! !!OBChoiceRequest methodsFor: 'accessing'!lines	^ lines! !!OBChoiceRequest methodsFor: 'accessing'!prompt	^ prompt! !!OBChoiceRequest methodsFor: 'signaling'!select: aString	| index |	index _ labels indexOf: aString.	self resume: (values at: index ifAbsent: [nil])! !!OBChoiceRequest methodsFor: 'initializing'!setPrompt: aString labels: labelArray values: valueArray lines: lineArray	prompt _ aString.	labels _ labelArray.	values _ valueArray.	lines _ lineArray.! !!OBChoiceRequest methodsFor: 'accessing'!values	^ values! !!OBChoiceRequest class methodsFor: 'exceptionInstantiator'!labels: anArray	^ self		prompt: nil		labels: anArray		values: anArray		lines: #()! !!OBChoiceRequest class methodsFor: 'exceptionInstantiator'!labels: labelArray lines: lineArray	^ self		prompt: nil		labels: labelArray		values: labelArray		lines: lineArray! !!OBChoiceRequest class methodsFor: 'exceptionInstantiator'!prompt: aString labels: labelArray values: valueArray	^ self		prompt: aString		labels: labelArray		 values: valueArray		lines: #()! !!OBChoiceRequest class methodsFor: 'exceptionInstantiator'!prompt: aString labels: labelArray values: valueArray lines: lineArray	^ (self new 		setPrompt: aString 		labels: labelArray 		values: valueArray 		lines: lineArray) 			signal! !OBInteractionRequest subclass: #OBCloseRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!(OBCloseRequest instVarNames includes: 'browser') ifFalse:	[OBCloseRequest addInstVarName: 'browser']!!OBCloseRequest methodsFor: 'accessing'!browser	^ browser! !!OBCloseRequest methodsFor: 'accessing'!browser: aBrowser	browser _ aBrowser! !!OBCloseRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleCloseRequest: self! !!OBCloseRequest class methodsFor: 'exceptionInstantiator'!signal: aBrowser	^ (self new browser: aBrowser) signal! !OBNode subclass: #OBCollectionNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Nodes'!!OBCollectionNode commentStamp: 'cwp 1/7/2005 23:31' prior: 0!OBCollectionNode is a trivial wrapper for a collection of nodes. It is typically used as an artificial root node for metagraphs that have no natural root.!(OBCollectionNode instVarNames includes: 'name') ifFalse:	[OBCollectionNode addInstVarName: 'name']!(OBCollectionNode instVarNames includes: 'collection') ifFalse:	[OBCollectionNode addInstVarName: 'collection']!!OBCollectionNode methodsFor: 'navigating'!addChild: aNode	(collection includes: aNode)		ifFalse: [collection _ collection copyWith: aNode]! !!OBCollectionNode methodsFor: 'navigating'!children	^ collection! !!OBCollectionNode methodsFor: 'ancestry'!isAncestorOf: aNode	^ collection anySatisfy: [:ea | ea = aNode or: [ea isAncestorOf: aNode]]! !!OBCollectionNode methodsFor: 'displaying'!name	^ name ifNil: [collection species name]! !!OBCollectionNode methodsFor: 'displaying'!name: aString	name _ aString! !!OBCollectionNode methodsFor: 'navigating'!removeChild: aNode	(collection includes: aNode)		ifTrue: [collection _ collection copyWithout: aNode]! !!OBCollectionNode methodsFor: 'initalizing'!setCollection: aCollection	collection _ aCollection! !!OBCollectionNode class methodsFor: 'as yet unclassified'!on: aCollection	^ self new setCollection: aCollection! !!OBCollectionNode class methodsFor: 'as yet unclassified'!on: aCollection named: aString	^ (self on: aCollection)		name: aString;		yourself! !OBPanel subclass: #OBColumnPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Panels'!!OBColumnPanel commentStamp: 'cwp 12/6/2004 23:50' prior: 0!OBColumnPanel handles navigation around the nodes of the object graph. It maintains a list of columns, which track the user's path through the node tree. As nodes are selected, additional columns are added to the list, which appear as panes on the right of the panel. iVars:columns	- A collection of OBColumns, each of which manages a single pane in the scroller.minPanes - The minimum number of panes that should ever be visible.maxPanes - The maximum number of panes that should ever be visible.!(OBColumnPanel instVarNames includes: 'root') ifFalse:	[OBColumnPanel addInstVarName: 'root']!(OBColumnPanel instVarNames includes: 'current') ifFalse:	[OBColumnPanel addInstVarName: 'current']!(OBColumnPanel instVarNames includes: 'columns') ifFalse:	[OBColumnPanel addInstVarName: 'columns']!(OBColumnPanel instVarNames includes: 'minPanes') ifFalse:	[OBColumnPanel addInstVarName: 'minPanes']!(OBColumnPanel instVarNames includes: 'maxPanes') ifFalse:	[OBColumnPanel addInstVarName: 'maxPanes']!!OBColumnPanel methodsFor: 'building'!buildOn: aBuilder 	^aBuilder scroller: self with: [columns do: [:ea | ea buildOn: aBuilder]]! !!OBColumnPanel methodsFor: 'accessing columns'!clearAfter: aColumn 	| start |	aColumn ifNotNil:		[start _ (columns indexOf: aColumn) + 1.		start to: columns size do: [:i | (columns at: i) clear]]! !!OBColumnPanel methodsFor: 'accessing columns'!columnAfter: aColumn 	^ [self columns after: aColumn]		on: Error		do: [:err | nil]! !!OBColumnPanel methodsFor: 'accessing columns'!columnBefore: aColumn 	^ self columnBefore: aColumn ifAbsent: [nil]! !!OBColumnPanel methodsFor: 'accessing columns'!columnBefore: aColumn ifAbsent: aBlock	^ [self columns before: aColumn]		on: Error		do: [:err | aBlock value]! !!OBColumnPanel methodsFor: 'accessing'!columns	^columns! !!OBColumnPanel methodsFor: 'accessing'!columns: anObject	columns := anObject! !!OBColumnPanel methodsFor: 'accessing columns'!currentColumn	^self columns reversed detect: [:ea | ea hasSelection] ifNone: []! !!OBColumnPanel methodsFor: 'accessing'!currentNode	^ current! !!OBColumnPanel methodsFor: 'accessing'!currentOrRootNode	^ current ifNil: [root]! !!OBColumnPanel methodsFor: 'callbacks'!defaultBackgroundColor	^ browser defaultBackgroundColor! !!OBColumnPanel methodsFor: 'accessing columns'!emptyColumn	^ OBColumn inPanel: self! !!OBColumnPanel methodsFor: 'accessing'!hasSelection	^ false! !!OBColumnPanel methodsFor: 'navigating'!hopTo: aNode 	| column |	column := self columns last.	[column refreshAndSignal: false; includesNode: aNode]		whileFalse: [column := self 						columnBefore: column 						ifAbsent: [^ self jumpTo: aNode]].	column select: aNode! !!OBColumnPanel methodsFor: 'testing'!isNavigation	^ true! !!OBColumnPanel methodsFor: 'constructing'!isVariableHeight	^ true! !!OBColumnPanel methodsFor: 'navigating'!jumpTo: aNode 	| column |	self selectAncestorsOf: aNode.	column _ self columns reversed 				detect: [:ea | ea selectedNode = aNode] 				ifNone: [^ self].	self clearAfter: column next.	self announcer announce: (OBSelectionChanged column: column)! !!OBColumnPanel methodsFor: 'navigating'!jumpToRoot	^ self columns first selection: 0! !!OBColumnPanel methodsFor: 'accessing'!labelString	| label |	self columns reversed do: 		[:ea | 		label := ea selectedNode ifNotNilDo: [:node | node title].		label ifNotNil: [^ label]].	^ nil! !!OBColumnPanel methodsFor: 'accessing'!maxPanes	^maxPanes! !!OBColumnPanel methodsFor: 'accessing'!minPanes	^ minPanes! !!OBColumnPanel methodsFor: 'updating'!nodeDeleted: ann	ann node = self root ifTrue: 		[current _ nil.		self columns first clear.		self announcer announce: (OBSelectionChanged column: self)].		! !!OBColumnPanel methodsFor: 'updating'!okToReclaimPane	columns size > minPanes ifFalse: [^ false].	^ columns last isEmpty or: [(columns at: columns size - 1) shouldBeLast].! !!OBColumnPanel methodsFor: 'accessing columns'!popColumn	self announcer unsubscribe: self columns removeLast.! !!OBColumnPanel methodsFor: 'accessing columns'!pushColumn: aColumn 	self columns addLast: aColumn.	self changed: #columns.! !!OBColumnPanel methodsFor: 'updating'!reclaimPanes	| old |	old := columns size.	[self okToReclaimPane] whileTrue: [self popColumn].	columns size = old ifFalse: [self changed: #columns]! !!OBColumnPanel methodsFor: 'navigating'!root	^ root! !!OBColumnPanel methodsFor: 'navigating'!selectAncestorsOf: aNode 	| subtree |	subtree := OBSubtree from: root to: aNode.	subtree ifNotNil: [self selectSubtree: subtree]! !!OBColumnPanel methodsFor: 'updating'!selectNode: announcement	^ self hopTo: announcement node! !!OBColumnPanel methodsFor: 'navigating'!selectSubtree: aSubtree	aSubtree selectInColumns: columns! !!OBColumnPanel methodsFor: 'accessing columns'!selected: aColumn 	aColumn next ifNotNilDo: 		[:next | 		next parent: aColumn selectedNode].! !!OBColumnPanel methodsFor: 'accessing'!selectedNode	^ self currentNode! !!OBColumnPanel methodsFor: 'updating'!selectionChanged: ann	current _ ann column selectedNode.	self selectionChangedIn: ann column! !!OBColumnPanel methodsFor: 'updating'!selectionChangedIn: aColumn	aColumn hasSelection		ifTrue: [self selected: aColumn]		ifFalse: [self clearAfter: aColumn].	self reclaimPanes.! !!OBColumnPanel methodsFor: 'accessing'!selectionPath	^(self columns 		collect: [:e | e parent] 		thenSelect: [:e | e notNil]) allButFirst! !!OBColumnPanel methodsFor: 'initializing'!setMetaNode: aMetaNode node: aNode 	root _ aNode.	root metaNode: aMetaNode.	self pushColumn: (OBColumn inPanel: self metaNode: aMetaNode node: root).	minPanes - self columns size 		timesRepeat: [self pushColumn: self emptyColumn]! !!OBColumnPanel methodsFor: 'initializing'!setMinPanes: min maxPanes: max	columns _ OrderedCollection new.	minPanes _ min.	maxPanes _ max! !!OBColumnPanel methodsFor: 'callbacks'!sizing	^ (columns size max: minPanes) min: maxPanes! !!OBColumnPanel methodsFor: 'updating'!subscribe	self announcer		observe: OBSelectingNode send: #selectNode: to: self;		observe: OBSelectionChanged send: #selectionChanged: to: self;		observe: OBNodeCreated send: #selectNode: to: self;		observe: OBNodeDeleted send: #nodeDeleted: to: self.! !!OBColumnPanel methodsFor: 'building'!vResizing	^ #spaceFill! !!OBColumnPanel class methodsFor: 'instance creation'!minPanes: min maxPanes: max	^ self basicNew setMinPanes: min maxPanes: max! !!OBColumnPanel class methodsFor: 'instance creation'!new	^ self minPanes: 1 maxPanes: 1! !OBAnnouncement subclass: #OBCommandScan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBCommandScan instVarNames includes: 'factories') ifFalse:	[OBCommandScan addInstVarName: 'factories']!!OBCommandScan methodsFor: 'accessing'!addCommandsOn: aNode for: aRequestor to: aSet	| cmd |	factories do: 		[:ea | 		cmd _ ea on: aNode for: aRequestor.		cmd isActive ifTrue: [aSet add: cmd]]! !!OBCommandScan methodsFor: 'accessing'!addFactory: aCommandFactory 	factories add: aCommandFactory! !!OBCommandScan methodsFor: 'user interface'!clusterCommands: aCollection	| groups root name cluster |	groups _ IdentityDictionary new.	root _ OBCommandCluster new.	aCollection do:		[:command |		name _ command cluster.		cluster _ name 					ifNil: [root]					ifNotNil: 						[groups 							at: name							ifAbsentPut: [command createCluster]].		cluster addCommand: command].	groups values do: [:ea | root addCommand: ea].	^ root! !!OBCommandScan methodsFor: 'accessing'!commandsOn: aNode for: aRequestor	^ factories collect: [:ea | ea on: aNode for: aRequestor]! !!OBCommandScan methodsFor: 'user interface'!groupCommands: commands 	| groups |	groups := commands groupBy: [:svc | svc group]				having: [:group | group isEmpty not].	groups := groups 				collect: [:ea | ea asArray sort: [:a :b | a label <= b label]].	^groups asArray sort: [:a :b | a anyOne group <= b anyOne group]! !!OBCommandScan methodsFor: 'initialize-release'!initialize	factories _ OrderedCollection new! !!OBCommandScan methodsFor: 'user interface'!populateMenu: aMenu withNodes: aCollection forRequestor: aRequestor	| commands cluster |	commands _ IdentitySet new.	aCollection do: [:node | self addCommandsOn: node for: aRequestor to: commands].	cluster _ self clusterCommands: commands.	cluster populateMenu: aMenu! !!OBCommandScan methodsFor: 'user interface'!processKeystroke: aCharacter withNode: aNode for: aRequestor	| commands |	commands _ self commandsOn: aNode for: aRequestor. 	(commands select: [:cmd | cmd keystroke == aCharacter]) do:		[:cmd |		(cmd isActive and: [cmd isEnabled])			ifTrue: [cmd execute]]! !OBInteractionRequest subclass: #OBConfirmationRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!!OBConfirmationRequest commentStamp: 'cwp 3/5/2004 12:30' prior: 0!This notification is used to ask the user to confirm some kind potentially dangerous operation. Its default action is to open a PopUpMenu.iVars:prompt		- a string describing the situation the user is asked to confirmconfirm		- a string describing the action that will be taken if the user confirmscancel		- a string describing the action that will be taken if the user does not confirm!(OBConfirmationRequest instVarNames includes: 'prompt') ifFalse:	[OBConfirmationRequest addInstVarName: 'prompt']!(OBConfirmationRequest instVarNames includes: 'confirm') ifFalse:	[OBConfirmationRequest addInstVarName: 'confirm']!(OBConfirmationRequest instVarNames includes: 'cancel') ifFalse:	[OBConfirmationRequest addInstVarName: 'cancel']!!OBConfirmationRequest methodsFor: 'responding'!cancel	^ self resume: false! !!OBConfirmationRequest methodsFor: 'accessing'!cancelChoice	^ cancel! !!OBConfirmationRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleConfirmationRequest: self! !!OBConfirmationRequest methodsFor: 'responding'!ok	self resume: true! !!OBConfirmationRequest methodsFor: 'accessing'!okChoice	^ confirm! !!OBConfirmationRequest methodsFor: 'accessing'!prompt	^ prompt! !!OBConfirmationRequest methodsFor: 'initalizing'!setPrompt: promptString confirm: confirmString cancel: cancelString	prompt _ promptString.	confirm _ confirmString.	cancel _ cancelString! !!OBConfirmationRequest class methodsFor: 'exceptionInstantiator'!newPrompt: prompt confirm: confirm cancel: cancel	^ self new setPrompt: prompt confirm: confirm cancel: cancel! !!OBConfirmationRequest class methodsFor: 'exceptionInstantiator'!prompt: prompt	^ self prompt: prompt confirm: 'Ok'! !!OBConfirmationRequest class methodsFor: 'exceptionInstantiator'!prompt: prompt confirm: confirm	^ self prompt: prompt confirm: confirm cancel: 'Cancel'! !!OBConfirmationRequest class methodsFor: 'exceptionInstantiator'!prompt: prompt confirm: confirm cancel: cancel	^ (self newPrompt: prompt confirm: confirm cancel: cancel) signal! !OBAnnouncement subclass: #OBDefinitionChanged	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBDefinitionChanged instVarNames includes: 'definition') ifFalse:	[OBDefinitionChanged addInstVarName: 'definition']!(OBDefinitionChanged instVarNames includes: 'node') ifFalse:	[OBDefinitionChanged addInstVarName: 'node']!!OBDefinitionChanged methodsFor: 'as yet unclassified'!definition	^ definition! !!OBDefinitionChanged methodsFor: 'as yet unclassified'!definition: aDefinition	definition _ aDefinition! !!OBDefinitionChanged methodsFor: 'as yet unclassified'!node	^ node! !!OBDefinitionChanged methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBDefinitionChanged class methodsFor: 'as yet unclassified'!definition: aDefinition	^ self new		definition: aDefinition;		yourself! !!OBDefinitionChanged class methodsFor: 'as yet unclassified'!node: aNode definition: aDefinition	^ self new		node: aNode;		definition: aDefinition;		yourself! !OBNode subclass: #OBFake2Node	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBFake2Node instVarNames includes: 'name') ifFalse:	[OBFake2Node addInstVarName: 'name']!(OBFake2Node instVarNames includes: 'children') ifFalse:	[OBFake2Node addInstVarName: 'children']!!OBFake2Node methodsFor: 'comparing' stamp: 'cwp 5/8/2007 23:50'!= aNode	^ self name = aNode name! !!OBFake2Node methodsFor: 'accessing' stamp: 'cwp 5/8/2007 23:46'!children	^ children! !!OBFake2Node methodsFor: 'comparing' stamp: 'cwp 5/8/2007 23:50'!hash	^ name hash! !!OBFake2Node methodsFor: 'ancestry' stamp: 'cwp 5/14/2007 13:21'!isAncestorOf: aNode using: aSelector	^ self = aNode or: [children anySatisfy: [:ea | ea isAncestorOf: aNode]]! !!OBFake2Node methodsFor: 'public' stamp: 'cwp 5/8/2007 23:46'!name	^ name! !!OBFake2Node methodsFor: 'printing' stamp: 'cwp 5/8/2007 23:45'!printOn: aStream	aStream		nextPutAll: 'Fake2<';		nextPutAll: name;		nextPut: $>! !!OBFake2Node methodsFor: 'initialize-release' stamp: 'cwp 5/8/2007 23:37'!setName: aSymbol children: anArray	name _ aSymbol.	children _ anArray collect: [:ea | self class tree: ea]! !!OBFake2Node class methodsFor: 'running' stamp: 'cwp 5/8/2007 23:53'!metagraph	| root |	root _ OBMetaNode named: 'Fake2'.	root childAt: #children put: root.	^ root! !!OBFake2Node class methodsFor: 'as yet unclassified' stamp: 'cwp 5/8/2007 23:43'!tree: anObject	| children token |	anObject isSymbol 		ifTrue: [token _ anObject. children _ #()]		ifFalse: [token _ anObject first. children _ anObject second].	^ self basicNew 		setName: token		children: children! !OBBrowser subclass: #OBFakeBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBFakeBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 3/13/2007 00:18'!cmdBeZ	^ OBPluggableCommand new		label: 'become z';		active: [:node :col | col isSelected: node];		action: [:node :col | node beZ. node announceChangedWith: col];		yourself! !!OBFakeBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 3/13/2007 00:34'!cmdCreateZ	^ OBPluggableCommand new		label: 'create z';		action: [:node :col | node createZ announceSelectionWith: col];		active: [:node :col | (col isSelected: node) not];		yourself! !!OBFakeBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 3/13/2007 00:20'!cmdDelete	^ OBPluggableCommand new		label: 'delete';		action: [:node :col | node delete. node announceDeletionWith: col];		active: [:node :col | col isSelected: node];		yourself! !!OBFakeBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 3/13/2007 00:24'!cmdDeleteRoot	^ OBPluggableCommand new		label: 'delete root';		action: [:node :col | node root announceDeletionWith: col];		active: [:node :col | col isSelected: node];		yourself! !OBBrowserTest subclass: #OBFakeBrowserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBFakeBrowserTest methodsFor: 'constants' stamp: 'cwp 3/12/2007 23:51'!browserClass	^ OBFakeBrowser! !!OBFakeBrowserTest methodsFor: 'running' stamp: 'cwp 11/7/2004 21:27'!metagraph	^ OBFakeNode metagraph! !!OBFakeBrowserTest methodsFor: 'running' stamp: 'cwp 12/17/2003 15:12'!node	^ OBFakeNode new! !!OBFakeBrowserTest methodsFor: 'constants' stamp: 'cwp 12/5/2004 18:17'!paneCount	^ 4! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 3/14/2004 14:25'!testAcceptText	self select: #a.	self assertListAt: 1 contains: #(a b c).	self assertListAt: 2 contains: #(aa ab ac).	self assertTextIs: 'a'.	self setText: 'x'.		"This is a gratuitous refresh to make the test pass. It isn't necessary when the 	browser is actually open. It's a deficiency of the test environment..."	self listMorphs do: [:ea | ea update: #list].		self assertListAt: 1 contains: #(x b c).	self assertListAt: 2 contains: #(xa xb xc).	self assertTextIs: 'x'! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 1/7/2004 08:27'!testAction	self select: #a.	self selectMenuItem:  'become z'.	self assertListAt: 1 contains:  #(z b c)! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 2/28/2004 13:49'!testConfirmAbandon	self select: #a.	self assertListAt: 1 contains: #(a b c).	self assertListAt: 2 contains: #(aa ab ac).	self assertTextIs: 'a'.	self editText: 'x'.	[self select: #b]		on: OBConfirmationRequest		do: [:notification | notification cancel].	self assertCurrentItemIs: #a.	self assertTextIs: 'x'.! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 7/8/2007 21:06'!testConfirmClose	| notification |	self select: #a.	self assertListAt: 1 contains: #(#a #b #c).	self assertListAt: 2 contains: #(#aa #ab #ac).	self assertTextIs: 'a'.	self editText: 'x'.	[widget close] on: OBConfirmationRequest do: [:ex | notification := ex].	self deny: notification isNil! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 7/8/2007 23:01'!testCreateWindow	self assert: (widget isKindOf: OBFakeWindow).	self assert: widget label = 'OmniBrowser'! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 6/4/2006 12:18'!testDeleteB	self select: #b.	self selectMenuItem: 'delete'.	self assertListAt: 1 contains: #(a c).	self assert: self listMorphs size = self paneCount.	self assertTextIs: ''.! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 3/14/2004 17:20'!testDeleteRootNode	self select: #a.	self selectMenuItem: 'delete root'.	self denyAListIncludes: #(a b c).	self assertTextIs: ''! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 8/26/2004 02:17'!testDeselectA	self select: #a.	self deselect: #a.	self assertListAt: 1 contains: #(a b c).	self assert: self listMorphs size = self paneCount.	self assertTextIs: ''.! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 6/4/2006 13:30'!testDragAndDrop	| node |	self select: #a.	node _ self drag: #ab.	self assert: (node isKindOf: OBFakeNode).	self assert: node name = #ab.	self drop: node on: #c.	self assertListAt: 1 contains: #(a b c).	self assertCurrentItemIs: #c.	self assertTextIs: 'c'.	self assertListAt: 2 contains: #(cb).! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 8/26/2004 02:17'!testInitialDisplay	self assert: self listMorphs size = self paneCount.	self assertListAt: 1 contains: #(a b c).	self assertTextIs: ''.	! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 7/8/2007 22:05'!testPanes	| scroller |	self assert: (self morphsOfClass: OBFakeList) size = self paneCount.	self assert: (self morphsOfClass: OBFakeText) size = 1.	scroller := (self morphsOfClass: OBFakeScroller) anyOne.	self assert: scroller children size = model navigationPanel minPanes! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 7/8/2007 22:13'!testRefreshDirty	self select: #a.	self editText: 'x'.		[self selectMenuItem: 'create z']		on: OBConfirmationRequest		do: [:request | Transcript cr; show: 'cancelling'. request cancel].	model announcer announce: (OBRefreshRequired new).		self assertListAt: 1 contains: #(a b c z).	self assertCurrentItemIs: #a.	self assertTextIs: 'x'.! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 12/7/2003 19:30'!testSelectA	self select: #a.	self assertListAt: 1 contains: #(a b c).	self assertListAt: 2 contains: #(aa ab ac).	self assertTextIs: 'a'! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'cwp 12/7/2003 19:30'!testSelectC	self select: #c.	self assertListAt: 1 contains: #(a b c).	self assertListAt: 2 contains: #().	self assertTextIs: 'c'! !!OBFakeBrowserTest methodsFor: 'testing' stamp: 'dvf 9/5/2005 18:10'!testSelectionPath	self select: #a.	self select: #ab.	self assert: ((model selectionPath collect: [:e | e item]) = (OrderedCollection with: 'a' with: 'b'))! !OBBuilder subclass: #OBFakeBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!!OBFakeBuilder methodsFor: 'accessing' stamp: 'cwp 7/8/2007 00:56'!addChild: anObject	current _ anObject! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:55'!button: aModel with: aBlock 	^self current: (OBFakeButton model: aModel) do: aBlock! !!OBFakeBuilder methodsFor: 'accessing' stamp: 'cwp 7/8/2007 00:55'!current: aWidget do: aBlock	current addChild: aWidget.	^ super current: aWidget do: aBlock! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:52'!fixedButtonBar: aPanel with: aBlock 	! !!OBFakeBuilder methodsFor: 'initialize-release' stamp: 'cwp 7/8/2007 00:56'!initialize	current _ self! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:47'!pane: aColumn with: aBlock 	^self current: (OBFakePane model: aColumn)		do: 			[self current: (OBFakeList model: aColumn) do: [].			aBlock value]! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:53'!radioButtonBar: aSwitch with: aBlock 	^self current: (OBFakeRadioButtonBar model: aSwitch) do: aBlock! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:46'!scroller: aPanel with: aBlock 	^self current: (OBFakeScroller model: aPanel) do: aBlock! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:48'!textarea: aPanel with: aBlock 	^self current: (OBFakeText model: aPanel) do: aBlock! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:57'!textfield: aPanel with: aBlock 	^self current: (OBFakeText model: aPanel) do: aBlock! !!OBFakeBuilder methodsFor: 'building' stamp: 'lr 1/7/2008 11:20'!verticalGroupWith: aBlock 	^aBlock value! !!OBFakeBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 20:50'!window: aBrowser with: aBlock 	^self current: (OBFakeWindow model: aBrowser label: aBrowser defaultLabel)		do: aBlock! !OBBuilderTest subclass: #OBFakeBuilderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Tests'!!OBFakeBuilderTest methodsFor: 'support' stamp: 'cwp 7/8/2007 01:21'!builderClass	^ OBFakeBuilder! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:34'!test01BrowserCreatesWindow	| widget |	widget _ self buildWindow.	self assert: (widget isKindOf: OBFakeWindow).	self assert: (widget model == model).! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:22'!test02BrowserAddsPanels	| widget |	widget := self buildWindow.	self assert: widget children size = 2.	self assert: (widget children first isKindOf: OBFakeScroller).	self assert: (widget children second isKindOf: OBFakeText)! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:22'!test03ColumnPanelAddsColumns	| widget |	widget := self buildNavigationPanel.	self assert: widget children size = 4.	widget children do: [:ea | self assert: (ea isKindOf: OBFakePane)]! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:39'!test04ColumnAddsList	| pane |	pane := self build: self columnWithFilter.	self assert: (pane isKindOf: OBFakePane).	self assert: (pane children first isKindOf: OBFakeList)! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/9/2007 23:26'!test05ColumnAddsButton	| pane |	pane := self build: self columnWithFilter.	self assert: (pane isKindOf: OBFakePane).	self assert: (pane children second isKindOf: OBFakeRadioButtonBar)! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 01:22'!test07ButtonModelCanBeBuiltAlone	| widget |	widget _ self build: self button.	self assert: (widget isKindOf: OBFakeButton)! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/8/2007 23:20'!test09HasLabel	| widget |	widget _ self buildWindow.	self assert: (widget label = 'OmniBrowser')! !!OBFakeBuilderTest methodsFor: 'tests' stamp: 'cwp 7/9/2007 23:26'!tests08SwitchCanBeBuiltAlone	| widget |	widget := self build: self switch.	self assert: (widget isKindOf: OBFakeRadioButtonBar)! !OBFakeWidget subclass: #OBFakeButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeButton instVarNames includes: 'label') ifFalse:	[OBFakeButton addInstVarName: 'label']!(OBFakeButton instVarNames includes: 'bar') ifFalse:	[OBFakeButton addInstVarName: 'bar']!(OBFakeButton instVarNames includes: 'isOn') ifFalse:	[OBFakeButton addInstVarName: 'isOn']!!OBFakeButton methodsFor: 'simulating' stamp: 'cwp 7/9/2007 23:50'!click	bar select: self! !!OBFakeButton methodsFor: 'selection' stamp: 'cwp 7/10/2007 00:28'!deselect	isOn _ false! !!OBFakeButton methodsFor: 'examining' stamp: 'cwp 7/10/2007 00:30'!isOn	^ isOn! !!OBFakeButton methodsFor: 'examining' stamp: 'cwp 7/9/2007 23:48'!label	^ label! !!OBFakeButton methodsFor: 'printing' stamp: 'cwp 7/9/2007 23:55'!printDebugIdOn: aStream	aStream print: label! !!OBFakeButton methodsFor: 'selection' stamp: 'cwp 7/10/2007 00:28'!select	isOn _ true! !!OBFakeButton methodsFor: 'initalize-release' stamp: 'cwp 7/9/2007 23:47'!setLabel: aString bar: aButtonBar	label _ aString.	bar _ aButtonBar! !!OBFakeButton class methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:47'!label: aString bar: aButtonBar	^ self new setLabel: aString bar: aButtonBar! !OBBrowser subclass: #OBFakeCommandBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBFakeCommandBrowser instVarNames includes: 'action') ifFalse:	[OBFakeCommandBrowser addInstVarName: 'action']!!OBFakeCommandBrowser methodsFor: 'accessing' stamp: 'cwp 10/4/2006 09:59'!action	^ action! !!OBFakeCommandBrowser methodsFor: 'accessing' stamp: 'cwp 10/4/2006 09:59'!action: aBlock		action _ aBlock! !!OBFakeCommandBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 9/18/2007 22:25'!cmdObsolete	^ OBPluggableCommand action: action! !!OBFakeCommandBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 3/11/2007 19:04'!cmdPluggable	^ OBPluggableCommand action: action! !!OBFakeCommandBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 9/18/2007 22:27'!obsoleteCmd	^ #cmdObsolete! !!OBFakeCommandBrowser class methodsFor: 'defaults' stamp: 'cwp 10/4/2006 10:04'!defaultMetaNode	^ OBFakeNode metagraph! !!OBFakeCommandBrowser class methodsFor: 'defaults' stamp: 'cwp 10/4/2006 10:04'!defaultRootNode	^ OBFakeNode new! !!OBFakeCommandBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 3/11/2007 19:22'!withAction: aBlock	| browser |	browser _ self basicNew initialize.	browser action: aBlock.	self panels do: [:ea | browser addPanel: ea].	browser setMetaNode: self defaultMetaNode node: self defaultRootNode.	^ browser! !OBFakeWidget subclass: #OBFakeList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeList instVarNames includes: 'list') ifFalse:	[OBFakeList addInstVarName: 'list']!(OBFakeList instVarNames includes: 'selectionIndex') ifFalse:	[OBFakeList addInstVarName: 'selectionIndex']!!OBFakeList methodsFor: 'simulating' stamp: 'cwp 7/10/2007 00:17'!basicUpdate	self updateList.	self updateSelectionIndex! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/13/2007 21:21'!canDrop: aNode on: aString	^ model canDrop: aNode on: (model nodeForItem: aString) 	! !!OBFakeList methodsFor: 'simulating' stamp: 'cwp 7/8/2007 01:51'!changeModelSelection: anInteger	model selection: anInteger! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/13/2007 22:44'!drop: aNode on: aString	^ model drop: aNode on: (model nodeForItem: aString) 	! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/8/2007 01:41'!getListDelicately	^ list ifNil: [Array new]! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/10/2007 00:15'!getListObtrusively	^ list _ model list! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/8/2007 02:06'!getMenu: shiftKeyState	| menu |	menu _ OBFakeMenu new defaultTarget: model.	model menu: menu.	^ menu! !!OBFakeList methodsFor: 'examining' stamp: 'cwp 7/8/2007 02:00'!selection	selectionIndex = 0 ifTrue: [^ nil].	list ifNotNil: [^ list at: selectionIndex].	^ model listAt: selectionIndex! !!OBFakeList methodsFor: 'emulating' stamp: 'cwp 7/10/2007 00:17'!update: aSelector 	aSelector = #list ifTrue: [^ self updateList].	aSelector = #selection ifTrue: [^ self updateSelectionIndex]! !!OBFakeList methodsFor: 'private' stamp: 'cwp 7/10/2007 00:16'!updateList	list _ model list.	selectionIndex _ model selection.	! !!OBFakeList methodsFor: 'private' stamp: 'cwp 7/10/2007 00:16'!updateSelectionIndex	selectionIndex _ model selection! !OBNode subclass: #OBFakeNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!(OBFakeNode instVarNames includes: 'item') ifFalse:	[OBFakeNode addInstVarName: 'item']!(OBFakeNode instVarNames includes: 'parent') ifFalse:	[OBFakeNode addInstVarName: 'parent']!(OBFakeNode instVarNames includes: 'children') ifFalse:	[OBFakeNode addInstVarName: 'children']!!OBFakeNode methodsFor: 'comparing' stamp: 'cwp 5/8/2007 23:27'!= other	^ self name = other name! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 3/13/2007 00:33'!adopt: aNode	aNode parent removeChild: aNode.	aNode parent: self.	children _ self children copyWith: aNode.	^ aNode! !!OBFakeNode methodsFor: 'actions' stamp: 'cwp 3/13/2007 00:08'!beZ	item _ 'z'.	! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 7/17/2007 23:07'!childX	^ Array with: (OBFakeNode parent: self item: #x)! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 1/23/2004 21:42'!children	^ children 		ifNil: [children _ (self item endsWith: 'c')					ifTrue: [Array new]					ifFalse: [#($a $b $c) collect: [:i | OBFakeNode parent: self item: i asString]]]! !!OBFakeNode methodsFor: 'actions' stamp: 'cwp 3/13/2007 00:33'!createZ	^ self adopt: (OBFakeNode parent: self item: 'z')! !!OBFakeNode methodsFor: 'actions' stamp: 'cwp 3/13/2007 00:20'!delete	parent ifNotNil: [parent removeChild: self].	! !!OBFakeNode methodsFor: 'drag and drop' stamp: 'cwp 3/13/2007 00:43'!dropOnFakeNode: aNode	aNode adopt: self.	aNode signalSelection! !!OBFakeNode methodsFor: 'drag and drop' stamp: 'cwp 3/2/2004 21:40'!dropSelector	^ #dropOnFakeNode:! !!OBFakeNode methodsFor: 'comparing' stamp: 'cwp 5/8/2007 23:27'!hash	^ self name hash! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 5/14/2007 13:18'!isAncestorOf: aNode using: aSelector	| current |	current _ aNode.	[current isNil] whileFalse:		[current = self ifTrue: [^ true].		current _ current parent].	^ false! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 12/7/2003 19:18'!item	^ item ifNil: [item _ '']! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 12/7/2003 19:09'!item: aSymbol	item _ aSymbol! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 12/15/2003 22:05'!name	^ self parentName, self item ! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 7/17/2007 23:37'!noChildren	^ #()! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 2/25/2004 21:49'!parent	^ parent! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 12/15/2003 22:01'!parent: aFakeNode	parent _ aFakeNode! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 12/15/2003 22:04'!parentName	^ (parent ifNil: [''] ifNotNil: [parent name])! !!OBFakeNode methodsFor: 'printing' stamp: 'cwp 5/8/2007 23:25'!printOn: aStream	aStream		nextPutAll: 'FakeNode<';		nextPutAll: self name;		nextPut: $>! !!OBFakeNode methodsFor: 'private' stamp: 'cwp 2/25/2004 21:53'!removeChild: aFakeNode	children _ self children copyWithout: aFakeNode! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 3/13/2007 00:24'!root	| node |	node _ self parent.	[node parent notNil] whileTrue: [node _ node parent].	^ node! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 12/15/2003 22:03'!text	^ self name! !!OBFakeNode methodsFor: 'public' stamp: 'cwp 9/18/2005 14:58'!text: aText	self item:( aText asString allButFirst: (self parentName size)).	self demandSelection.	^ true! !!OBFakeNode class methodsFor: 'browsing' stamp: 'cwp 3/12/2007 23:47'!metagraph	| fake |	fake _ OBMetaNode new.	fake childAt: #children put: fake.	^ fake! !!OBFakeNode class methodsFor: 'instance creation' stamp: 'cwp 12/15/2003 22:06'!parent: aFakeNode item: aString	^ self new parent: aFakeNode; item: aString! !OBFakeWidget subclass: #OBFakePane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!!OBFakePane methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:07'!addSwitch	children add: (OBFakeBuilder build: model switch)! !!OBFakePane methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:06'!hasSwitch	^ children size > 1! !!OBFakePane methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:09'!removeSwitch	children removeLast! !!OBFakePane methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:03'!update: aSymbol	aSymbol = #switch ifTrue: [self updateSwitch]! !!OBFakePane methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:06'!updateSwitch	self hasSwitch 		ifTrue: [model wantsButton ifFalse: [self removeSwitch]]		ifFalse: [model wantsButton ifTrue: [self addSwitch]]! !OBFakeWidget subclass: #OBFakeRadioButtonBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeRadioButtonBar instVarNames includes: 'buttons') ifFalse:	[OBFakeRadioButtonBar addInstVarName: 'buttons']!(OBFakeRadioButtonBar instVarNames includes: 'selection') ifFalse:	[OBFakeRadioButtonBar addInstVarName: 'selection']!!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:28'!basicUpdate	self updateList.	self updateSelection.! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:51'!buttonAt: index do: aBlock	aBlock value: (children at: index ifAbsent: [^ self])! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:00'!select: aButton	model selection: (children indexOf: aButton)! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:56'!selectIndex: index	self buttonAt: selection do: [:button | button deselect].	selection _ index.	self buttonAt: selection do: [:button | button select].! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:28'!update: aSymbol	aSymbol == #list ifTrue: [self updateList].	aSymbol == #selection ifTrue: [self updateSelection].! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:44'!updateList	children _ model list collect: [:ea | OBFakeButton label: ea bar: self].	selection := model selection.! !!OBFakeRadioButtonBar methodsFor: 'as yet unclassified' stamp: 'cwp 7/9/2007 23:57'!updateSelection	self selectIndex: model selection! !OBFakeWidget subclass: #OBFakeScroller	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!!OBFakeScroller methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:21'!update: aSymbol	aSymbol = #sizing ifTrue: [^ self updateSizing].	aSymbol = #columns ifTrue: [^ self updatePanes].! !!OBFakeScroller methodsFor: 'as yet unclassified' stamp: 'cwp 7/10/2007 00:25'!updatePanes	| builder |	builder _ OBFakeBuilder new.	children := model columns collect: [:ea | ea buildOn: builder].! !OBFakeWidget subclass: #OBFakeText	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeText instVarNames includes: 'text') ifFalse:	[OBFakeText addInstVarName: 'text']!(OBFakeText instVarNames includes: 'selection') ifFalse:	[OBFakeText addInstVarName: 'selection']!(OBFakeText instVarNames includes: 'hasUnacceptedEdits') ifFalse:	[OBFakeText addInstVarName: 'hasUnacceptedEdits']!(OBFakeText instVarNames includes: 'hasEditingConflicts') ifFalse:	[OBFakeText addInstVarName: 'hasEditingConflicts']!!OBFakeText methodsFor: 'simulating' stamp: 'cwp 7/9/2007 00:55'!accept	model accept: text notifying: self.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.! !!OBFakeText methodsFor: 'emulating' stamp: 'cwp 7/9/2007 00:55'!basicUpdate	text _ model text.	self getSelection.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.! !!OBFakeText methodsFor: 'emulating' stamp: 'cwp 7/8/2007 22:50'!canDiscardEdits	^ hasUnacceptedEdits not! !!OBFakeText methodsFor: 'simulating' stamp: 'cwp 7/9/2007 00:49'!getSelection	^ selection _ model selection! !!OBFakeText methodsFor: 'examining' stamp: 'cwp 7/9/2007 00:54'!hasEditingConflicts	^ hasEditingConflicts! !!OBFakeText methodsFor: 'emulating' stamp: 'cwp 7/9/2007 00:41'!selectionInterval	^ selection! !!OBFakeText methodsFor: 'examining' stamp: 'cwp 7/8/2007 01:47'!text	^ text! !!OBFakeText methodsFor: 'simulating' stamp: 'cwp 7/8/2007 22:49'!text: aString	text _ aString.	hasUnacceptedEdits _ true! !!OBFakeText methodsFor: 'examining' stamp: 'cwp 7/10/2007 00:37'!update: aSymbol	aSymbol = #text ifTrue: [self basicUpdate].	aSymbol = #selection ifTrue: [self getSelection].	aSymbol = #codeChangedElsewhere ifTrue: [hasEditingConflicts _ true].! !OBFakeWidget subclass: #OBFakeWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Fake-Widgets'!(OBFakeWindow instVarNames includes: 'label') ifFalse:	[OBFakeWindow addInstVarName: 'label']!!OBFakeWindow methodsFor: 'simulating' stamp: 'cwp 7/8/2007 21:11'!close	model okToChange ifTrue: [^ self].	model windowIsClosing; release.	model _ nil.! !!OBFakeWindow methodsFor: 'examining' stamp: 'cwp 7/8/2007 22:59'!label	^ label! !!OBFakeWindow methodsFor: 'accessing' stamp: 'cwp 7/8/2007 23:23'!label: aString	label _ aString! !!OBFakeWindow methodsFor: 'printing' stamp: 'cwp 7/9/2007 23:57'!printDebugIdOn: aStream	aStream print: label! !!OBFakeWindow methodsFor: 'emulating' stamp: 'cwp 7/8/2007 23:08'!update: aSymbol	aSymbol = #relabel		ifTrue: [model ifNotNil: [label _ model labelString]]! !!OBFakeWindow class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2007 23:22'!model: anObject label: aString	^ (super model: anObject) label: aString! !OBPanel subclass: #OBFixedButtonPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Panels'!!OBFixedButtonPanel commentStamp: 'cwp 1/7/2005 23:35' prior: 0!OBFixedButtonPanel displays a horizontal row of buttons. In contrast to OBVarButtonPanel, the buttons do not change as nodes are selected in the navigation panel; instead they are enabled and disabled according to whether the actions they represent are applicable to the selected node.!!OBFixedButtonPanel methodsFor: 'building'!buildOn: aBuilder 	^aBuilder fixedButtonBar: self with: []! !!OBFixedButtonPanel methodsFor: 'callbacks'!color	^ browser defaultBackgroundColor ! !!OBFixedButtonPanel methodsFor: 'callbacks'!commands	| commands node buttons grouped groups |	node _ self currentNode.	node ifNil: [^ #()].	commands _ (self announce: OBNodeCommandScan) commandsOn: node for: self.	buttons _ commands select: [:ea | ea wantsButton].	groups _ (buttons collect: [:ea | ea group]) asSet asSortedCollection: [:a :b | a > b].	grouped _ groups collect: [:ea | (buttons select: [:b | b group = ea]) asSortedCollection: [:a :b | a order <= b order]].	^ grouped gather: [:ea | ea]! !!OBFixedButtonPanel methodsFor: 'callbacks'!currentNode	^ browser currentOrRootNode ! !!OBFixedButtonPanel methodsFor: 'callbacks'!isSelected: aNode	^ true! !!OBFixedButtonPanel methodsFor: 'constructing'!isVariableHeight	^ false! !!OBFixedButtonPanel methodsFor: 'callbacks'!selectionChanged: ann	self changed: #commands! !!OBFixedButtonPanel methodsFor: 'callbacks'!subscribe	self announcer		observe: OBSelectionChanged		send: #selectionChanged:		to: self.	self announcer		observe: OBNodeChanged		send: #selectionChanged:		to: self.! !!OBFixedButtonPanel methodsFor: 'building'!vResizing	^ #rigid! !!OBFixedButtonPanel class methodsFor: 'as yet unclassified'!new	^ self basicNew initialize! !OBInteractionRequest subclass: #OBInformRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!(OBInformRequest instVarNames includes: 'message') ifFalse:	[OBInformRequest addInstVarName: 'message']!!OBInformRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleInformRequest: self! !!OBInformRequest methodsFor: 'accessing'!message	^ message! !!OBInformRequest methodsFor: 'accessing'!message: aString 	message := aString! !!OBInformRequest class methodsFor: 'exceptionInstantiator'!message: aString	^ (self new		message: aString;		yourself) signal! !OBOpenTest subclass: #OBLibraryOpenTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Core'!!OBLibraryOpenTest methodsFor: 'accessing' stamp: 'cwp 1/21/2007 23:42'!metagraph	| fake |	fake _ OBMetaNode new.	fake childAt: #children put: fake.	^ fake! !!OBLibraryOpenTest methodsFor: 'tests' stamp: 'avi 9/17/2005 01:16'!testGraphRootSelection	| parent child |	parent _ OBFakeNode parent: nil item: 'parent'.	child _ OBFakeNode parent: parent item: 'a'.	self create: [OBBrowser 					metaNode: self metagraph					root: parent					selection: child].	self shouldnt: [browser navigationPanel] raise: Error! !!OBLibraryOpenTest methodsFor: 'tests' stamp: 'dkh 6/1/2007 10:08'!testGraphRootSelectionPanels	| parent child panels |	parent := OBFakeNode parent: nil item: 'parent'.	child := OBFakeNode parent: parent item: 'a'.	panels := (Array with: OBColumnPanel new with: OBDefinitionPanel new).	self		create: [OBBrowser				metaNode: self metagraph				root: parent				selection: child				panels: panels].	self assert: browser navigationPanel minPanes = 1.	self assert: browser navigationPanel maxPanes = 1.	self assert: browser root = parent.	self assert: browser currentNode = child.	self assert: browser panels size = panels size.	self		assert: (browser panels includesAllOf: panels)! !OBFilter subclass: #OBModalFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Filters'!!OBModalFilter commentStamp: 'cwp 1/7/2005 23:39' prior: 0!OBModalFilter is used to implement the 'instance/?/class' buttons in a standard class browser. In functional terms it filters the nodes of a column according to the edge of the metagraph that they correspond to. OBModalFilter displays an OBRadioButtonBar in its column's pane, with one button per edge. Only nodes from the currently selected edge are allowed in the column.iVars:selection	- the currently selected edge!(OBModalFilter instVarNames includes: 'selection') ifFalse:	[OBModalFilter addInstVarName: 'selection']!!OBModalFilter methodsFor: 'callbacks'!activate	! !!OBModalFilter methodsFor: 'filtering'!edgesFrom: aCollection forNode: aNode	^ Array with: (aCollection at: self selection)! !!OBModalFilter methodsFor: 'callbacks'!list	^ metaNode edges collect: [:edge | edge label]! !!OBModalFilter methodsFor: 'callbacks'!listForNode: aNode	^ self list! !!OBModalFilter methodsFor: 'filtering'!noteParent: pNode child: cNode	pNode metaNode edges withIndexDo:		[:edge :index | 		cNode metaNode = edge metaNode			ifTrue: [selection _ index]]! !!OBModalFilter methodsFor: 'callbacks'!selection	^ selection ifNil: [selection _ 1]! !!OBModalFilter methodsFor: 'callbacks'!selection: anInteger	selection _ anInteger.	self changed: #selection.	! !!OBModalFilter methodsFor: 'queries'!wantsButton	^ true! !!OBModalFilter methodsFor: 'testing'!wantsSwitch	^ true! !OBBuilder subclass: #OBMorphBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Core'!(OBMorphBuilder instVarNames includes: 'color') ifFalse:	[OBMorphBuilder addInstVarName: 'color']!!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:55'!button: aButtonModel with: aBlock 	| morph |	morph := PluggableButtonMorph 				on: aButtonModel				getState: #isSelected				action: #push				label: #labelMorph.	morph		hResizing: #spaceFill;		vResizing: #spaceFill;		styleWith: OBMorphBuilder new.	^self current: morph do: aBlock! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:52'!fixedButtonBar: aPanel with: aBlock 	| morph |	morph := OBButtonBar on: aPanel.	morph		height: Preferences standardCodeFont height * 2.2;		layoutPolicy: TableLayout new;		vResizing: #rigid;		hResizing: #spaceFill;		listDirection: #leftToRight;		rubberBandCells: true;		borderWidth: 0.	current addMorphBack: morph.	self current: morph do: aBlock! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 12/9/2007 11:58'!horizontalGroupWith: aBlock 	| morph |	morph := OBGroupingMorph new.	morph layoutPolicy: TableLayout new.	morph listDirection: #leftToRight.	current addMorph: morph frame: (0 @ 0 extent: 1 @ 1).	self current: morph do: aBlock.	morph addBorders! !!OBMorphBuilder methodsFor: 'private' stamp: 'cwp 12/17/2007 23:40'!layoutPanels	| panes |	panes := current submorphs select: [:ea | ea class == OBGroupingMorph].	(self shouldUseSpecialLayoutFor: panes)		ifTrue: [panes first layoutFrame bottomFraction: 0.4.				panes second layoutFrame topFraction: 0.4]		ifFalse: [panes withIndexDo: 					[:morph :index | 					morph layoutFrame 						topFraction: index - 1 / panes size;						bottomFraction: index / panes size]].	panes do: 		[:ea | 		ea on: #mouseEnter send: #paneTransition: to: current.		ea on: #mouseLeave send: #paneTransition: to: current].	self style39 ifTrue: [current addPaneSplitters]! !!OBMorphBuilder methodsFor: 'private' stamp: 'cwp 7/5/2007 23:31'!listMorphForColumn: aColumn	^ (OBPluggableListMorph		on: aColumn		list: #list		selected: #selection		changeSelected: #selection:		menu: #menu:		keystroke: #keystroke:from:)			getListElementSelector: #listAt:;			getListSizeSelector: #listSize;			dragEnabled: aColumn dragEnabled;			dropEnabled: aColumn dropEnabled;			borderWidth: 0;			autoDeselect: false;			yourself! !!OBMorphBuilder methodsFor: 'private' stamp: 'cwp 3/18/2007 21:16'!mercuryMorphFor: aMercuryPanel	^ (OBPluggableTextMorph		on: aMercuryPanel		text: #text		accept: #accept:notifying:		readSelection: #selection		menu: #menu:shifted:)			font: Preferences standardCodeFont;			hideScrollBarsIndefinitely;			acceptOnCR: true;			height: Preferences standardCodeFont height * 1.2;			borderWidth: 0;			vResizing: #rigid;			hResizing: #spaceFill;			yourself.! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:47'!pane: aColumn with: aBlock 	| pane |	pane := OBPane new.	pane		model: aColumn;		hResizing: #spaceFill;		vResizing: #spaceFill;		clipSubmorphs: true;		color: Color transparent;		cellInset: 0;		borderWidth: 0;		layoutPolicy: ProportionalLayout new;		addList: (self listMorphForColumn: aColumn).	current ifNotNil: [current pushPane: pane].	^self current: pane do: aBlock! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:53'!radioButtonBar: aSwitch with: aBlock 	| morph |	^aSwitch isActive 		ifTrue: 			[morph := OBRadioButtonBar 						on: aSwitch						list: #list						selected: #selection						changeSelected: #selection:.			current ifNotNil: [current addButton: morph].			morph]! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:46'!scroller: aColumnPanel with: aBlock 	| morph |	morph := (OBPaneScroller withModel: aColumnPanel)				name: 'scroller';				vResizing: #spaceFill;				hResizing: #spaceFill;				yourself.	current ifNotNil: [current addMorphBack: morph].	^self current: morph do: aBlock! !!OBMorphBuilder methodsFor: 'private' stamp: 'cwp 12/17/2007 23:53'!shouldUseSpecialLayoutFor: panes	^ panes size = 2		and: [panes first listDirection = #topToBottom]		and: [panes second listDirection = #topToBottom]		and: [panes first lastSubmorph class = OBPaneScroller]		and: [panes last lastSubmorph class = OBPluggableTextMorph]! !!OBMorphBuilder methodsFor: 'style' stamp: 'cwp 7/23/2007 02:04'!style39	^ Smalltalk hasClassNamed: #AbstractResizerMorph! !!OBMorphBuilder methodsFor: 'style' stamp: 'cwp 7/21/2007 22:26'!styleButton: aButton	self style39 ifFalse:		[aButton			borderWidth: 2;			borderRaised]! !!OBMorphBuilder methodsFor: 'style' stamp: 'cwp 7/21/2007 22:26'!styleButtonBar: aBar	self style39		ifFalse: [aBar borderWidth: 0]		ifTrue: 			[aBar				color: Color transparent;				borderWidth: 0;				layoutInset: 2;				cellInset: 2]! !!OBMorphBuilder methodsFor: 'style' stamp: 'cwp 7/23/2007 02:08'!styleHorizontalDivider: divider	self style39		ifTrue: [divider height: 3]		ifFalse:			[divider				borderWidth: 2;				borderInset]! !!OBMorphBuilder methodsFor: 'style' stamp: 'cwp 7/23/2007 02:08'!styleVerticalDivider: divider	self style39		ifTrue: [divider height: 3]		ifFalse:			[divider				borderWidth: 2;				borderRaised]! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:48'!textarea: aDefinitionPanel with: aBlock 	"see CodeHolder>>buildMorphicCodePaneWith:"	| morph shoutInstalled morphClass |	shoutInstalled := (Smalltalk classNamed: #SHTextStylerST80) notNil.	morphClass := shoutInstalled 				ifTrue: [OBPluggableTextMorphWithShout]				ifFalse: [OBPluggableTextMorph].	morph := morphClass 				on: aDefinitionPanel				text: #text				accept: #accept:notifying:				readSelection: #selection				menu: #menu:shifted:.	morph		font: Preferences standardCodeFont;		borderWidth: 0;		vResizing: #spaceFill;		hResizing: #spaceFill.	current ifNotNil: [current addMorphBack: morph].	^self current: morph do: aBlock! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 7/25/2007 23:57'!textfield: aMercuryPanel with: aBlock 	| morph divider |	morph := self mercuryMorphFor: aMercuryPanel.	morph color: Color white.	current ifNotNil: 			[current addMorphBack: morph.			self current: morph do: aBlock.			divider := (BorderedSubpaneDividerMorph horizontal)						color: aMercuryPanel browser defaultBackgroundColor duller;						styleWith: OBMorphBuilder new.			current addMorphBack: divider].	^morph! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 12/9/2007 10:57'!verticalGroupWith: aBlock 	| morph |	morph := OBGroupingMorph new.	morph layoutPolicy: TableLayout new.	current addMorph: morph frame: (0 @ 0 extent: 1 @ 1).	self current: morph do: aBlock! !!OBMorphBuilder methodsFor: 'building' stamp: 'cwp 12/9/2007 11:54'!window: aBrowser with: aBlock 	| window |	color _ aBrowser defaultBackgroundColor.	window := SystemWindow labelled: aBrowser defaultLabel.	window model: aBrowser.	^self current: window		do: 			[aBlock value.			self layoutPanels]! !!OBMorphBuilder class methodsFor: 'instance-creation' stamp: 'lr 6/20/2007 09:36'!open: aModel	^ (self build: aModel) openInWorld! !OBBuilderTest subclass: #OBMorphBuilderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 22:38'!activate	! !!OBMorphBuilderTest methodsFor: 'accessing' stamp: 'cwp 3/13/2007 22:30'!builder	^ OBMorphBuilder new! !!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 3/15/2007 22:37'!displayString	^ 'test'! !!OBMorphBuilderTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2007 20:20'!displayStringForChild: aNode 	^ aNode displayString! !!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 3/24/2007 00:48'!isEnabled: aButton	^ true! !!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 3/24/2007 00:49'!isSelected: aButton	^ false! !!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 22:38'!list	^ #(a b c)! !!OBMorphBuilderTest methodsFor: 'emulating' stamp: 'cwp 5/17/2007 22:38'!selection	^ 1! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/13/2007 22:27'!tests01BrowserCreatesWindow	| morph |	morph _ self buildWindow.	self assert: (morph isKindOf: SystemWindow).	self assert: (morph model == model).! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/18/2007 23:32'!tests02BrowserAddsPanelGroups	| widget |	widget _ self buildWindow.	self assert: widget submorphs size = 3.	self assert: (widget submorphs second isKindOf: RectangleMorph).	self assert: (widget submorphs third isKindOf: RectangleMorph).! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/18/2007 23:45'!tests02BrowserAddsPanels	| morphs |	morphs _ self buildWindow submorphs gather: [:ea | ea submorphs].	morphs _ morphs select: [:ea | ea respondsTo: #model].	self assert: (morphs anySatisfy: [:ea | ea model isKindOf: OBColumnPanel]).	self assert: (morphs anySatisfy: [:ea | ea model isKindOf: OBDefinitionPanel]).! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/15/2007 23:11'!tests03ColumnPanelAddsColumns	| morph panes |	morph _ self buildNavigationPanel.	panes _ morph submorphs first submorphs.	self assert: (morph model isKindOf: OBColumnPanel).	self assert: panes  size = 7.	(1 to: 7 by: 2) do: [:ea | self assert: ((panes at: ea) isKindOf: OBPane)].	! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/15/2007 22:55'!tests04ColumnAddsList	| morph |	morph _ self build: self columnWithFilter.	self assert: (morph isKindOf: OBPane).	self assert: (morph submorphs last isKindOf: PluggableListMorph)! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/15/2007 22:55'!tests05ColumnAddsButton	| morph |	morph _ self build: self columnWithFilter.	self assert: (morph isKindOf: OBPane).	self assert: (morph submorphs first isKindOf: OBRadioButtonBar)! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/23/2007 22:47'!tests06TwoGroupSpecialCase	| widget |	widget _ self buildWindow.	self assert: widget submorphs size = 3.	self assert: (widget submorphs second layoutFrame bottomFraction = 0.4).	self assert: (widget submorphs third layoutFrame topFraction = 0.4).! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 3/24/2007 00:50'!tests07ButtonModelCanBeBuiltAlone	| morph |	model _ OBButtonModel withLabel: 'test' inBar: self.	morph _ OBMorphBuilder build: model.	self assert: (morph isKindOf: PluggableButtonMorph).! !!OBMorphBuilderTest methodsFor: 'tests' stamp: 'cwp 5/17/2007 22:38'!tests08SwitchCanBeBuiltAlone	| morph |	model _ OBSwitch new.	model filter: self.	morph _ OBMorphBuilder build: model.	self assert: (morph isKindOf: OBRadioButtonBar).! !OBPlatform subclass: #OBMorphicPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Core'!!OBMorphicPlatform methodsFor: 'preferences' stamp: 'cwp 7/1/2007 17:07'!enableGently: aSymbol	^ Preferences enableGently: aSymbol! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'cwp 6/1/2007 16:50'!handleBrowseRequest: request	^ OBMorphBuilder open: request browser! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dc 9/18/2007 10:48'!handleChoiceRequest: request	^ UIManager default		chooseFrom: request labels		values: request values		lines: request lines		title: (request prompt ifNil: [''])! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'avi 12/5/2007 13:20'!handleCloseRequest: request	(SystemWindow allInstances detect: [:ea | ea model = request browser] ifNone: []) ifNotNilDo:		[:sw |		sw delete]! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dc 9/18/2007 15:57'!handleConfirmationRequest: request	^ UIManager default		chooseFrom: {request okChoice. request cancelChoice}		values: {true. false}		title: request prompt.! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dkh 1/14/2008 12:20'!handleDirectoryRequest: request	| fileDirectory |	fileDirectory := UIManager default chooseDirectory.	fileDirectory == nil ifTrue: [ ^nil ].	^fileDirectory pathName! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dc 7/22/2007 20:32'!handleInformRequest: anOBInformRequest 	self inform: anOBInformRequest message! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dkh 12/19/2007 09:32'!handleMultiLineTextRequest: request	^UIManager default				multiLineRequest: request prompt				centerAt: Sensor cursorPoint				initialAnswer: request template				answerHeight: 400! !!OBMorphicPlatform methodsFor: 'interaction' stamp: 'dc 9/18/2007 16:01'!handleTextRequest: request	| text |	text := UIManager default				request:request prompt				initialAnswer: request template.	^ text		ifEmpty: [nil]		ifNotEmpty: [text]! !!OBMorphicPlatform methodsFor: 'preferences' stamp: 'cwp 7/1/2007 16:46'!menuWithIcons	^ Preferences menuWithIcons! !!OBMorphicPlatform methodsFor: 'preferences' stamp: 'cwp 7/1/2007 16:41'!optionalButtons	^ Preferences optionalButtons ! !!OBMorphicPlatform methodsFor: 'preferences' stamp: 'cwp 7/1/2007 17:09'!setPreference: aSymbol toValue: anObject	^ Preferences setPreference: aSymbol toValue: anObject! !!OBMorphicPlatform class methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2007 16:10'!default	^ self new! !OBInteractionRequest subclass: #OBMultiLineTextRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!(OBMultiLineTextRequest instVarNames includes: 'prompt') ifFalse:	[OBMultiLineTextRequest addInstVarName: 'prompt']!(OBMultiLineTextRequest instVarNames includes: 'template') ifFalse:	[OBMultiLineTextRequest addInstVarName: 'template']!!OBMultiLineTextRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleMultiLineTextRequest: self! !!OBMultiLineTextRequest methodsFor: 'accessing'!prompt	^ prompt! !!OBMultiLineTextRequest methodsFor: 'accessing'!prompt: aString	prompt _ aString! !!OBMultiLineTextRequest methodsFor: 'accessing'!template	^ template! !!OBMultiLineTextRequest methodsFor: 'accessing'!template: aString	template _ aString! !!OBMultiLineTextRequest class methodsFor: 'exceptionInstantiator'!prompt: aString	^ self prompt: aString template: ''! !!OBMultiLineTextRequest class methodsFor: 'exceptionInstantiator'!prompt: promptString template: templateString	^ (self new prompt: promptString; template: templateString) signal! !OBAnnouncement subclass: #OBNodeChanged	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBNodeChanged instVarNames includes: 'node') ifFalse:	[OBNodeChanged addInstVarName: 'node']!!OBNodeChanged methodsFor: 'as yet unclassified'!node	^ node! !!OBNodeChanged methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBNodeChanged class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBAnnouncement subclass: #OBNodeCreated	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBNodeCreated instVarNames includes: 'node') ifFalse:	[OBNodeCreated addInstVarName: 'node']!!OBNodeCreated methodsFor: 'as yet unclassified'!node	^ node! !!OBNodeCreated methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBNodeCreated class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBAnnouncement subclass: #OBNodeDeleted	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBNodeDeleted instVarNames includes: 'node') ifFalse:	[OBNodeDeleted addInstVarName: 'node']!!OBNodeDeleted methodsFor: 'as yet unclassified'!node	^ node! !!OBNodeDeleted methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBNodeDeleted class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBCommand subclass: #OBPluggableCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Commands'!(OBPluggableCommand instVarNames includes: 'action') ifFalse:	[OBPluggableCommand addInstVarName: 'action']!(OBPluggableCommand instVarNames includes: 'active') ifFalse:	[OBPluggableCommand addInstVarName: 'active']!(OBPluggableCommand instVarNames includes: 'enabled') ifFalse:	[OBPluggableCommand addInstVarName: 'enabled']!(OBPluggableCommand instVarNames includes: 'label') ifFalse:	[OBPluggableCommand addInstVarName: 'label']!(OBPluggableCommand instVarNames includes: 'keystroke') ifFalse:	[OBPluggableCommand addInstVarName: 'keystroke']!(OBPluggableCommand instVarNames includes: 'icon') ifFalse:	[OBPluggableCommand addInstVarName: 'icon']!(OBPluggableCommand instVarNames includes: 'buttonLabel') ifFalse:	[OBPluggableCommand addInstVarName: 'buttonLabel']!!OBPluggableCommand methodsFor: 'accessing'!action: aValuable	action := aValuable! !!OBPluggableCommand methodsFor: 'accessing'!active: aValuable	active := aValuable! !!OBPluggableCommand methodsFor: 'accessing'!buttonLabel	^ buttonLabel! !!OBPluggableCommand methodsFor: 'accessing'!buttonLabel: aString	buttonLabel _ aString! !!OBPluggableCommand methodsFor: 'accessing'!enabled: aBlock	enabled _ aBlock! !!OBPluggableCommand methodsFor: 'execute'!execute	^ action valueWithPossibleArgs: (Array with: target with: requestor)! !!OBPluggableCommand methodsFor: 'accessing'!group	^ #general! !!OBPluggableCommand methodsFor: 'accessing'!icon	^ icon! !!OBPluggableCommand methodsFor: 'accessing'!icon: anIcon	icon _ anIcon! !!OBPluggableCommand methodsFor: 'initialize-release'!initialize	action _ [].	active _ [true].	enabled _ [true].	label _ 'a command'.! !!OBPluggableCommand methodsFor: 'testing'!isActive	^ active valueWithPossibleArgs: (Array with: target with: requestor)! !!OBPluggableCommand methodsFor: 'testing'!isEnabled	^ enabled valueWithPossibleArgs: (Array with: target with: requestor)! !!OBPluggableCommand methodsFor: 'accessing'!keystroke	^ keystroke! !!OBPluggableCommand methodsFor: 'accessing'!keystroke: aCharacter	keystroke _ aCharacter! !!OBPluggableCommand methodsFor: 'accessing'!label	^ label! !!OBPluggableCommand methodsFor: 'accessing'!label: aString	label _ aString! !!OBPluggableCommand methodsFor: 'morphic'!labelWithKeystroke	^keystroke		ifNil: [label]		ifNotNil: [label, ' (', keystroke asString, ')']! !!OBPluggableCommand methodsFor: 'converting'!on: aNode for: aRequestor 	| inst |	inst _ self copy.	inst setTarget: aNode requestor: aRequestor.	^ inst! !!OBPluggableCommand methodsFor: 'testing'!takesNodes	^ true! !!OBPluggableCommand methodsFor: 'testing'!useLineAfter	^ false! !!OBPluggableCommand methodsFor: 'testing'!wantsButton	^ self buttonLabel notNil! !!OBPluggableCommand class methodsFor: 'as yet unclassified'!action: aValuable	^ self new action: aValuable! !!OBPluggableCommand class methodsFor: 'as yet unclassified'!action: aValuable active: aValuable2	^ self new 		action: aValuable;		active: aValuable2;		yourself! !!OBPluggableCommand class methodsFor: 'as yet unclassified'!new	^ self basicNew initialize! !!OBPluggableCommand class methodsFor: 'as yet unclassified'!takesNodes	^ true! !!OBPluggableCommand class methodsFor: 'as yet unclassified'!takesText	^ false! !OBFilter subclass: #OBPluggableFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Filters'!(OBPluggableFilter instVarNames includes: 'edges') ifFalse:	[OBPluggableFilter addInstVarName: 'edges']!(OBPluggableFilter instVarNames includes: 'nodeDisplay') ifFalse:	[OBPluggableFilter addInstVarName: 'nodeDisplay']!(OBPluggableFilter instVarNames includes: 'nodes') ifFalse:	[OBPluggableFilter addInstVarName: 'nodes']!(OBPluggableFilter instVarNames includes: 'parentDisplay') ifFalse:	[OBPluggableFilter addInstVarName: 'parentDisplay']!(OBPluggableFilter instVarNames includes: 'note') ifFalse:	[OBPluggableFilter addInstVarName: 'note']!(OBPluggableFilter instVarNames includes: 'icon') ifFalse:	[OBPluggableFilter addInstVarName: 'icon']!!OBPluggableFilter methodsFor: 'filtering'!displayString: aString forNode: aNode	^ nodeDisplay 		ifNil: [super displayString: aString forNode: aNode]		ifNotNil: [nodeDisplay value: aString value: aNode]! !!OBPluggableFilter methodsFor: 'filtering'!displayString: aString forParent: pNode child: cNode	^ parentDisplay		ifNil: [super displayString: aString forParent: pNode child: cNode]		ifNotNil: [parentDisplay value: aString value: pNode value: cNode]! !!OBPluggableFilter methodsFor: 'accessing'!edges	^ edges! !!OBPluggableFilter methodsFor: 'accessing'!edges: anObject	edges := anObject! !!OBPluggableFilter methodsFor: 'filtering'!edgesFrom: aCollection forNode: aNode	^ edges 		ifNil: [super edgesFrom: aCollection forNode: aNode]		ifNotNil: [edges value: aCollection value: aNode]! !!OBPluggableFilter methodsFor: 'accessing'!icon	^ icon! !!OBPluggableFilter methodsFor: 'accessing'!icon: aBlock	icon _ aBlock! !!OBPluggableFilter methodsFor: 'filtering'!icon: aSymbol forNode: aNode	^ icon		ifNil: [super icon: aSymbol forNode: aNode]		ifNotNil: [icon value: aSymbol value: aNode]! !!OBPluggableFilter methodsFor: 'accessing'!nodeDisplay	^nodeDisplay! !!OBPluggableFilter methodsFor: 'accessing'!nodeDisplay: anObject	nodeDisplay := anObject! !!OBPluggableFilter methodsFor: 'accessing'!nodes	^nodes! !!OBPluggableFilter methodsFor: 'accessing'!nodes: anObject	nodes := anObject! !!OBPluggableFilter methodsFor: 'filtering'!nodesFrom: aCollection forNode: aNode	^ nodes 		ifNil: [super nodesFrom: aCollection forNode: aNode]		ifNotNil: [nodes value: aCollection value: aNode]! !!OBPluggableFilter methodsFor: 'accessing'!note	^ note! !!OBPluggableFilter methodsFor: 'accessing'!note: aBlock	note _ aBlock! !!OBPluggableFilter methodsFor: 'filtering'!noteParent: pNode child: cNode	^ note 		ifNil: [super noteParent: pNode child: cNode]		ifNotNil: [note value: pNode value: cNode]! !!OBPluggableFilter methodsFor: 'accessing'!parentDisplay	^parentDisplay! !!OBPluggableFilter methodsFor: 'accessing'!parentDisplay: anObject	parentDisplay := anObject! !OBPluggableTextMorph subclass: #OBPluggableTextMorphWithShout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!(OBPluggableTextMorphWithShout instVarNames includes: 'styler') ifFalse:	[OBPluggableTextMorphWithShout addInstVarName: 'styler']!(OBPluggableTextMorphWithShout instVarNames includes: 'unstyledAcceptText') ifFalse:	[OBPluggableTextMorphWithShout addInstVarName: 'unstyledAcceptText']!!OBPluggableTextMorphWithShout methodsFor: 'accepting' stamp: 'tween 3/15/2007 14:00'!acceptTextInModel 		self okToStyle ifFalse:[^super acceptTextInModel].				"#correctFrom:to:with: is sent when the method source is	manipulated during compilation (removing unused temps,	changing selectors etc). But 	#correctFrom:to:with: operates 	on the textMorph's text, and we may be saving an unstyled 	copy of the text. This means that these corrections will be lost	unless we also apply the corrections to the unstyled copy that we are saving.		So remember the unstyled copy in unstyledAcceptText, so	that when #correctFrom:to:with: is received we can also apply	the correction to it"	unstyledAcceptText := styler unstyledTextFrom: textMorph asText.	[^setTextSelector isNil or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: unstyledAcceptText with: self]			ifFalse: [model perform: setTextSelector with: unstyledAcceptText]]	] ensure:[unstyledAcceptText := nil]! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:00'!classOrMetaClass: aBehavior	"set the classOrMetaClass in the receiver's styler to aBehavior"			styler classOrMetaClass: aBehavior ! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:00'!correctFrom: start to: stop with: aString	"see the comment in #acceptTextInModel "	unstyledAcceptText ifNotNil:[unstyledAcceptText replaceFrom: start to: stop with: aString ].	^ super correctFrom: start to: stop with: aString! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:00'!environment: anObject	"set the environment in the receiver's styler to anObject"			styler environment: anObject ! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:00'!font: aFont	super font: aFont.	styler ifNotNil: [styler font: aFont]! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:01'!hasUnacceptedEdits: aBoolean	"re-implemented to re-style the text iff aBoolean is true"	 	super hasUnacceptedEdits: aBoolean.	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: textMorph contents]! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:01'!okToStyle	styler ifNil:[^false].	Preferences syntaxHighlightingAsYouType ifFalse: [^false].	(model respondsTo: #shoutAboutToStyle: ) ifFalse:[^true].	^model shoutAboutToStyle: self! !!OBPluggableTextMorphWithShout methodsFor: 'private' stamp: 'tween 3/15/2007 14:14'!privateSetText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ self textMorphClass new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:14'!setText: aText		self okToStyle ifFalse:[^self privateSetText: aText].	self privateSetText: (styler format: aText asText).	aText size < 4096		ifTrue:[	styler style: textMorph contents]		ifFalse:[styler styleInBackgroundProcess:  textMorph contents]! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:01'!sourceMap: aSortedCollection	"set the sourceMap in the receiver's styler to aSortedCollection"			styler sourceMap: aSortedCollection! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:01'!styler	^styler! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:02'!styler: anObject		styler := anObject! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 11/16/2007 07:17'!stylerStyled: styledCopyOfText	textMorph contents runs: styledCopyOfText runs .	"textMorph paragraph recomposeFrom: 1 to: textMorph contents size delta: 0."  "caused chars to appear in wrong order esp. in demo mode. remove this line when sure it is fixed"	textMorph updateFromParagraph.	selectionInterval 		ifNotNil:[			textMorph editor				selectInvisiblyFrom: selectionInterval first to: selectionInterval last;				storeSelectionInParagraph;				setEmphasisHere].	textMorph editor blinkParen.	self scrollSelectionIntoView! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:02'!stylerStyledInBackground: styledCopyOfText 	"It is possible that the text string	has changed since the styling began. Disregard the styles if styledCopyOfText's string differs with the current textMorph contents string"		textMorph contents string = styledCopyOfText string		ifTrue: [self stylerStyled: styledCopyOfText]	! !!OBPluggableTextMorphWithShout methodsFor: 'private' stamp: 'tween 3/15/2007 14:15'!textMorphClass	"Answer the class used to create the receiver's textMorph"		^OBTextMorphWithShout! !!OBPluggableTextMorphWithShout methodsFor: 'styler' stamp: 'tween 3/15/2007 14:02'!workspace: anObject	"set the workspace in the receiver's styler to anObject"			styler workspace: anObject ! !!OBPluggableTextMorphWithShout class methodsFor: 'instance creation' stamp: 'tween 4/24/2007 16:28'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	|styler answer stylerClass |	answer := self new.	stylerClass := Smalltalk classNamed: #SHTextStylerST80.	styler := stylerClass		ifNotNil:[			stylerClass new				view: answer;				yourself].	^ answer		styler: styler;		on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !OBBarMorphTest subclass: #OBRadioButtonBarTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Tests-Morphic'!(OBRadioButtonBarTest instVarNames includes: 'selection') ifFalse:	[OBRadioButtonBarTest addInstVarName: 'selection']!!OBRadioButtonBarTest methodsFor: 'asserting' stamp: 'cwp 11/27/2004 18:03'!assertSelectionIs: anInteger	self assert: selection = anInteger.	bar submorphs withIndexDo: 		[:button :index |		index = anInteger			ifTrue: [self assert: button isOn]			ifFalse: [self deny: button isOn]]! !!OBRadioButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 2/22/2004 17:42'!list	^ #('alpha' 'beta' 'gamma')! !!OBRadioButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 2/22/2004 16:39'!selection	^ selection! !!OBRadioButtonBarTest methodsFor: 'callbacks' stamp: 'cwp 2/24/2004 19:31'!selection: anInteger	selection _ anInteger.	self changed: #selection! !!OBRadioButtonBarTest methodsFor: 'running' stamp: 'cwp 11/27/2004 18:03'!setUp	selection _ 0.	bar _ OBRadioButtonBar			on: self			list: #list			selected: #selection			changeSelected: #selection:.! !!OBRadioButtonBarTest methodsFor: 'testing' stamp: 'cwp 3/11/2007 15:57'!testLayout	| rects |		"This is an ugly hack. I can't figure out how else to force a layout."	bar openInWorld.	self changed: #list.	bar bounds: (100@100 corner: 400@140).	bar delete.	rects _ bar submorphs collect: [:b | b bounds].	self assert: rects first left = bar left.	self assert: rects first right = rects second left.	self assert: rects second right = rects third left.	self assert: rects third right = bar right.! !!OBRadioButtonBarTest methodsFor: 'testing' stamp: 'cwp 2/22/2004 16:53'!testList	self assert: bar list = self list! !!OBRadioButtonBarTest methodsFor: 'testing' stamp: 'cwp 2/24/2004 19:35'!testPushAlphaBeta	self changed: #list.	self push: 'alpha'.	self assertSelectionIs: 1.	self push: 'beta'.	self assertSelectionIs: 2.! !!OBRadioButtonBarTest methodsFor: 'testing' stamp: 'cwp 11/27/2004 18:04'!testUpdateList	| labels |	self changed: #list.	labels _ bar submorphs collect: [:b | b label contents].	self assert: labels size = self list size.	self assert: (labels includesAllOf: self list)! !!OBRadioButtonBarTest methodsFor: 'testing' stamp: 'cwp 2/24/2004 19:15'!testUpdateSelection	self changed: #list.	selection _ 2.	self changed: #selection.	self assertSelectionIs: 2.! !OBAnnouncement subclass: #OBRefreshRequired	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!OBFilter subclass: #OBRescueFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Filters'!(OBRescueFilter instVarNames includes: 'cache') ifFalse:	[OBRescueFilter addInstVarName: 'cache']!(OBRescueFilter instVarNames includes: 'rescued') ifFalse:	[OBRescueFilter addInstVarName: 'rescued']!!OBRescueFilter methodsFor: 'filtering'!cache: aCollection for: aNode	| cached missing |	cached _ cache at: aNode ifAbsent: [^ self initCache: aCollection for: aNode].	cache at: aNode put: aCollection.	missing _ rescued at: aNode ifAbsent: [Set new].	missing removeAllSuchThat: [:ea | aCollection includes: ea].	cached do: [:ea | (aCollection includes: ea) ifFalse: [missing add: ea]].	missing isEmpty ifFalse: [rescued at: aNode put: missing].	^ missing asArray! !!OBRescueFilter methodsFor: 'filtering'!displayString: aString forParent: pNode child: cNode	^ ((rescued at: pNode ifAbsent: [#()]) includes: cNode)		ifTrue: [aString asText addAttribute: TextEmphasis struckOut]		ifFalse: [aString]! !!OBRescueFilter methodsFor: 'filtering'!initCache: aCollection for: aNode	cache at: aNode put: aCollection.	^ #()! !!OBRescueFilter methodsFor: 'private'!initialize	cache _ Dictionary new.	rescued _ Dictionary new.! !!OBRescueFilter methodsFor: 'filtering'!nodesFrom: aCollection forNode: aNode	^ aCollection, (self cache: aCollection for: aNode)! !!OBRescueFilter methodsFor: 'private'!rescue: aCollection for: aNode	| previous |	previous _ rescued at: aNode ifAbsent: [#()].	^ rescued at: aNode put: previous, aCollection.! !OBAnnouncement subclass: #OBSelectingNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBSelectingNode instVarNames includes: 'node') ifFalse:	[OBSelectingNode addInstVarName: 'node']!!OBSelectingNode methodsFor: 'as yet unclassified'!node	^ node! !!OBSelectingNode methodsFor: 'as yet unclassified'!node: aNode	node _ aNode! !!OBSelectingNode class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBAnnouncement subclass: #OBSelectionChanged	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!(OBSelectionChanged instVarNames includes: 'node') ifFalse:	[OBSelectionChanged addInstVarName: 'node']!(OBSelectionChanged instVarNames includes: 'column') ifFalse:	[OBSelectionChanged addInstVarName: 'column']!(OBSelectionChanged instVarNames includes: 'deselectedNode') ifFalse:	[OBSelectionChanged addInstVarName: 'deselectedNode']!!OBSelectionChanged methodsFor: 'accessing'!column	^ column! !!OBSelectionChanged methodsFor: 'accessing'!column: aColumn	column _ aColumn! !!OBSelectionChanged methodsFor: 'accessing'!deselectedNode	^deselectedNode! !!OBSelectionChanged methodsFor: 'accessing'!deselectedNode: aNode	deselectedNode := aNode! !!OBSelectionChanged methodsFor: 'accessing'!node	^ column 		ifNil: [node]		ifNotNil: [column selectedNode]! !!OBSelectionChanged methodsFor: 'accessing'!node: aNode	node _ aNode! !!OBSelectionChanged class methodsFor: 'instance creation'!column: aColumn 	^ self new column: aColumn! !!OBSelectionChanged class methodsFor: 'as yet unclassified'!node: aNode	^ self new node: aNode! !OBTextMorphEditor subclass: #OBTextMorphEditorWithShout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!(OBTextMorphEditorWithShout instVarNames includes: 'inBackTo') ifFalse:	[OBTextMorphEditorWithShout addInstVarName: 'inBackTo']!!OBTextMorphEditorWithShout methodsFor: 'backspace handling' stamp: 'tween 3/15/2007 14:16'!backTo: startIndex	"When backspacing, 2 notifications of the userHasEdited are received.	This then causes a background process to not terminate correctly.	The reason for all this is uncertain, but discarding the superfluous userHasEdited	message received while running backTo: seems to cure the problem"	| answer |	[inBackTo := true.	answer := super backTo: startIndex	] ensure:[		inBackTo:=false.		^answer]	! !!OBTextMorphEditorWithShout methodsFor: 'parenblinking' stamp: 'tween 3/15/2007 14:17'!blinkParen	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]]! !!OBTextMorphEditorWithShout methodsFor: 'new selection' stamp: 'tween 3/15/2007 14:18'!changeEmphasis: characterStream 	morph editView styler 		evaluateWithoutStyling: [^super changeEmphasis: characterStream]! !!OBTextMorphEditorWithShout methodsFor: 'parenblinking' stamp: 'tween 3/15/2007 14:18'!clearParens	super clearParens.	lastParentLocation := nil! !!OBTextMorphEditorWithShout methodsFor: 'new selection' stamp: 'tween 3/15/2007 14:19'!correctFrom: start to: stop with: aString		view ifNotNil: [view correctFrom: start to: stop with: aString].	^super correctFrom: start to: stop with: aString! !!OBTextMorphEditorWithShout methodsFor: 'backspace handling' stamp: 'tween 3/15/2007 14:16'!userHasEdited	"ignore this if generated during backTo:	See comment in backTo: "	(inBackTo isNil or: [inBackTo not])		ifTrue:[^super userHasEdited]	! !OBTextMorph subclass: #OBTextMorphWithShout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OB-Morphic-Morphs'!!OBTextMorphWithShout methodsFor: 'private' stamp: 'tween 3/15/2007 14:08'!editorClass	"Answer the class used to create the receiver's editor"		^OBTextMorphEditorWithShout! !!OBTextMorphWithShout methodsFor: 'private' stamp: 'tween 3/15/2007 14:25'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ self editorClass new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !OBPanel subclass: #OBTextPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Panels'!!OBTextPanel methodsFor: 'user interface'!addEditingItemsToMenu: aMenu shifted: aBoolean	| items |	items _  aBoolean 		ifTrue: [self shiftedYellowButtonMenu] 		ifFalse: [self yellowButtonMenu].	items do: [:ea |			  ea = #-				ifFalse: [aMenu add: ea first action: ea second]				ifTrue: [aMenu addLine]].! !!OBTextPanel methodsFor: 'user interface'!addMoreToMenu: aMenu	aMenu addLine.	aMenu		add: 'more...' translated		action: #shiftedTextPaneMenuRequest! !!OBTextPanel methodsFor: 'user interface'!addTextCommandsToMenu: aMenu selection: aTextSelection	| scan |	scan _ self announce: OBTextCommandScan.	scan		populateMenu: aMenu		withNodes: {aTextSelection}		forRequestor: self.! !!OBTextPanel methodsFor: 'callbacks'!allowsEditing	^ true! !!OBTextPanel methodsFor: 'callbacks'!isEditable	^ true! !!OBTextPanel methodsFor: 'callbacks'!menu: aMenu shifted: aBoolean selection: aTextSelection 		self addEditingItemsToMenu: aMenu shifted: aBoolean.	self addTextCommandsToMenu: aMenu selection: aTextSelection.	self addMoreToMenu: aMenu.	^ aMenu ! !!OBTextPanel methodsFor: 'callbacks'!perform: aSelector orSendTo: anObject	| receiver |	receiver  _ (self respondsTo: aSelector) ifTrue: [self] ifFalse: [anObject].	receiver perform: aSelector! !!OBTextPanel methodsFor: 'user interface'!shiftedYellowButtonMenu	^ Array streamContents:		[:stream |		stream			nextPut: (Array with: 'explain' translated with: #explain);			nextPut: #-;			nextPut: (Array 						with: 'selectors containing it (W)' translated 						with: #methodNamesContainingIt);			nextPut: (Array 						with: 'method strings with it (E)' translated 						with: #methodStringsContainingit);			nextPut: (Array 						with: 'method source with it' translated 						with: #methodSourceContainingIt);			nextPut: (Array 						with: 'class names containing it' translated 						with: #classNamesContainingIt);			nextPut: (Array 						with: 'class comments with it' translated 						with: #classCommentsContainingIt);			nextPut: (Array 						with: 'change sets with it' translated 						with:  #browseChangeSetsWithSelector);			nextPut: #-;			nextPut: (Array with: 'save contents to file...' translated with: #saveContentsInFile);			nextPut: #-;			nextPut: (Array with: 'more...' translated with: #yellowButtonActivity)]! !!OBTextPanel methodsFor: 'user interface'!yellowButtonMenu	^ Array streamContents:		[:stream |		stream 				nextPut: (Array with: 'find...(f)' translated with: #find);			nextPut: (Array with: 'find again (g)' translated with: #findAgain);			nextPut: (Array with: 'set search string (h)' translated with: #setSearchString);			nextPut: #-;			nextPut: (Array with: 'do again (j)' translated with: #again);			nextPut: (Array with: 'undo (z)' translated with: #undo);			nextPut: #-;			nextPut: (Array with: 'copy (c)' translated with: #copySelection);			nextPut: (Array with: 'cut (x)' translated with: #cut);			nextPut: (Array with: 'paste (v)' translated with: #paste);			nextPut: (Array with: 'paste...' translated with: #pasteRecent);			nextPut: #-;			nextPut: (Array with: 'do it (d)' translated with: #doIt);			nextPut: (Array with: 'print it (p)' translated with: #printIt);			nextPut: (Array with: 'inspect it (i)' translated with: #inspectIt);			nextPut: (Array with: 'explore it (I)' translated with: #exploreIt);			nextPut: (Array with: 'debug it' translated with: #debugIt);			nextPut: #-;			nextPut: (Array with: 'accept (s)' translated with: #accept);			nextPut: (Array with: 'cancel (l)' translated with: #cancel)]! !OBInteractionRequest subclass: #OBTextRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Notifications'!!OBTextRequest commentStamp: 'cwp 3/5/2004 12:35' prior: 0!This notification is used to ask the user to supply a short piece of text. Its defaultAction is to open a FillInTheBlank.iVars:prompt		- a string describing the text the user is asked to supplytemplate	- a default reply !(OBTextRequest instVarNames includes: 'prompt') ifFalse:	[OBTextRequest addInstVarName: 'prompt']!(OBTextRequest instVarNames includes: 'template') ifFalse:	[OBTextRequest addInstVarName: 'template']!!OBTextRequest methodsFor: 'dispatching'!handleWith: anObject	^ anObject handleTextRequest: self! !!OBTextRequest methodsFor: 'accessing'!prompt	^ prompt! !!OBTextRequest methodsFor: 'accessing'!prompt: aString	prompt _ aString! !!OBTextRequest methodsFor: 'accessing'!template	^ template! !!OBTextRequest methodsFor: 'accessing'!template: aString	template _ aString! !!OBTextRequest class methodsFor: 'exceptionInstantiator'!prompt: aString	^ self prompt: aString template: ''! !!OBTextRequest class methodsFor: 'exceptionInstantiator'!prompt: promptString template: templateString	^ (self new prompt: promptString; template: templateString) signal! !OBTextPanel subclass: #OBDefinitionPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Panels'!!OBDefinitionPanel commentStamp: 'cwp 1/7/2005 23:35' prior: 0!OBDefinition serves as the model for the text pane of a typical browser. It's main responsibility is to act as a relay between a PluggableTextMorph and a Definition supplied by the currently selected node.iVars:browser - The browser of which this panel is a part.!(OBDefinitionPanel instVarNames includes: 'definition') ifFalse:	[OBDefinitionPanel addInstVarName: 'definition']!(OBDefinitionPanel instVarNames includes: 'selection') ifFalse:	[OBDefinitionPanel addInstVarName: 'selection']!!OBDefinitionPanel methodsFor: 'updating'!aboutToChange: ann	| ok |	self canDiscardEdits ifTrue: [^ true].	ok := OBConfirmationRequest			prompt: 'Changes have not been saved.Is it OK to discard those changes?'			confirm: 'Discard changes'.	(ok isNil not and: [ok])		ifTrue: [self changed: #clearUserEdits]		ifFalse: [ann veto]! !!OBDefinitionPanel methodsFor: 'updating'!aboutToChangeSilently: ann	self canDiscardEdits ifFalse: [ann veto]! !!OBDefinitionPanel methodsFor: 'callbacks'!accept: aText notifying: aController	^ self 		withDefinitionDo: [:def | [def accept: aText notifying: aController]									on: OBAnnouncerRequest									do: [:notification | notification resume: self announcer]]		ifNil: [true]! !!OBDefinitionPanel methodsFor: '*ob-morphic' stamp: 'dc 8/24/2007 12:34'!addItem: classAndMethod	"Used by the system when the user clicks on a link in a class comment. For example see class comment of SystemProgressMorph and click on displayProgressAt:from:to:during:."	|tokens class methodNode|	tokens := classAndMethod findTokens: Character space.	tokens size ~= 2 ifTrue: [^ self].	class := Smalltalk classNamed: tokens first.	class ifNil: [^ self].	methodNode := OBMethodNode on: tokens second inClass: class.	methodNode browse! !!OBDefinitionPanel methodsFor: 'callbacks'!allowsEditing	^ definition notNil and: [definition allowsEditing]! !!OBDefinitionPanel methodsFor: 'building'!buildOn: aBuilder 	^aBuilder textarea: self with: []! !!OBDefinitionPanel methodsFor: 'accessing'!definition: aDefinition	definition := aDefinition.	selection := nil.	self changed: #text! !!OBDefinitionPanel methodsFor: 'updating'!definitionChanged: ann	definition _ ann definition.	self changed: #text! !!OBDefinitionPanel methodsFor: 'callbacks'!doItContext	^ self 		withDefinitionDo: [:def | (def respondsTo: #doItContext) ifTrue: [def doItContext]]		ifNil: [nil]! !!OBDefinitionPanel methodsFor: 'callbacks'!doItReceiver	^ self 		withDefinitionDo: [:def | (def respondsTo: #doItReceiver) ifTrue: [def doItReceiver]]		ifNil: [nil]! !!OBDefinitionPanel methodsFor: 'accessing'!environment	^ self selectedClass environment! !!OBDefinitionPanel methodsFor: 'accessing'!getDefinition	^ browser currentNode ifNotNilDo: [:n | n definition]! !!OBDefinitionPanel methodsFor: 'callbacks'!isEditable	^ definition notNil and: [definition isEditable]! !!OBDefinitionPanel methodsFor: 'accessing'!node: aNode	node _ aNode.	self definition: (aNode ifNotNil: [aNode definition])! !!OBDefinitionPanel methodsFor: 'updating'!nodeChanged: ann	node = ann node ifTrue: [self node: ann node]! !!OBDefinitionPanel methodsFor: 'updating'!refresh: announcement	| oldDefinition |	definition ifNil: [^ self].	oldDefinition _ definition.	definition _ self getDefinition ifNil: [oldDefinition].	definition text = oldDefinition text ifTrue: [^ self].	self canDiscardEdits			ifTrue: [self changed: #text]			ifFalse: [self changed: #codeChangedElsewhere]! !!OBDefinitionPanel methodsFor: 'callbacks'!selectedClass	^ self 		withDefinitionDo: [:def | (def respondsTo: #selectedClass) ifTrue: [def selectedClass]] 		ifNil: [nil]! !!OBDefinitionPanel methodsFor: 'callbacks'!selection	^ selection ifNil: [ selection := self withDefinitionDo: [ :def | def textSelection ] ifNil: [ 1 to: 0 ] ]! !!OBDefinitionPanel methodsFor: 'callbacks'!selection: anInterval	selection := anInterval.	self changed: #selection! !!OBDefinitionPanel methodsFor: 'updating'!selectionChanged: ann	self node: ann column selectedNode! !!OBDefinitionPanel methodsFor: '*OB-Morphic-Shout' stamp: 'tween 4/24/2007 16:50'!shoutAboutToStyle: aPluggableShoutMorph	|  node classOrMetaClass |	node := browser currentNode.	((node isKindOf: OBMethodNode) or: [(node isKindOf: OBMethodVersionNode) or:[node isKindOf: OBMethodCategoryNode]])		ifTrue:[			classOrMetaClass := node theClass.			(classOrMetaClass isBehavior or:[classOrMetaClass isTrait]) ifFalse:[classOrMetaClass := nil].			aPluggableShoutMorph classOrMetaClass: classOrMetaClass. 			^true].	((node isKindOf: OBClassNode) or:[(node isKindOf: OBClassCategoryNode)]) 		ifTrue:[			aPluggableShoutMorph classOrMetaClass: nil.			^true].	^false! !!OBDefinitionPanel methodsFor: 'updating'!subscribe	self announcer 		observe: OBAboutToChange		send: #aboutToChange:		to: self;				observe: OBAboutToChangeSilently		send: #aboutToChangeSilently:		to: self;				observe: OBSelectionChanged		send: #selectionChanged:		to: self;						observe: OBNodeChanged		send: #nodeChanged:		to: self;								observe: OBRefreshRequired		send: #refresh:		to: self;							observe: OBDefinitionChanged		send: #definitionChanged: 		to: self.! !!OBDefinitionPanel methodsFor: 'callbacks'!text	^ self withDefinitionDo: [:def | def text] ifNil: ['']! !!OBDefinitionPanel methodsFor: 'accessing'!vResizing	^ #spaceFill! !!OBDefinitionPanel methodsFor: 'accessing'!withDefinitionDo: workBlock ifNil: nilBlock	definition ifNil: [ ^ nilBlock value].	^ workBlock value: definition! !OBCommandScan subclass: #OBNodeCommandScan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!OBCommandScan subclass: #OBTextCommandScan	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OmniBrowser-Announcements'!OBMorphicIcons initialize!OBScrollBar initialize!