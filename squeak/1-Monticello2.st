"Release-cwp.30timestamp: 22 November 2008 3:37:55 pmauthor: 'Colin Putney <cputney@wiresong.ca>'Added an icon to the project slice. Refactored the serialization code for better portability. Added explicit #initialize messages for portability to VWRemoved extension conflicts with Seaside."!SharedPool subclass: #MDBogusPoolA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!SharedPool subclass: #MDBogusPoolB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!!Array methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	self class = Array 		ifTrue: [ aSerializer serializeArray: self ]		ifFalse: [ super mdSerializeWith: aSerializer ]! !!Boolean methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeSingleton: self! !!String methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeUtf8String: self! !!Class methodsFor: '*mc2-squeak' stamp: 'cwp 5/20/2008 20:05'!instanceVariableNames: nameString 	ClassBuilder new 		name: self name		inEnvironment: self environment		subclassOf: self superclass		type: self typeOfClass		instanceVariableNames: nameString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeClass: self! !!Class methodsFor: '*mc2-squeak' stamp: 'cwp 5/21/2008 19:07'!poolImportNames	^ self sharedPools collect: [:ea | self environment keyAtIdentityValue: ea]! !!Collection methodsFor: '*mc2-squeak' stamp: 'cwp 8/26/2005 21:58'!disjoin: aCollection	^ (self union: aCollection) difference: (self intersection: aCollection)! !!Dictionary methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	^ aSerializer serializeDictionary: self! !!Integer methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeInteger: self! !TestCase subclass: #MDAdaptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDAdaptionTest instVarNames includes: 'proxy') ifFalse:	[MDAdaptionTest addInstVarName: 'proxy']!!MDAdaptionTest methodsFor: 'constants' stamp: 'cwp 3/4/2008 22:39'!adaptorSelectors	^ #(isPresent isUpToDate: load: remove update: merge:into:onFailure:)! !!MDAdaptionTest methodsFor: 'configuration' stamp: 'cwp 3/2/2006 17:32'!proxyClass	self subclassResponsibility! !!MDAdaptionTest methodsFor: 'running' stamp: 'cwp 2/6/2005 22:37'!setUp	proxy := self proxyClass new! !!MDAdaptionTest methodsFor: 'constructing' stamp: 'cwp 3/15/2005 22:22'!slice	^ MDExplicitSlice named: 'Foo'! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 2/12/2005 13:59'!testClassComment	self tryAdapting: (MDClassCommentElement className: #MDBogusA)! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 2/6/2005 22:26'!testClassElement	self tryAdapting: (MDClassElement className: #MDBogusA)! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 3/4/2005 14:43'!testClassInstVarElement	self tryAdapting: (MDClassInstVarElement className: #MDBogusA name: 'beth')! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 2/6/2005 22:29'!testClassVarElement	self tryAdapting: (MDClassVarElement className: #MDBogusA name: 'Beta')! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 2/6/2005 22:27'!testInstVarElement	self tryAdapting: (MDInstVarElement className: #MDBogusA name: 'one')! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 2/6/2005 22:26'!testMethodElement	self tryAdapting: (MDMethodElement className: #MDBogusA selector: #method1)! !!MDAdaptionTest methodsFor: 'tests' stamp: 'cwp 4/28/2008 22:04'!testPoolImportElement	self tryAdapting: (MDPoolImportElement 			className: #MDBogusA			name: #MDBogusPoolB)! !!MDAdaptionTest methodsFor: 'running' stamp: 'cwp 2/6/2005 22:26'!tryAdapting: anElement	| adaptor |	adaptor := anElement adaptedFor: proxy.	self adaptorSelectors do: [:ea | self assert: (adaptor respondsTo: ea)].! !!MDAdaptionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 2/6/2005 22:33'!isAbstract	^ self name = #MDAdaptionTest! !TestCase subclass: #MDAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!(MDAdaptorTest instVarNames includes: 'system') ifFalse:	[MDAdaptorTest addInstVarName: 'system']!!MDAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 14:43'!adaptor	^ self adaptorForElement: self element! !!MDAdaptorTest methodsFor: 'constructing' stamp: 'cwp 3/2/2006 18:05'!adaptorClass	self subclassResponsibility! !!MDAdaptorTest methodsFor: 'constructing' stamp: 'cwp 12/1/2005 22:17'!adaptorForElement: anElement	^ self adaptorClass forElement: anElement inSystem: self system! !!MDAdaptorTest methodsFor: 'accessing' stamp: 'cwp 2/6/2005 22:49'!bogusClass	^ MDBogusA! !!MDAdaptorTest methodsFor: 'configuration' stamp: 'cwp 3/23/2005 00:03'!canBeUnloadable	^ true! !!MDAdaptorTest methodsFor: 'configuration' stamp: 'cwp 3/2/2006 18:12'!displayString	^ self properties asString! !!MDAdaptorTest methodsFor: 'running' stamp: 'cwp 2/1/2006 21:20'!editDuring: aBlock	aBlock value.	system commit.! !!MDAdaptorTest methodsFor: 'properties' stamp: 'cwp 11/17/2007 01:25'!initials	^ self stamp copyUpTo: $ ! !!MDAdaptorTest methodsFor: 'accessing' stamp: 'cwp 2/12/2005 14:48'!propertyToChange	self subclassResponsibility! !!MDAdaptorTest methodsFor: 'running' stamp: 'cwp 8/3/2008 22:14'!runCase	MDAnnouncer isolate: [super runCase]! !!MDAdaptorTest methodsFor: 'running' stamp: 'cwp 5/22/2008 00:13'!setUp	system := MDPlatform current systemEditor! !!MDAdaptorTest methodsFor: 'constructing' stamp: 'cwp 12/3/2005 23:00'!system	^ system! !!MDAdaptorTest methodsFor: 'running' stamp: 'cwp 2/5/2005 20:53'!tearDown	self destroyObject! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 2/15/2005 14:45'!testIsLoadable	self assert: (self adaptor isLoadable: self properties)! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 2/5/2005 20:42'!testIsPresent	self createObject.	self assert: self adaptor isPresent! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 13:22'!testIsUnloadable	| adaptor |	self canBeUnloadable ifTrue: 		[ adaptor := self adaptorForElement: self unloadableElement.		self deny: (adaptor isLoadable: self properties) ]! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 3/23/2005 00:10'!testIsUpToDate	self createObject.	self assert: (self adaptor isUpToDate: self properties)! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 12/11/2005 22:48'!testLoad	self editDuring: [self adaptor load: self properties].	self assertObjectHasDefaultProperties! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 2/5/2005 21:07'!testNotPresent	self deny: self adaptor isPresent! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 2/12/2005 14:41'!testNotUpToDate	| properties |	self propertyToChange ifNil: [^ self].	self createObject.	properties := self properties.	properties at: self propertyToChange put: self changedValue.	self deny: (self adaptor isUpToDate: properties)! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 12/3/2005 23:14'!testRemove	self createObject.	self editDuring: [self adaptor remove].	self deny: self objectIsPresent! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 12/3/2005 23:16'!testRemoveNotPresent	self editDuring: [self adaptor remove].	self deny: self objectIsPresent! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 13:23'!testUnloadableNotPresent	| adaptor |	self canBeUnloadable ifTrue: 		[ adaptor := self adaptorForElement: self unloadableElement.		self deny: adaptor isPresent ]! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 12/11/2005 10:43'!testUpdate	| properties |	self createObject.	properties := MDPropertyDictionary new.	self editDuring: [self adaptor update: properties].	self assert: properties = self properties! !!MDAdaptorTest methodsFor: 'tests' stamp: 'cwp 12/3/2005 23:17'!testUpdateSideEffects	| properties |	self createObject.	properties := MDPropertyDictionary new.	self editDuring: [self adaptor update: properties].	self assertObjectHasDefaultProperties! !!MDAdaptorTest methodsFor: 'properties' stamp: 'cwp 4/9/2005 01:54'!timeStamp	^ MDTimestamp fromSqueakMethodStamp: self stamp! !!MDAdaptorTest methodsFor: 'configuration' stamp: 'cwp 2/15/2005 15:56'!unloadableElement	self subclassResponsibility! !!MDAdaptorTest class methodsFor: 'as yet unclassified' stamp: 'cwp 2/6/2005 11:53'!isAbstract	^ self name = #MDAdaptorTest! !!MDAdaptorTest class methodsFor: 'as yet unclassified' stamp: 'cwp 2/5/2005 21:40'!shouldInheritSelectors	^ true! !Object subclass: #MDAnnouncement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!TestCase subclass: #MDAnnouncementTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDAnnouncementTest instVarNames includes: 'element') ifFalse:	[MDAnnouncementTest addInstVarName: 'element']!(MDAnnouncementTest instVarNames includes: 'project') ifFalse:	[MDAnnouncementTest addInstVarName: 'project']!(MDAnnouncementTest instVarNames includes: 'slice') ifFalse:	[MDAnnouncementTest addInstVarName: 'slice']!(MDAnnouncementTest instVarNames includes: 'received') ifFalse:	[MDAnnouncementTest addInstVarName: 'received']!!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:19'!runCase	MDAnnouncer isolate: [super runCase]! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 21:01'!setUp	element := MDMethodElement 		className: #MDBogusA		selector: #griffle.	project := MDProject forTesting.	slice := MDExplicitSlice forTesting.	slice addElement: element.	project addSlice: slice.	project subscribe! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 20:24'!subscribeTo: aClass 	MDAnnouncer default 		observe: aClass		do: [ :ann | received := ann ]! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:35'!testAdded	MDAnnouncer announce: (MDElementAdded for: element).	self assert: (project isDirty: slice)! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 21:43'!testDirty	self subscribeTo: MDSliceDirty.	MDAnnouncer announce: (MDElementAdded for: element).	self deny: received isNil.	self assert: received slice = slice! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:36'!testModified	MDAnnouncer announce: (MDElementModified for: element).	self assert: (project isDirty: slice)! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 22:23'!testProjectRenamed		self subscribeTo: MDElementModified.	project name: 'someOtherProject'.	self assert: (received isKindOf: MDElementModified).	self assert: received element id = project id.	! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:35'!testRemoved	MDAnnouncer announce: (MDElementRemoved for: element).	self assert: (project isDirty: slice)! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 21:05'!testRepositoryAdded	| repository |	self subscribeTo: MDElementAdded.	repository := MDMemoryRepository named: 'anotherTest'.	project addRepository: repository.	self assert: (received isKindOf: MDElementAdded).	self assert: received element projectId = project id.	self assert: received element repositoryId = repository id.! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 21:07'!testRepositoryRemoved		| repository |	repository := MDMemoryRepository forTesting.	project addRepository: repository.	self subscribeTo: MDElementRemoved.	project removeRepository: repository.	self assert: (received isKindOf: MDElementRemoved).	self assert: received element projectId = project id.	self assert: received element repositoryId = repository id.! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 20:38'!testSliceAdded	| anotherSlice |	self subscribeTo: MDElementAdded.	anotherSlice := MDExplicitSlice named: 'anotherTest'.	project addSlice: anotherSlice.	self assert: (received isKindOf: MDElementAdded).	self assert: received element projectId = project id.	self assert: received element sliceId = anotherSlice id.! !!MDAnnouncementTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 21:02'!testSliceRemoved		self subscribeTo: MDElementRemoved.	project removeSlice: slice.	self assert: (received isKindOf: MDElementRemoved).	self assert: received element projectId = project id.	self assert: received element sliceId = slice id.! !Object subclass: #MDAnnouncer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!!MDAnnouncer commentStamp: 'cwp 7/28/2008 07:06' prior: 0!This is copied from OmniBrowser. This should be factored out into a separate library that's used by both, but hey, it's only a handful of methods. !(MDAnnouncer instVarNames includes: 'subscriptions') ifFalse:	[MDAnnouncer addInstVarName: 'subscriptions']!!MDAnnouncer methodsFor: 'subscription' stamp: 'cwp 7/27/2008 20:29'!announce: anObject	| ann |	ann _ anObject asAnnouncement.	subscriptions keysAndValuesDo:		[:class :action |		(ann isKindOf: class) ifTrue: [action valueWithArguments: (Array with: ann)]].	^ ann! !!MDAnnouncer methodsFor: 'initialize-release' stamp: 'cwp 7/27/2008 20:29'!initialize	subscriptions _ IdentityDictionary new.! !!MDAnnouncer methodsFor: 'subscription' stamp: 'cwp 7/27/2008 20:29'!observe: aClass do: aValuable 	| actions |	actions _ subscriptions at: aClass ifAbsent: [ActionSequence new].	subscriptions at: aClass put: (actions copyWith: aValuable).! !!MDAnnouncer methodsFor: 'subscription' stamp: 'cwp 7/27/2008 20:29'!observe: aClass send: aSelector to: anObject	self		observe: aClass		do: (MessageSend receiver: anObject selector: aSelector)! !!MDAnnouncer methodsFor: 'accessing' stamp: 'cwp 8/3/2008 22:53'!subscribers	^ subscriptions		inject: IdentitySet new		into: 			[:subscribers :actions | 			actions do: [:ea | subscribers add: ea receiver]. 			subscribers]! !!MDAnnouncer methodsFor: 'subscription' stamp: 'cwp 7/27/2008 20:29'!unsubscribe: anObject	subscriptions keysAndValuesDo:		[:class :actions |		subscriptions at: class put: (actions reject: [:ea | ea receiver == anObject])].	subscriptions keysAndValuesRemove: [:key :value | value isEmpty]! !(MDAnnouncer class instVarNames includes: 'default') ifFalse:	[MDAnnouncer class addInstVarName: 'default']!!MDAnnouncer class methodsFor: 'announcing' stamp: 'cwp 7/28/2008 07:29'!announce: anAnnouncement	self default announce: anAnnouncement! !!MDAnnouncer class methodsFor: 'instance creation' stamp: 'cwp 7/28/2008 07:09'!default	^ default ifNil: [default := self new]! !!MDAnnouncer class methodsFor: 'testing' stamp: 'cwp 7/28/2008 07:15'!isolate: aBlock	| old |	old := default.	[default := self new.	aBlock value]		ensure: [default := old]! !!MDAnnouncer class methodsFor: 'instance creation' stamp: 'cwp 7/27/2008 20:29'!new	^ self basicNew initialize! !Object subclass: #MDAuthorInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakPlatform'!(MDAuthorInfo classVarNames includes: 'MDAuthor') ifFalse:	[MDAuthorInfo addClassVarName: 'MDAuthor']!(MDAuthorInfo classVarNames includes: 'MDLastImageName') ifFalse:	[MDAuthorInfo addClassVarName: 'MDLastImageName']!!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 12/28/2007 21:23'!initialize	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 12/28/2007 21:09'!prompt	^ ' Please enter you name and email address for Monticello2 '! !!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:10'!shutDown	MDLastImageName := Smalltalk imageName! !!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:10'!startUp	MDLastImageName = Smalltalk imageName ifFalse: [ MDAuthor := nil ]! !!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:09'!value	^ MDAuthor ifNil: 		[ MDAuthor := MDPlatform current 			prompt: self prompt			default: '' ]! !!MDAuthorInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:09'!value: aString 	"Set the name and email address of the user of the system."	MDAuthor := aString! !Object subclass: #MDBogusA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!(MDBogusA instVarNames includes: 'one') ifFalse:	[MDBogusA addInstVarName: 'one']!(MDBogusA classVarNames includes: 'MDAlpha') ifFalse:	[MDBogusA addClassVarName: 'MDAlpha']!(MDBogusA sharedPools includes: MDBogusPoolA) ifFalse:	[MDBogusA addSharedPool: MDBogusPoolA]!(MDBogusA sharedPools includes: TextConstants) ifFalse:	[MDBogusA addSharedPool: TextConstants]!(MDBogusA class instVarNames includes: 'aleph') ifFalse:	[MDBogusA class addInstVarName: 'aleph']!TestResource subclass: #MDBogusRepositoryResource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDBogusRepositoryResource instVarNames includes: 'repository') ifFalse:	[MDBogusRepositoryResource addInstVarName: 'repository']!!MDBogusRepositoryResource methodsFor: 'as yet unclassified' stamp: 'cwp 5/7/2008 08:20'!contents	^ MDMarshal materialize: #(17 9 40 23 5 9 5 21 52 210 77 14 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 65 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 10 66 111 103 117 115 45 66 97 115 101 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 22 115 101 110 100 115 83 101 110 100 115 65 99 99 101 115 115 101 115 73 118 97 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 115 101 110 100 101 114 115 14 9 6 115 111 117 114 99 101 15 9 46 115 101 110 100 115 83 101 110 100 115 65 99 99 101 115 115 101 115 73 118 97 114 13 9 115 101 108 102 32 115 101 110 100 115 65 99 99 101 115 115 101 115 73 118 97 114 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 11 14 9 6 66 111 103 117 115 66 15 9 23 115 101 99 111 110 100 73 110 115 116 97 110 99 101 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 3 111 110 101 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 110 117 109 98 101 114 115 14 9 6 115 111 117 114 99 101 15 9 8 111 110 101 13 9 94 32 49 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 67 14 9 12 104 97 115 84 105 109 101 115 116 97 109 112 8 20 9 4 14 9 8 99 97 116 101 103 111 114 121 14 9 7 116 101 115 116 105 110 103 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 6 115 111 117 114 99 101 15 9 20 104 97 115 84 105 109 101 115 116 97 109 112 13 9 94 32 116 114 117 101 14 9 9 116 105 109 101 83 116 97 109 112 21 45 159 254 52 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 12 97 99 99 101 115 115 101 115 73 118 97 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 9 97 99 99 101 115 115 105 110 103 14 9 6 115 111 117 114 99 101 15 9 38 97 99 99 101 115 115 101 115 73 118 97 114 13 9 94 32 102 105 114 115 116 73 110 115 116 97 110 99 101 86 97 114 105 97 98 108 101 66 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 11 14 9 6 66 111 103 117 115 66 15 9 22 102 105 114 115 116 73 110 115 116 97 110 99 101 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 1 97 7 20 9 4 14 9 8 99 97 116 101 103 111 114 121 14 9 8 99 97 112 105 116 97 108 115 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 6 115 111 117 114 99 101 15 9 7 97 13 9 94 32 36 66 14 9 9 116 105 109 101 83 116 97 109 112 21 49 17 69 60 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 69 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 10 66 111 103 117 115 45 66 97 115 101 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 66 111 103 117 115 65 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 67 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 10 66 111 103 117 115 45 66 97 115 101 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 16 97 99 99 101 115 115 101 115 67 86 97 114 65 108 115 111 7 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 9 97 99 99 101 115 115 105 110 103 14 9 6 115 111 117 114 99 101 15 9 39 97 99 99 101 115 115 101 115 67 86 97 114 65 108 115 111 13 9 94 32 70 105 114 115 116 67 108 97 115 115 86 97 114 105 97 98 108 101 66 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 1 98 7 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 8 99 97 112 105 116 97 108 115 14 9 6 115 111 117 114 99 101 15 9 7 98 13 9 94 32 36 66 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 13 14 9 6 66 111 103 117 115 66 15 9 28 115 101 99 111 110 100 67 108 97 115 115 73 110 115 116 97 110 99 101 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 74 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 13 66 111 103 117 115 45 70 111 114 109 97 116 115 14 9 6 102 111 114 109 97 116 14 9 4 119 101 97 107 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 19 105 115 67 111 109 112 108 101 116 101 108 121 85 115 101 108 101 115 115 7 20 9 4 14 9 8 99 97 116 101 103 111 114 121 14 9 7 116 101 115 116 105 110 103 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 6 115 111 117 114 99 101 15 9 27 105 115 67 111 109 112 108 101 116 101 108 121 85 115 101 108 101 115 115 13 9 94 32 116 114 117 101 14 9 9 116 105 109 101 83 116 97 109 112 21 49 17 70 104 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 28 98 111 103 117 115 72 111 112 101 102 117 108 108 121 85 110 105 113 117 101 83 101 108 101 99 116 111 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 5 111 116 104 101 114 14 9 6 115 111 117 114 99 101 15 9 59 98 111 103 117 115 72 111 112 101 102 117 108 108 121 85 110 105 113 117 101 83 101 108 101 99 116 111 114 13 9 115 101 108 102 32 98 111 103 117 115 79 116 104 101 114 85 110 105 113 117 101 83 101 108 101 99 116 111 114 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 4 102 105 118 101 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 110 117 109 98 101 114 115 14 9 6 115 111 117 114 99 101 15 9 29 102 105 118 101 13 9 94 32 115 101 108 102 32 116 119 111 32 43 32 115 101 108 102 32 116 104 114 101 101 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 71 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 13 66 111 103 117 115 45 70 111 114 109 97 116 115 14 9 6 102 111 114 109 97 116 14 9 5 98 121 116 101 115 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 3 102 111 111 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 9 97 99 99 101 115 115 105 110 103 14 9 6 115 111 117 114 99 101 15 9 11 102 111 111 13 9 94 32 115 101 108 102 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 8 105 115 83 116 114 105 110 103 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 5 111 116 104 101 114 14 9 6 115 111 117 114 99 101 15 9 17 105 115 83 116 114 105 110 103 13 9 94 32 102 97 108 115 101 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 12 14 9 6 66 111 103 117 115 66 14 9 19 70 105 114 115 116 67 108 97 115 115 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 14 14 9 6 66 111 103 117 115 66 14 9 9 66 111 103 117 115 80 111 111 108 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 70 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 13 66 111 103 117 115 45 70 111 114 109 97 116 115 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 5 116 104 114 101 101 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 110 117 109 98 101 114 115 14 9 6 115 111 117 114 99 101 15 9 10 116 104 114 101 101 13 9 94 32 51 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 12 14 9 6 66 111 103 117 115 66 14 9 20 83 101 99 111 110 100 67 108 97 115 115 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 10 14 9 6 66 111 103 117 115 65 20 9 3 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 4 116 101 120 116 15 9 18 67 111 109 109 101 110 116 32 102 111 114 32 66 111 103 117 115 65 14 9 9 116 105 109 101 83 116 97 109 112 21 45 155 232 228 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 3 116 119 111 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 110 117 109 98 101 114 115 14 9 6 115 111 117 114 99 101 15 9 8 116 119 111 13 9 94 32 50 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 1 98 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 108 101 116 116 101 114 115 14 9 6 115 111 117 114 99 101 15 9 7 98 13 9 94 32 36 66 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 24 98 111 103 117 115 79 116 104 101 114 85 110 105 113 117 101 83 101 108 101 99 116 111 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 5 111 116 104 101 114 14 9 6 115 111 117 114 99 101 15 9 32 98 111 103 117 115 79 116 104 101 114 85 110 105 113 117 101 83 101 108 101 99 116 111 114 13 9 94 32 115 101 108 102 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 9 66 111 103 117 115 80 111 111 108 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 11 66 111 103 117 115 45 80 111 111 108 115 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 10 83 104 97 114 101 100 80 111 111 108 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 12 97 99 99 101 115 115 101 115 67 86 97 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 9 97 99 99 101 115 115 105 110 103 14 9 6 115 111 117 114 99 101 15 9 35 97 99 99 101 115 115 101 115 67 86 97 114 13 9 94 32 70 105 114 115 116 67 108 97 115 115 86 97 114 105 97 98 108 101 66 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 1 97 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 108 101 116 116 101 114 115 14 9 6 115 111 117 114 99 101 15 9 7 97 13 9 94 32 36 65 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 72 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 13 66 111 103 117 115 45 70 111 114 109 97 116 115 14 9 6 102 111 114 109 97 116 14 9 8 118 97 114 105 97 98 108 101 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 66 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 10 66 111 103 117 115 45 66 97 115 101 14 9 6 102 111 114 109 97 116 14 9 6 110 111 114 109 97 108 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 9 14 9 6 66 111 103 117 115 73 20 9 3 14 9 8 99 97 116 101 103 111 114 121 14 9 13 66 111 103 117 115 45 70 111 114 109 97 116 115 14 9 6 102 111 114 109 97 116 14 9 5 119 111 114 100 115 14 9 14 115 117 112 101 114 99 108 97 115 115 78 97 109 101 14 9 6 79 98 106 101 99 116 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 65 14 9 19 98 111 103 117 115 85 110 115 101 110 116 83 101 108 101 99 116 111 114 8 20 9 4 14 9 8 99 97 116 101 103 111 114 121 14 9 5 111 116 104 101 114 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 6 115 111 117 114 99 101 15 9 27 98 111 103 117 115 85 110 115 101 110 116 83 101 108 101 99 116 111 114 13 9 94 32 115 101 108 102 14 9 9 116 105 109 101 83 116 97 109 112 21 50 96 25 84 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 15 14 9 6 66 111 103 117 115 66 14 9 17 115 101 110 100 115 65 99 99 101 115 115 101 115 73 118 97 114 8 20 9 2 14 9 8 99 97 116 101 103 111 114 121 14 9 7 115 101 110 100 101 114 115 14 9 6 115 111 117 114 99 101 15 9 36 115 101 110 100 115 65 99 99 101 115 115 101 115 73 118 97 114 13 9 115 101 108 102 32 97 99 99 101 115 115 101 115 73 118 97 114 18 9 0 23 5 9 5 21 52 210 77 15 1 5 9 2 1 5 9 13 14 9 6 66 111 103 117 115 66 15 9 27 102 105 114 115 116 67 108 97 115 115 73 110 115 116 97 110 99 101 86 97 114 105 97 98 108 101 66 20 9 0 18 9 0 23 5 9 6 21 53 3 166 54 1 2 14 9 17 79 114 100 101 114 101 100 67 111 108 108 101 99 116 105 111 110 9 3 15 9 5 97 114 114 97 121 15 9 10 102 105 114 115 116 73 110 100 101 120 15 9 9 108 97 115 116 73 110 100 101 120 17 9 38 22 52 210 77 15 227 134 126 137 114 67 191 74 119 174 92 48 210 21 245 254 143 62 105 40 22 52 210 77 15 197 195 43 232 22 50 123 224 245 26 15 16 141 187 79 155 117 152 199 192 22 52 210 77 15 156 230 26 244 188 62 202 158 247 25 231 63 8 40 121 116 55 126 150 176 22 52 210 77 14 240 206 23 234 227 147 202 240 30 206 111 181 227 145 175 49 39 93 243 56 22 52 210 77 15 241 4 93 97 162 50 33 36 250 229 93 95 47 133 81 84 195 195 121 215 22 52 210 77 15 91 110 45 164 247 88 92 113 27 242 220 243 51 0 97 114 163 186 65 30 22 52 210 77 15 54 6 90 172 178 254 141 74 197 32 144 204 200 171 94 121 212 96 4 234 22 52 210 77 15 86 94 85 78 25 148 149 208 5 157 74 6 85 232 86 176 112 143 164 150 22 52 210 77 15 245 226 252 67 241 163 103 50 86 244 195 222 234 241 0 68 33 30 91 233 22 52 210 77 15 48 216 116 124 105 112 60 39 143 161 193 161 252 214 229 89 11 8 246 43 22 52 210 77 15 30 61 47 165 3 51 55 109 122 233 82 191 92 104 154 134 17 136 10 15 22 52 210 77 15 237 23 253 162 29 138 89 188 76 225 250 129 184 197 81 165 91 236 180 253 22 52 210 77 15 95 196 58 231 212 161 243 187 27 82 209 183 38 65 41 78 98 180 254 109 22 52 210 77 15 101 44 20 47 97 154 187 229 36 26 93 158 61 12 106 1 148 7 43 151 22 52 210 77 15 212 1 74 7 67 152 252 51 105 117 37 77 212 117 89 138 172 252 116 174 22 52 210 77 15 34 53 212 217 190 138 204 223 250 252 189 7 138 72 243 5 21 237 162 237 22 52 210 77 15 126 154 11 79 117 121 136 127 197 122 206 55 110 180 226 45 105 170 76 213 22 52 210 77 15 197 154 79 84 62 119 38 51 238 141 221 74 126 121 81 53 58 67 148 14 22 52 210 77 15 111 12 141 225 207 112 90 155 1 244 85 247 212 149 124 217 88 169 20 99 22 52 210 77 15 136 173 117 202 66 21 197 146 209 236 35 252 27 76 39 65 19 247 190 108 22 52 210 77 15 95 120 28 4 255 206 94 42 72 84 23 25 198 224 182 222 175 157 114 122 22 52 210 77 15 151 45 209 176 248 53 21 209 34 234 75 205 219 212 83 237 119 86 228 114 22 52 210 77 15 81 23 3 185 148 201 113 42 201 226 47 76 119 129 186 53 19 200 216 105 22 52 210 77 15 40 25 217 227 136 185 157 229 108 225 60 127 80 221 10 21 85 192 106 4 22 52 210 77 15 176 235 75 91 215 16 75 173 214 245 65 27 153 6 239 227 97 91 133 55 22 52 210 77 15 147 152 52 232 62 169 227 6 22 62 219 230 246 149 90 10 114 32 105 239 22 52 210 77 15 156 61 130 18 165 74 205 194 171 45 14 47 150 106 112 60 12 102 96 48 22 52 210 77 15 206 49 150 74 1 188 237 29 203 80 229 192 185 193 27 249 34 205 18 176 22 52 210 77 15 65 74 250 17 76 5 123 51 57 4 1 96 227 77 211 244 36 172 98 2 22 52 210 77 15 40 191 69 74 157 232 86 142 94 1 105 80 105 152 203 105 104 146 49 73 22 52 210 77 15 106 141 31 91 50 122 35 22 226 32 169 70 107 139 112 201 181 199 25 185 22 52 210 77 15 110 43 177 168 248 163 70 92 0 114 94 100 177 74 25 112 132 101 174 188 22 52 210 77 15 77 40 46 148 145 113 48 18 32 143 248 3 81 175 11 111 146 189 224 197 22 52 210 77 15 241 100 164 58 113 49 174 11 198 233 210 37 86 118 210 87 208 208 217 133 22 52 210 77 15 247 220 65 63 123 137 22 208 226 31 103 79 200 179 225 45 101 40 20 74 22 52 210 77 15 162 1 206 249 253 193 135 119 141 162 38 36 40 205 159 5 203 57 249 93 22 52 210 77 15 75 36 105 163 106 127 221 157 106 198 49 201 198 129 74 76 143 107 41 30 22 52 210 77 15 95 226 146 6 54 26 163 168 121 216 14 76 238 114 192 120 163 0 126 182 9 1 9 38 23 5 9 7 21 53 3 166 54 22 53 3 166 54 241 240 140 231 242 67 241 193 71 101 105 189 7 35 37 37 201 40 152 20 17 9 0 20 9 5 14 9 6 97 117 116 104 111 114 15 9 34 67 111 108 105 110 32 80 117 116 110 101 121 32 60 99 112 117 116 110 101 121 64 119 105 114 101 115 111 110 103 46 99 97 62 14 9 7 99 111 109 109 101 110 116 15 9 21 83 110 97 112 115 104 111 116 32 102 111 114 32 116 101 115 116 105 110 103 46 14 9 8 105 110 105 116 105 97 108 115 15 9 3 99 119 112 14 9 7 111 114 100 105 110 97 108 9 1 14 9 9 115 108 105 99 101 78 97 109 101 15 9 5 66 111 103 117 115 22 0 0 0 0 78 149 30 110 111 68 98 51 59 230 212 62 130 88 246 4 77 50 78 124)! !!MDBogusRepositoryResource methodsFor: 'as yet unclassified' stamp: 'cwp 4/7/2008 23:34'!fileout	| out exporter memo |	out := WriteStream on: String new.	exporter := MDFileOutExporter on: out.	memo := repository memos anyOne.	exporter export: memo from: repository.	^ out contents! !!MDBogusRepositoryResource methodsFor: 'as yet unclassified' stamp: 'cwp 3/23/2008 23:48'!repository	^ repository! !!MDBogusRepositoryResource methodsFor: 'as yet unclassified' stamp: 'cwp 4/30/2008 06:54'!setUp		repository := MDMemoryRepository new.	repository putAll: self contents! !!MDBogusRepositoryResource methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!tearDown	repository := nil! !!MDBogusRepositoryResource class methodsFor: 'as yet unclassified' stamp: 'cwp 4/18/2008 08:06'!compileContents: aSet	 | source |	source := String streamContents:		[:stream |		stream 			nextPutAll: 'contents';			crtab;			nextPutAll: '^ MDMarshal materialize: #('.		(MDMarshal serialize: aSet)			do: [:b | stream print: b] separatedBy: [stream space].		stream nextPut: $)].		self compile: source ! !!MDBogusRepositoryResource class methodsFor: 'as yet unclassified' stamp: 'cwp 5/7/2008 08:20'!recompile	| versions snapshot properties memo objects |	versions := self new setUp repository versions select:		[:object | object class = MDElementVersion].	versions := versions asSet.	snapshot := MDSnapshot withVersions: versions.	properties := MDPropertyDictionary new		author: 'Colin Putney <cputney@wiresong.ca>';		comment: 'Snapshot for testing.';		initials: 'cwp';			ordinal: 1;		sliceName: 'Bogus';		yourself.	memo := MDMemo snapshot: snapshot slice: (MDPackageInfoSlice named: 'Bogus') parents: #() properties: properties.	objects := versions, {snapshot. memo}.	self compileContents: (objects asArray sort: [:a :b | a hashstamp <= b hashstamp])! !Object subclass: #MDByteIndex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-File'!(MDByteIndex instVarNames includes: 'keySize') ifFalse:	[MDByteIndex addInstVarName: 'keySize']!(MDByteIndex instVarNames includes: 'valueSize') ifFalse:	[MDByteIndex addInstVarName: 'valueSize']!(MDByteIndex instVarNames includes: 'streamSize') ifFalse:	[MDByteIndex addInstVarName: 'streamSize']!(MDByteIndex instVarNames includes: 'stream') ifFalse:	[MDByteIndex addInstVarName: 'stream']!!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/13/2005 03:36'!at: keyArray	^ self at: keyArray ifAbsent: [self error: 'Could not find key ', keyArray printString]! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/13/2005 03:36'!at: keyArray ifAbsent: errorBlock	keyArray size = keySize ifFalse: [self error: 'Key must be exactly ', keySize asString, ' bytes'].	^ self basicAt: keyArray ifAbsent: errorBlock! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/13/2005 03:37'!at: keyArray put: valueArray	keyArray size = keySize ifFalse: [self error: 'Key must be exactly ', keySize asString, ' bytes'].	valueArray size = valueSize ifFalse: [self error: 'Value must be exactly ', valueSize asString, ' bytes'].	^ self basicAt: keyArray put: valueArray! !!MDByteIndex methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!basicAt: keyArray ifAbsent: errorBlock	| i key |	i := self scanFor: keyArray.	key := self keyBytesAtIndex: i.	^ key = keyArray		ifTrue: [self valueBytesAtIndex: i]		ifFalse: errorBlock! !!MDByteIndex methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!basicAt: keyArray put: valueArray	| i key |	i := self scanFor: keyArray.	key := self keyBytesAtIndex: i.	key = keyArray ifFalse:		[self writeTally: self tally + 1.		self writeKeyBytes: keyArray atIndex: i].	self writeValueBytes: valueArray atIndex: i.	^ valueArray! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:45'!hash: keyArray	^ keyArray hash! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/15/2005 03:38'!keyBytesAtIndex: i	self seekTo: i.	^ stream atEnd		ifTrue: [ByteArray new: keySize]		ifFalse: [stream next: keySize]! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/13/2005 03:05'!keySize	^ keySize! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/15/2005 03:07'!maxIndex	^ streamSize - 4 // self recordSize! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:43'!recordSize	^ keySize + valueSize! !!MDByteIndex methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!scanFor: keyArray	| start |	start := (self hash: keyArray) \\ self maxIndex.	start to: self maxIndex do: [:i | (self scanFor: keyArray at: i) ifTrue: [^ i]].	0 to: start - 1 do: [:i | (self scanFor: keyArray at: i) ifTrue: [^ i]].		self error: 'Index is full'! !!MDByteIndex methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!scanFor: keyArray at: i	| key |	key := self keyBytesAtIndex: i.	^ key = keyArray or: [key allSatisfy: [:b | b = 0]]! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:42'!seekTo: i	stream position: i * self recordSize + 4! !!MDByteIndex methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:11'!setStream: aStream keySize: keyNumber valueSize: valueNumber streamSize: streamNumber	keySize := keyNumber.	valueSize := valueNumber.	streamSize := streamNumber.	stream := aStream.	stream binary! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/19/2005 02:51'!streamSize	^ streamSize! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/15/2005 03:23'!tally	stream reset.	^ stream atEnd		ifTrue: [0]		ifFalse: [stream nextInt32]! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:41'!valueBytesAtIndex: i	self seekTo: i.	stream skip: keySize.	^ stream next: valueSize! !!MDByteIndex methodsFor: 'accessing' stamp: 'avi 3/13/2005 03:05'!valueSize	^ valueSize! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:40'!writeKeyBytes: keyBytes atIndex: i	self seekTo: i.	stream nextPutAll: keyBytes! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:42'!writeTally: aNumber	stream reset.	stream nextInt32Put: aNumber! !!MDByteIndex methodsFor: 'private' stamp: 'avi 3/13/2005 03:40'!writeValueBytes: valueBytes atIndex: i	self seekTo: i.	stream skip: keySize.	stream nextPutAll: valueBytes! !!MDByteIndex class methodsFor: 'as yet unclassified' stamp: 'avi 3/15/2005 03:08'!stream: aStream keySize: keyNumber valueSize: valueNumber	^ self stream: aStream keySize: keyNumber valueSize: valueNumber streamSize: aStream size! !!MDByteIndex class methodsFor: 'as yet unclassified' stamp: 'avi 3/19/2005 02:41'!stream: aStream keySize: keyNumber valueSize: valueNumber streamSize: streamNumber	^ self basicNew setStream: aStream keySize: keyNumber valueSize: valueNumber streamSize: streamNumber! !TestCase subclass: #MDByteIndexTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDByteIndexTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!storeAndRetrieveWithFileSize: aNumber	|  file stream |	stream := RWBinaryOrTextStream on: ByteArray new.	stream next: aNumber put: 0.	stream reset. 	file := MDByteIndex stream: stream keySize: 2 valueSize: 4.	file at: 'aa' asByteArray put: 'abcd' asByteArray.	file at: 'ab' asByteArray put: 'qxry' asByteArray.	file at: 'xy' asByteArray put: '1234' asByteArray.	self assert: file tally = 3.	self assert: (file at: 'aa' asByteArray) = 'abcd' asByteArray.	self assert: (file at: 'ab' asByteArray) = 'qxry' asByteArray.	self assert: (file at: 'xy' asByteArray) = '1234' asByteArray.	file at: 'ab' asByteArray put: '9876' asByteArray.	self assert: (file at: 'ab' asByteArray) = '9876' asByteArray.	self assert: file tally = 3! !!MDByteIndexTest methodsFor: 'as yet unclassified' stamp: 'avi 3/13/2005 03:58'!testStoreAndRetrieve	self storeAndRetrieveWithFileSize: 100.	self storeAndRetrieveWithFileSize: 24.	self should: [self storeAndRetrieveWithFileSize: 12] raise: Error! !Object subclass: #MDChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDChange instVarNames includes: 'version') ifFalse:	[MDChange addInstVarName: 'version']!(MDChange instVarNames includes: 'variant') ifFalse:	[MDChange addInstVarName: 'variant']!!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 21:45'!<= other	^ self element printString <= other element printString! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 21:43'!element	^ variant element! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 22:18'!final	^ variant! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 16:14'!hasEffect	^ version variant ~= variant! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 7/26/2008 16:10'!name	^ variant properties name ifNil: [self element printString]! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 22:18'!original	^ version variant! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 15:52'!setVersion: aVersion variant: aVariant	version := aVersion.	variant := aVariant! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 15:52'!variant	^ variant! !!MDChange methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 15:52'!version	^ version	! !!MDChange class methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 15:52'!version: aVersion variant: aVariant	^ self new setVersion: aVersion variant: aVariant! !Object subclass: #MDChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!(MDChunk instVarNames includes: 'element') ifFalse:	[MDChunk addInstVarName: 'element']!(MDChunk instVarNames includes: 'properties') ifFalse:	[MDChunk addInstVarName: 'properties']!(MDChunk instVarNames includes: 'invisible') ifFalse:	[MDChunk addInstVarName: 'invisible']!!MDChunk methodsFor: 'accessing' stamp: 'cwp 4/27/2008 00:29'!beInvisible	invisible := true! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 5/2/2008 21:35'!element	^ element! !!MDChunk methodsFor: 'operations' stamp: 'cwp 5/3/2008 00:16'!hasSuperclass: aSymbol	^ false! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 4/27/2008 00:29'!isRemoval	^ properties isNil! !!MDChunk methodsFor: 'operations' stamp: 'cwp 5/3/2008 00:15'!isSuperOf: aChunk	^ false! !!MDChunk methodsFor: 'operations' stamp: 'cwp 5/2/2008 21:43'!joinSectionIn: aDictionary 	| section |	section := aDictionary 		at: element theClassName		ifAbsentPut: [ MDFileOutSection new ].	section addChunk: self! !!MDChunk methodsFor: 'operations' stamp: 'cwp 4/27/2008 00:06'!load: aPropertyDictionary	properties := aPropertyDictionary.	! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 5/20/2008 22:41'!printSortKeyOn: stream 	^ stream		nextPut: self typeChar;		nextPut: $!!;		nextPutAll: self sortOrdinal! !!MDChunk methodsFor: 'operations' stamp: 'cwp 4/26/2008 23:50'!reactToClass: aChunk	(element theClassName = aChunk name and: [aChunk isRemoval])		ifTrue: [self beInvisible].	^ aChunk! !!MDChunk methodsFor: 'operations' stamp: 'cwp 4/27/2008 00:05'!remove	properties := nil! !!MDChunk methodsFor: 'initialize-release' stamp: 'cwp 4/27/2008 00:29'!setElement: anElement	invisible := false.	element := anElement.! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 5/20/2008 22:38'!sortKey	^ String streamContents: [ :stream | self printSortKeyOn: stream ]! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 5/20/2008 22:41'!sortOrdinal	^ element name! !!MDChunk methodsFor: 'accessing' stamp: 'cwp 11/18/2008 20:00'!theClassName	^ element theClassName! !!MDChunk methodsFor: 'writing' stamp: 'cwp 5/19/2008 00:29'!writeInitializerOn: aStream	! !!MDChunk methodsFor: 'writing' stamp: 'cwp 4/27/2008 00:31'!writeOn: aStream	invisible ifFalse:		[properties			ifNil: [self writeRemovalOn: aStream]			ifNotNil: [self writeDefinitionOn: aStream]]! !!MDChunk methodsFor: 'writing' stamp: 'cwp 8/12/2008 20:28'!writeStampOn: aStream 	((properties includesKey: #initials) and: [ properties includesKey: #timeStamp ]) ifTrue: 		[ aStream			nextPutAll: ''' stamp: ''';			nextPutAll: properties initials;			space.		properties timeStamp printer 			printOn: aStream			format: '%l/%e/%Y %H:%M' ]! !!MDChunk class methodsFor: 'as yet unclassified' stamp: 'cwp 3/25/2008 22:21'!forElement: anElement	^ self new setElement: anElement! !TestCase subclass: #MDChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!write: aChunk	| stream |	stream := WriteStream on: String new.	aChunk writeOn: stream.	^ stream contents.! !!MDChunkTest class methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:31'!isAbstract	^ self name = #MDChunkTest! !Object subclass: #MDFakeClassDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!(MDFakeClassDescription instVarNames includes: 'superclass') ifFalse:	[MDFakeClassDescription addInstVarName: 'superclass']!(MDFakeClassDescription instVarNames includes: 'methodDict') ifFalse:	[MDFakeClassDescription addInstVarName: 'methodDict']!(MDFakeClassDescription instVarNames includes: 'format') ifFalse:	[MDFakeClassDescription addInstVarName: 'format']!(MDFakeClassDescription instVarNames includes: 'instanceVariables') ifFalse:	[MDFakeClassDescription addInstVarName: 'instanceVariables']!(MDFakeClassDescription instVarNames includes: 'organization') ifFalse:	[MDFakeClassDescription addInstVarName: 'organization']!(MDFakeClassDescription instVarNames includes: 'name') ifFalse:	[MDFakeClassDescription addInstVarName: 'name']!!MDFakeClassDescription methodsFor: 'mutation' stamp: 'cwp 5/22/2008 00:13'!addInstVarName: aString	instanceVariables := instanceVariables copyWith: aString! !!MDFakeClassDescription methodsFor: 'copying' stamp: 'cwp 8/27/2005 11:36'!copy	^ self class basedOn: self! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:37'!format	^format! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:37'!format: anObject	format := anObject! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:37'!instVarNames	^ instanceVariables! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:13'!instVarNames: anArray	instanceVariables := anArray! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:37'!methodDict	^methodDict! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:37'!methodDict: anObject	methodDict := anObject! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:38'!name	^ name! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:13'!name: aSymbol	name := aSymbol! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:39'!organization	^organization! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:39'!organization: anObject	organization := anObject! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:39'!superclass	^superclass! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:39'!superclass: anObject	superclass := anObject! !!MDFakeClassDescription methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:55'!theRealClass	^Smalltalk classNamed: name! !Object subclass: #MDFakeElementAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Fakes'!(MDFakeElementAdaptor instVarNames includes: 'image') ifFalse:	[MDFakeElementAdaptor addInstVarName: 'image']!(MDFakeElementAdaptor instVarNames includes: 'element') ifFalse:	[MDFakeElementAdaptor addInstVarName: 'element']!!MDFakeElementAdaptor methodsFor: 'private' stamp: 'cwp 2/13/2005 19:29'!checkDependencies	self isLoadable ifFalse: [self error: 'Unmet dependency']! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 5/24/2005 07:54'!display: properties	^ properties one asString! !!MDFakeElementAdaptor methodsFor: 'private' stamp: 'cwp 5/11/2008 22:05'!isLoadable	| required |	(element name includes: $/) ifFalse: [^ true].	required := element name copyUpTo: $/.	^ image elements anySatisfy: [:ea | ea name = required]! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 2/13/2005 19:44'!isLoadable: properties	^ self isLoadable! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 5/11/2008 21:32'!isPresent	^ (image at: element ifAbsent: [^ false]) notNil! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 2/4/2005 00:39'!isUpToDate: properties	properties keysAndValuesDo: 		[:key :value |		(self properties at: key ifAbsent: [^ false]) = value ifFalse: [^ false]].	^ true	! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 3/25/2005 22:03'!load: properties 	self checkDependencies.	self properties.	properties keysAndValuesDo: [:key :value | self properties at: key put: value]! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'avi 3/16/2005 12:33'!merge: aPropertyDictionary into: otherPropertyDictionary onFailure: aBlock	^ aBlock value! !!MDFakeElementAdaptor methodsFor: 'accessing' stamp: 'cwp 5/11/2008 22:04'!properties	^ image at: element! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 5/11/2008 21:33'!remove	image at: element put: nil! !!MDFakeElementAdaptor methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:10'!setImage: aFakeImageProxy element: anElement	image := aFakeImageProxy.	element := anElement! !!MDFakeElementAdaptor methodsFor: 'public' stamp: 'cwp 2/4/2005 00:33'!update: properties	self properties keysAndValuesDo: [:key :value | properties at: key put: value]! !!MDFakeElementAdaptor class methodsFor: 'instance creation' stamp: 'cwp 2/4/2005 00:35'!forElement: anElement inImage: aDictionary	^ self new setImage: aDictionary element: anElement! !Object subclass: #MDFakeLink	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDFakeLink instVarNames includes: 'service') ifFalse:	[MDFakeLink addInstVarName: 'service']!(MDFakeLink instVarNames includes: 'closed') ifFalse:	[MDFakeLink addInstVarName: 'closed']!!MDFakeLink methodsFor: 'accessing' stamp: 'jf 10/25/2008 13:35'!close	closed := true! !!MDFakeLink methodsFor: 'accessing' stamp: 'cwp 1/5/2008 00:10'!description	^ 'fake net repository'! !!MDFakeLink methodsFor: 'testing' stamp: 'jf 10/25/2008 13:36'!isOpen	^ closed isNil or: [ closed not ]! !!MDFakeLink methodsFor: 'accessing' stamp: 'cwp 6/1/2008 00:55'!locator	^ MDFakeLocator new! !!MDFakeLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 23:58'!send: aMessage	^ service handleMessage: aMessage! !!MDFakeLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setService: aService	service := aService! !!MDFakeLink class methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!repositoryForTesting	| service link repository |	service := MDNetService for: MDMemoryRepository new.	link := MDFakeLink to: service.	repository := MDNetRepository link: link.	^ repository! !!MDFakeLink class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 23:58'!to: aService	^ self new setService: aService! !Object subclass: #MDFakeLocator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDFakeLocator instVarNames includes: 'stream') ifFalse:	[MDFakeLocator addInstVarName: 'stream']!(MDFakeLocator instVarNames includes: 'mocket') ifFalse:	[MDFakeLocator addInstVarName: 'mocket']!!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!createStream	| class |	class := Smalltalk at: #FastSocketStream ifAbsent: [Smalltalk at: #SocketStream].	stream := class on: self mocket.	^ stream! !!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 1/12/2008 13:03'!description	^ 'Fake'! !!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 00:34'!host	^ 'fakehost.com'! !!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!mocket		^ mocket ifNil: 		[mocket := MLMocket new.		mocket			execute: [mocket connectTo: #(127 0 0 1) port: 7301];			expectConnectionTo: #(127 0 0 1) port: 7301]! !!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 00:36'!port	^ 7901! !!MDFakeLocator methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 00:56'!update: properties	^ properties		type: MDNetRepository type;		host: self host;		port: self port;		yourself! !Object subclass: #MDFileOutExporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!(MDFileOutExporter instVarNames includes: 'stream') ifFalse:	[MDFileOutExporter addInstVarName: 'stream']!(MDFileOutExporter instVarNames includes: 'sections') ifFalse:	[MDFileOutExporter addInstVarName: 'sections']!(MDFileOutExporter instVarNames includes: 'preamble') ifFalse:	[MDFileOutExporter addInstVarName: 'preamble']!!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForClassCommentElement: anElement 	^ self addChunk: (MDClassCommentChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForClassElement: anElement 	^ self addChunk: (MDClassChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForClassInstVarElement: anElement 	^ self addChunk: (MDClassInstVarChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForClassVarElement: anElement 	^ self addChunk: (MDClassVarChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForInstVarElement: anElement 	^ self addChunk: (MDInstVarChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForMethodElement: anElement 	^ self addChunk: (MDMethodChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'adapting' stamp: 'cwp 5/2/2008 21:23'!adaptorForPoolImportElement: anElement 	^ self addChunk: (MDPoolImportChunk forElement: anElement)! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/2/2008 21:43'!addChunk: aChunk 	aChunk joinSectionIn: sections.	^ aChunk! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/2/2008 22:35'!addMemo: aMemo 	preamble := MDMemoChunk on: aMemo.! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/2/2008 21:19'!addVersion: aVersion	aVersion variant loadInto: self! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/2/2008 21:19'!export: aMemo from: aRepository	| snapshot |	self addMemo: aMemo.	snapshot := aRepository get: aMemo reference.	snapshot contents do:		[:ea | self addVersion: (aRepository get: ea)].	self harmonize.	self flush! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/19/2008 00:44'!flush	preamble ifNotNil: 		[preamble writeOn: stream.		stream cr].	sections 		do:	[:ea | 			ea writeOn: stream. 			stream cr].	sections do: [:ea | ea writeInitializerOn: stream].	stream flush! !!MDFileOutExporter methodsFor: 'exporting' stamp: 'cwp 5/2/2008 22:46'!harmonize	sections do: [:ea | ea harmonize].	sections do: 		[:outer | 		sections do: 			[:inner | 			outer noteSection: inner]].	sections := sections asSortedCollection.! !!MDFileOutExporter methodsFor: 'initialize-release' stamp: 'cwp 5/2/2008 21:30'!setStream: aStream	stream := aStream.	sections := Dictionary new.! !!MDFileOutExporter class methodsFor: 'as yet unclassified' stamp: 'cwp 3/24/2008 23:16'!on: aStream	^ self new setStream: aStream! !TestCase subclass: #MDFileOutExporterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDFileOutExporterTest instVarNames includes: 'stream') ifFalse:	[MDFileOutExporterTest addInstVarName: 'stream']!(MDFileOutExporterTest instVarNames includes: 'exporter') ifFalse:	[MDFileOutExporterTest addInstVarName: 'exporter']!!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:26'!bogusAInitialize	| element variant |	element := MDMethodElement className: #BogusA selector: #initialize classIsMeta: true.	variant := MDDefinitionVariant forElement: element.	variant properties		category: #capitals;		initials: 'cwp';		timestamp: (MDTimestamp fromInteger: 886029518);		source: 'initialize';		yourself.	^ MDElementVersion variant: variant! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:57'!classRemoval	| element variant |	element := MDClassElement className: #BogusB.	variant := MDRemovalVariant forElement: element.	^ MDElementVersion variant: variant! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/24/2008 22:34'!get: aString	^ self repository get: (MDHashstamp fromString: aString).! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/24/2008 23:18'!repository	^ MDBogusRepositoryResource current repository! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:20'!setUp	stream := WriteStream on: String new.	exporter := MDFileOutExporter on: stream.! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassA	| version actual |	version := self get: 'BB7B1j1C3yfXYwfk5gtjhSCFfn2bLTAs'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusA' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassAClassMethod	| version actual |	version := self get: 'BB7B1pz2CiTIcTCv4p9FhmN-8ItWhDth'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusA class' caseSensitive: true).	self assert: (actual includesSubstring: 'isCompletelyUseless' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassAComment	| version actual |	version := self get: 'BB7B1tna4jGwDgeSxlbbDkUcSLErTdOk'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusA' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassBClassInstVar	| version actual |	version := self get: 'BB7B1zTQEHxvWFPEsVxbHwWnsGpZ8-F8'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusB class' caseSensitive: true).	self assert: (actual includesSubstring: 'addInstVarName:' caseSensitive: true).	self assert: (actual includesSubstring: 'firstClassInstanceVariableB' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 19:13'!testClassBClassVar	| version actual |	version := self get: 'BB7B1ruO0oxpSMVzlLfCBquosWpdeYnJ'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusB' caseSensitive: true).	self assert: (actual includesSubstring: 'addClassVarName:' caseSensitive: true).	self assert: (actual includesSubstring: 'FirstClassVariableB' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassBInstVar	| version actual |	version := self get: 'BB7B1nM4Kemmzcp8lG0EnAWfLbbIM+He'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusB' caseSensitive: true).	self assert: (actual includesSubstring: 'firstInstanceVariableB' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 23:08'!testClassBMethod	| version actual |	version := self get: 'BB7B1qsfgOXscoNQ+57SN9384L02NOuw'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusB' caseSensitive: true).	self assert: (actual includesSubstring: 'foo' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassBPoolImport	| version actual |	version := self get: 'BB7B1sWhRQd03QKGoSkXz-hA7o2Hxvtg'.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusB' caseSensitive: true).	self assert: (actual includesSubstring: 'BogusPool' caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 01:07'!testClassRemoval	| actual |	exporter addVersion: (self get: 'BB7B1j1C3yfXYwfk5gtjhSCFfn2bLTAs').	exporter addVersion: self classRemoval.	exporter harmonize; flush.	actual := stream contents.	self assert: (actual 			includesSubstring: 'BogusB'			caseSensitive: true)! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 22:02'!testCompleteSnapshot	| memo |	memo := self repository memos anyOne.	exporter export: memo from: self repository.	self assert: stream contents size > 3000.! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 22:05'!testDependenciesHonored	| memo fileout |	memo := self repository memos anyOne.	exporter export: memo from: self repository.	fileout := stream contents.	self deny: (fileout includesSubString: 'Smalltalk hasClassNamed:')! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/3/2008 00:17'!testExtensionMethod	| actual version1 version2 index1 index2 |	version1 := self get: 'BB7B1qsfgOXscoNQ+57SN9384L02NOuw'.	version2 := self get: 'BB7B1j1C3yfXYwfk5gtjhSCFfn2bLTAs'.	exporter addVersion: version1.	exporter addVersion: version2.	exporter harmonize.	exporter flush.	actual := stream contents.	index1 := actual indexOfSubCollection: 'BogusA'.	index2 := actual indexOfSubCollection: 'BogusB'.	self assert: index1 < index2! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:15'!testInitializerMethod	| version actual |	version := self bogusAInitialize.	actual := self write: version.	self assert: (actual includesSubstring: 'BogusA initialize' caseSensitive: true).! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/13/2008 16:34'!testSharedPoolsFirst	| memo fileout index1 index2 |	memo := self repository memos anyOne.	exporter export: memo from: self repository.	fileout := stream contents.	index1 := fileout indexOfSubCollection: 'BogusPool'.	index2 := fileout indexOfSubCollection: 'BogusA'.	self assert: index1 < index2! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:02'!testSuperclassOrder	| memo fileout index1 index2 |	memo := self repository memos anyOne.	exporter export: memo from: self repository.	fileout := stream contents.	index1 := fileout indexOfSubCollection: 'BogusA'.	index2 := fileout indexOfSubCollection: 'BogusE'.	self assert: index1 < index2! !!MDFileOutExporterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:24'!write: aVersion	exporter addVersion: aVersion.	exporter flush.	^ stream contents! !!MDFileOutExporterTest class methodsFor: 'as yet unclassified' stamp: 'cwp 3/24/2008 23:19'!resources	^ {MDBogusRepositoryResource}! !Object subclass: #MDFileOutSection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!(MDFileOutSection instVarNames includes: 'chunks') ifFalse:	[MDFileOutSection addInstVarName: 'chunks']!(MDFileOutSection instVarNames includes: 'superSection') ifFalse:	[MDFileOutSection addInstVarName: 'superSection']!(MDFileOutSection instVarNames includes: 'depth') ifFalse:	[MDFileOutSection addInstVarName: 'depth']!!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 10/13/2008 16:22'!<= other	^ self isSharedPool = other isSharedPool		ifFalse: [self isSharedPool]		ifTrue: 			[self depth = other depth				ifTrue: [self theClassName <= other theClassName]				ifFalse: [self depth < other depth]]! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:29'!addChunk: aChunk	chunks add: aChunk! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 22:30'!classChunk	^ chunks first! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 23:01'!depth	^ depth ifNil:		[depth := superSection 			ifNil: [1]			ifNotNil: [superSection depth + 1]]! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:31'!harmonize	| class |	chunks := chunks asSortedCollection: [ :a :b | a sortKey <= b sortKey ].	class := nil.	chunks do: [ :chunk | class := chunk reactToClass: class ]! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:29'!initialize	chunks := Set new! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 10/13/2008 16:32'!isSharedPool	^ self classChunk hasSuperclass: #SharedPool! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 22:30'!noteSection: other	(other classChunk isSuperOf: self classChunk) ifTrue:		[superSection := other]! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 11/18/2008 20:00'!theClassName	^ chunks first theClassName! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:39'!writeInitializerOn: aStream	chunks do: [:ea | ea writeInitializerOn: aStream]		! !!MDFileOutSection methodsFor: 'as yet unclassified' stamp: 'cwp 5/2/2008 21:34'!writeOn: aStream	chunks		do: [:ea | ea writeOn: aStream]		separatedBy: [aStream cr]! !!MDFileOutSection class methodsFor: 'as yet unclassified' stamp: 'cwp 11/20/2008 18:49'!new	^ self basicNew initialize! !Object subclass: #MDHashedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!(MDHashedObject instVarNames includes: 'cache') ifFalse:	[MDHashedObject addInstVarName: 'cache']!!MDHashedObject methodsFor: 'comparing' stamp: 'cwp 3/16/2008 00:12'!= other	^ self species = other species		and: [self hashstamp = other hashstamp]! !!MDHashedObject methodsFor: 'comparing' stamp: 'cwp 3/16/2008 00:16'!hash	^ cache hash! !!MDHashedObject methodsFor: 'accessing' stamp: 'cwp 8/9/2005 21:43'!hashstamp	^ cache! !!MDHashedObject methodsFor: 'initialize-release' stamp: 'cwp 3/16/2008 00:19'!initHashstamp	cache := MDHashstamp 				forObject: self 				timestamp: cache! !!MDHashedObject methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 08:12'!initialize	cache := MDTimestamp now.! !!MDHashedObject methodsFor: 'testing' stamp: 'cwp 1/19/2007 20:49'!isMemo	^ false! !!MDHashedObject methodsFor: 'testing' stamp: 'cwp 1/1/2007 09:34'!isSnapshot	^ false! !!MDHashedObject methodsFor: 'serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	^ aSerializer serializeHashedObject: self! !!MDHashedObject methodsFor: 'accessing' stamp: 'cwp 8/9/2005 21:44'!timestamp	^ cache timestamp! !!MDHashedObject methodsFor: 'testing' stamp: 'cwp 3/16/2008 00:23'!verifyHashstamp	^ cache = (MDHashstamp forObject: self timestamp: self timestamp)		! !!MDHashedObject class methodsFor: 'serialization' stamp: 'avi 3/12/2005 02:51'!extension	self subclassResponsibility! !!MDHashedObject class methodsFor: 'serialization' stamp: 'cwp 11/20/2008 18:49'!new	^ self basicNew initialize! !Magnitude variableByteSubclass: #MDHashstamp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!!MDHashstamp commentStamp: 'dc 6/14/2007 08:17' prior: 0!A Hashstamp is combination of SHA1 hash and timestamp which uniquely identifies the version.!(MDHashstamp classVarNames includes: 'MDCharMap') ifFalse:	[MDHashstamp addClassVarName: 'MDCharMap']!!MDHashstamp methodsFor: 'comparing' stamp: 'cwp 5/22/2008 00:10'!< other	| selfByte otherByte |	1 to: self byteSize do: 		[:i | 			selfByte := self byteAt: i.			otherByte := other byteAt: i.			(selfByte == otherByte) ifFalse: [^ selfByte < otherByte]].	^ false! !!MDHashstamp methodsFor: 'comparing' stamp: 'cwp 9/11/2005 17:56'!= other	self class = other class ifFalse: [^ false].	1 to: self size do: [:i | (self at: i) = (other at: i) ifFalse: [^ false]].	^ true! !!MDHashstamp methodsFor: 'serializing' stamp: 'cwp 6/23/2008 13:19'!asByteArray	^ self bytes! !!MDHashstamp methodsFor: 'bytes' stamp: 'cwp 4/18/2005 13:17'!byteAt: index	^ self basicAt: index! !!MDHashstamp methodsFor: 'bytes' stamp: 'cwp 4/18/2005 13:41'!byteAt: index put: value	self basicAt: index put: value! !!MDHashstamp methodsFor: 'bytes' stamp: 'cwp 4/18/2005 13:46'!byteSize	^ self basicSize! !!MDHashstamp methodsFor: 'serializing' stamp: 'cwp 5/22/2008 00:10'!bytes	| bytes |	bytes := ByteArray new: self size.	bytes replaceFrom: 1 to: self size with: self startingAt: 1.	^ bytes! !!MDHashstamp methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:10'!digest	| hash |	hash := LargePositiveInteger basicNew: 20.	1 to: 20 do: [:i | hash digitAt: i put: (self at: i + 4)].	^ hash! !!MDHashstamp methodsFor: 'comparing' stamp: 'cwp 4/18/2005 13:35'!hash	^ByteArray		hashBytes: self		startingWith: self species hash! !!MDHashstamp methodsFor: 'serializing' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeHashstamp: self! !!MDHashstamp methodsFor: 'printing' stamp: 'cwp 10/2/2008 20:19'!printFirst: first second: second third: third on: aStream 	| a b c d |	a := first bitShift: -2.	b := ((first bitShift: 4) bitOr: (second bitShift: -4)) bitAnd: 63.	c := ((second bitShift: 2) bitOr: (third bitShift: -6)) bitAnd: 63.	d := third bitAnd: 63.	aStream		nextPut: (MDCharMap at: a + 1);		nextPut: (MDCharMap at: b + 1);		nextPut: (MDCharMap at: c + 1);		nextPut: (MDCharMap at: d + 1)! !!MDHashstamp methodsFor: 'printing' stamp: 'cwp 5/22/2008 00:10'!printOn: aStream	| bytes |	bytes := self bytes.	1 to: 24 by: 3 do: [:i | self 							printFirst: (bytes at: i) 							second: (bytes at: i+1)							third: (bytes at: i+2)							on: aStream].! !!MDHashstamp methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!replaceFrom: start to: end with: bytes	| offset |	offset := start - 1.	1 to: (end - offset) do: [:i | self basicAt: offset + i put: (bytes basicAt: i)]! !!MDHashstamp methodsFor: 'initialize-release' stamp: 'cwp 4/18/2005 13:33'!setHash: aLargeInteger timestamp: aTimestamp	self replaceFrom: 1 to: 4 with: aTimestamp.	self replaceFrom: 5 to: 24 with: (aLargeInteger withAtLeastNDigits: 20)! !!MDHashstamp methodsFor: 'accessing' stamp: 'cwp 4/18/2005 13:15'!timestamp	^ MDTimestamp fromHashstamp: self! !!MDHashstamp class methodsFor: 'serializing' stamp: 'cwp 10/2/2008 20:19'!decodeString: aString 	| write read a b c d |	write := (ByteArray new: self hashstampSize) writeStream.	read := aString readStream.	[ read atEnd ] whileFalse: 		[ a := (MDCharMap indexOf: read next) - 1.		b := (MDCharMap indexOf: read next) - 1.		write nextPut: (a bitShift: 2) + (b bitShift: -4).		b := b bitAnd: 15.		c := (MDCharMap indexOf: read next) - 1.		write nextPut: (b bitShift: 4) + (c bitShift: -2).		c := c bitAnd: 3.		d := (MDCharMap indexOf: read next) - 1.		write nextPut: (c bitShift: 6) + d ].	^ write contents! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'cwp 4/9/2005 05:02'!forObject: anObject 	^ self forObject: anObject timestamp: MDTimestamp now! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'cwp 11/17/2008 00:54'!forObject: anObject timestamp: aTimestamp	^ self 		hashIn: [:stream | MDMarshal serialize: anObject on: stream]		timestamp: aTimestamp! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'cwp 5/22/2008 00:10'!fromBytes: aByteArray	| hashstamp |	aByteArray size = self hashstampSize ifFalse: [self error: 'Incorrect byte size'].	hashstamp := self new.	1 to: 24 do: [:i | hashstamp byteAt: i put: (aByteArray at: i)].	^ hashstamp! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'avi 3/14/2005 12:46'!fromString: aString	^ self fromBytes: (self decodeString: aString)! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'cwp 4/9/2005 05:01'!hashIn: aBlock	^ self hashIn: aBlock timestamp: MDTimestamp now! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'cwp 6/5/2008 22:22'!hashIn: aBlock timestamp: aTimestamp	| sha stream |	stream := ByteArray new writeStream.	aBlock value: stream.	sha := SecureHashAlgorithm new.	^ self new setHash: (sha hashMessage: stream contents) timestamp: aTimestamp! !!MDHashstamp class methodsFor: 'accessing defaults' stamp: 'dc 6/27/2007 13:48'!hashstampSize	^ 24! !!MDHashstamp class methodsFor: 'initialize-release' stamp: 'cwp 10/2/2008 20:19'!initialize	MDCharMap := '+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'! !!MDHashstamp class methodsFor: 'instance creation' stamp: 'dc 6/27/2007 13:48'!new	^ self new: self hashstampSize! !TestCase subclass: #MDHashstampTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testCreation	| hashstamp |	hashstamp := MDHashstamp hashIn: [:stream | stream nextPutAll: 'abc' asByteArray].	self assert: hashstamp digest digitLength = 20.	self assert: (MDTimestamp now asInteger - hashstamp timestamp asInteger) < 5.! !!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testEqual	| first second now |	now := MDTimestamp now.	first := MDHashstamp forObject: 'abc' timestamp: now.	second := MDHashstamp forObject: 'abc' timestamp: now.	self assert: first = second! !!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testHash	| first second |	first := MDHashstamp hashIn: [:stream | stream nextPutAll: 'abc' asByteArray].	second := MDHashstamp hashIn: [:stream | stream nextPutAll: 'bcd' asByteArray].	self deny: first hash = second hash.	self deny: first = second! !!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLessThan	| first second |	first := MDHashstamp fromString: 'bjrm0RTKT7KesZu0C1N9d0Dv+-Fez-No'.	second := MDHashstamp fromString: 'c0qD0lTwM3oFdWJn9yYiSxGZjuhr9NHe'.	self assert: first <= second! !!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testPrinting	| hashstamp |	hashstamp := MDHashstamp 					forObject: 'abc'					timestamp: (MDTimestamp fromInteger: 30000).	self assert: hashstamp printString = '++-pA+-UztUKcA8pSliAinvJ8dSNIEAy'! !!MDHashstampTest methodsFor: 'tests' stamp: 'dc 6/14/2007 08:19'!testRead	| hashstamp |	hashstamp := MDHashstamp hashIn: [:stream | stream nextPutAll: 'abc' asByteArray].	self assert: hashstamp = (MDHashstamp fromString: hashstamp asString)! !!MDHashstampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testTimestamp	| first second now then |	now := MDTimestamp now.	then := MDTimestamp fromInteger: (now asInteger - 1).	first := MDHashstamp forObject: 'abc' timestamp: then.	second := MDHashstamp forObject: 'abc' timestamp: now.	self assert: first digest = second digest.	self deny: first = second! !Object subclass: #MDHistorian	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Project'!(MDHistorian instVarNames includes: 'slice') ifFalse:	[MDHistorian addInstVarName: 'slice']!(MDHistorian instVarNames includes: 'properties') ifFalse:	[MDHistorian addInstVarName: 'properties']!(MDHistorian instVarNames includes: 'parents') ifFalse:	[MDHistorian addInstVarName: 'parents']!(MDHistorian instVarNames includes: 'ordinal') ifFalse:	[MDHistorian addInstVarName: 'ordinal']!(MDHistorian instVarNames includes: 'isDirty') ifFalse:	[MDHistorian addInstVarName: 'isDirty']!!MDHistorian methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:10'!basicMemo	| memo |	memo := MDMemo parents: self parents.	self update: memo properties.	MDPlatform current updateMemoProperties: memo properties.	memo properties ordinal: (self ordinal).	^ memo! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 6/1/2008 20:30'!clearParents	parents := OrderedCollection new! !!MDHistorian methodsFor: 'ordinals' stamp: 'cwp 5/22/2008 00:10'!incrementOrdinal	ordinal := ordinal + 1! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 3/8/2008 21:27'!isDirty	^ isDirty! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 8/3/2008 21:50'!markClean	isDirty ifTrue: 		[isDirty := false.		MDAnnouncer default announce: (MDSliceClean for: slice)]! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 8/3/2008 21:50'!markDirty	isDirty ifFalse: 		[isDirty := true.		MDAnnouncer default announce: (MDSliceDirty for: slice)]! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:10'!memo	| memo name |	memo := self basicMemo.	name := memo nameForSlice: slice.	^ (MDCommentRequest signal: 'Comment for ', name) ifNotNilDo:		[:comment | 		comment isEmpty ifFalse: [memo properties comment: comment].		self incrementOrdinal.		memo].	! !!MDHistorian methodsFor: 'notification' stamp: 'cwp 7/26/2008 17:49'!noteElementChanged: anElement 	(slice includes: anElement) ifTrue: [ self markDirty ]! !!MDHistorian methodsFor: 'notification' stamp: 'cwp 3/8/2008 12:45'!noteInclude: aMemo	parents add: aMemo hashstamp.	self noteOrdinal: aMemo properties ordinal ! !!MDHistorian methodsFor: 'notification' stamp: 'cwp 8/3/2008 21:47'!noteLoad: aMemo	parents := OrderedCollection with: aMemo hashstamp.	self noteOrdinal: aMemo properties ordinal.	self markClean! !!MDHistorian methodsFor: 'ordinals' stamp: 'cwp 5/22/2008 00:10'!noteOrdinal: anInteger 		anInteger ifNotNil: [ordinal := ordinal max: anInteger + 1]! !!MDHistorian methodsFor: 'notification' stamp: 'cwp 8/3/2008 21:47'!noteSave: aMemo	parents := OrderedCollection with: aMemo hashstamp.	self markClean! !!MDHistorian methodsFor: 'ordinals' stamp: 'cwp 3/8/2008 12:35'!ordinal	^ ordinal! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 3/8/2008 12:36'!parents	^ parents asArray! !!MDHistorian methodsFor: 'accessing' stamp: 'cwp 12/27/2007 21:47'!properties	^ properties! !!MDHistorian methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:10'!setSlice: aSlice	slice := aSlice.	properties := MDPropertyDictionary new.	parents := OrderedCollection new.	ordinal := 1.	isDirty := false	! !!MDHistorian methodsFor: 'updating' stamp: 'cwp 12/27/2007 21:27'!update: props	properties keysAndValuesDo: [:k :v | props at: k put: v]! !!MDHistorian class methodsFor: 'as yet unclassified' stamp: 'cwp 3/8/2008 14:01'!forSlice: aSlice	^ self new setSlice: aSlice! !TestCase subclass: #MDHistorianTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDHistorianTest instVarNames includes: 'historian') ifFalse:	[MDHistorianTest addInstVarName: 'historian']!(MDHistorianTest instVarNames includes: 'slice') ifFalse:	[MDHistorianTest addInstVarName: 'slice']!!MDHistorianTest methodsFor: 'support' stamp: 'cwp 3/6/2008 20:09'!createMemo	^ MDMemo		snapshot: (MDSnapshot withVersions: Array new) 		slice: slice		parents: Array new		properties: MDPropertyDictionary new.! !!MDHistorianTest methodsFor: 'support' stamp: 'cwp 5/22/2008 00:10'!markDirty	| element |	element := MDFakeElement named: #a.	slice addElement: element.	historian noteElementChanged: element.! !!MDHistorianTest methodsFor: 'support' stamp: 'cwp 3/6/2008 18:45'!memo	^ self memoWithComment: 'This is a test'! !!MDHistorianTest methodsFor: 'support' stamp: 'cwp 3/8/2008 14:02'!memoWithComment: aString	^ [historian memo]		on: MDCommentRequest		do: [:req | req resume: aString]! !!MDHistorianTest methodsFor: 'support' stamp: 'cwp 5/22/2008 00:10'!setUp	slice := MDExplicitSlice named: 'test'.	historian := MDHistorian forSlice: slice.! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testCancelCommentRequest	| memo |	memo := self memoWithComment: nil.	self assert: memo isNil! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testComment	| memo |	memo := self memoWithComment: 'test123'.	self assert: (memo properties comment = 'test123')! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 3/9/2008 22:25'!testDirty		self markDirty.	self assert: historian isDirty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testEmptyComment	| memo |	memo := self memoWithComment: ''.	self deny: (memo properties includesKey: #comment)! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testIncludeUpdatesOrdinal		| child first second |	first := self createMemo.	second := self createMemo.	second properties ordinal: 5.	historian noteLoad: first.	historian noteInclude: second.	child := self memo.	self assert: child properties ordinal = 6! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLoad		| parent child |	parent := self createMemo.	historian noteLoad: parent.	child := self memo.	self assert: child parents size = 1.	self assert: child parents anyOne = parent hashstamp! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLoadAndInclude		| child first second |	first := self createMemo.	second := self createMemo.	historian noteLoad: first.	historian noteInclude: second.	child := self memo.	self assert: child parents size = 2.	self assert: child parents first = first hashstamp.	self assert: child parents second = second hashstamp.! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLoadAndSave		| child first second |	first := self createMemo.	second := self createMemo.	historian noteLoad: first.	historian noteSave: second.	child := self memo.	self assert: child parents size = 1.	self assert: child parents anyOne = second hashstamp.! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLoadClearsDirtyFlag		| parent |	self markDirty.	parent := self createMemo.	historian noteLoad: parent.	self deny: historian isDirty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testLoadUpdatesOrdinal		| parent child |	parent := self createMemo.	parent properties ordinal: 5.	historian noteLoad: parent.	child := self memo.	self assert: child properties ordinal = 6! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 3/6/2008 19:23'!testNoParents		self assert: self memo parents isEmpty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testNotDirty	| element |	element := MDFakeElement named: #a.	historian noteElementChanged: element.	self deny: historian isDirty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testOrdinalsIncreaseByOne	| memo |	self memo.	memo := self memo.	self assert: memo properties ordinal = 2! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 12/28/2007 23:56'!testOrdinalsStartAtOne	self assert: self memo properties ordinal = 1! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testPlatformProperties	| properties memo |	properties := MDPropertyDictionary new.	MDPlatform current updateMemoProperties: properties.		memo := self memo.	properties keysAndValuesDo:		[:k :v | self assert: (memo properties at: k) = v]! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSave		| parent child |	parent := self memo.	parent setSnapshot: (MDSnapshot withVersions: Array new) slice: slice. 	historian noteSave: parent.	child := self memo.	self assert: child parents size = 1.	self assert: child parents anyOne = parent hashstamp! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSaveAndInclude		| child first second |	first := self memo.	second := self createMemo.	first setSnapshot: (MDSnapshot withVersions: Array new) slice: slice. 	historian noteSave: first.	historian noteInclude: second.	child := self memo.	self assert: child parents size = 2.	self assert: child parents first = first hashstamp.	self assert: child parents second = second hashstamp.! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSaveClearsDirtyFlag	| parent |	self markDirty.		parent := self memo.	parent setSnapshot: (MDSnapshot withVersions: Array new) slice: slice. 	historian noteSave: parent.		self deny: historian isDirty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 3/8/2008 21:16'!testStartsClean	self deny: historian isDirty! !!MDHistorianTest methodsFor: 'tests' stamp: 'cwp 12/28/2007 23:57'!testUpdate		historian properties abc: 123.	self assert: self memo properties abc = 123! !Object subclass: #MDImageElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDImageElement commentStamp: 'dc 6/14/2007 05:21' prior: 0!I am an abstract superclass. My subclasses are references to the parts of a Smalltalk program. These play the same role as MethodReferences. They are references to specific parts of a Smalltalk program. They're more fine-grained than Definitions in MC1 - you'll see separate elements for each instance variable, for example, so that they can referred to directly, rather than by implication in a class reference.!!MDImageElement methodsFor: 'comparing' stamp: 'cwp 5/28/2008 21:43'!<= other	^ self printString <= other printString! !!MDImageElement methodsFor: 'comparing' stamp: 'avi 11/28/2004 16:02'!= other	self subclassResponsibility ! !!MDImageElement methodsFor: 'adapting' stamp: 'cwp 2/3/2005 23:54'!adaptedFor: anImageProxy	self subclassResponsibility! !!MDImageElement methodsFor: 'conflicts' stamp: 'avi 3/16/2005 12:27'!alwaysPreferDefinition	^ false! !!MDImageElement methodsFor: 'conflicts' stamp: 'avi 3/16/2005 12:27'!alwaysPreferRemoval	^ false! !!MDImageElement methodsFor: 'printing' stamp: 'cwp 8/28/2005 17:43'!displayClassName	^ 'Element'! !!MDImageElement methodsFor: 'comparing' stamp: 'avi 11/28/2004 16:02'!hash	self subclassResponsibility ! !!MDImageElement methodsFor: 'image proxy' stamp: 'cwp 2/3/2005 23:53'!is: properties upToDateFor: anImageProxy	^ (self adaptedFor: anImageProxy) isUpToDate: properties! !!MDImageElement methodsFor: 'image proxy' stamp: 'cwp 2/13/2005 19:42'!isLoadable: properties into: anImageProxy	^ (self adaptedFor: anImageProxy) isLoadable: properties! !!MDImageElement methodsFor: 'image proxy' stamp: 'cwp 2/3/2005 23:53'!load: properties into: anImageProxy	^ (self adaptedFor: anImageProxy) load: properties! !!MDImageElement methodsFor: 'conflicts' stamp: 'avi 3/16/2005 12:22'!merge: aPropertyDictionary into: otherPropertyDictionary in: anImageProxy onFailure: aBlock	^ (self adaptedFor: anImageProxy)		merge: aPropertyDictionary		into: otherPropertyDictionary		onFailure: aBlock! !!MDImageElement methodsFor: 'converting' stamp: 'dc 6/21/2007 18:31'!newDefinitionVariant	"Creates a new definition variant based on the receiver."	^ MDDefinitionVariant forElement: self! !!MDImageElement methodsFor: 'converting' stamp: 'dc 6/21/2007 18:31'!newElementVersion	"Creates a new version based on the receiver."	^ self newDefinitionVariant newElementVersion ! !!MDImageElement methodsFor: 'image proxy' stamp: 'cwp 2/3/2005 23:53'!removeFrom: anImageProxy	^ (self adaptedFor: anImageProxy) remove! !!MDImageElement methodsFor: 'image proxy' stamp: 'cwp 2/3/2005 23:53'!update: properties from: anImageProxy	^ (self adaptedFor: anImageProxy) update: properties! !Object subclass: #MDKeyedStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-File'!(MDKeyedStream instVarNames includes: 'stream') ifFalse:	[MDKeyedStream addInstVarName: 'stream']!!MDKeyedStream methodsFor: 'comparing' stamp: 'cwp 12/25/2006 15:25'!= other	^ self species = other species		and: [self stream name = other stream name]! !!MDKeyedStream methodsFor: 'public' stamp: 'cwp 11/6/2007 22:52'!appendKey: keyBytes value: valueBytes 	self assert: [keyBytes size = self keySize].	stream		setToEnd;		nextPutAll: keyBytes;		nextInt32Put: valueBytes size;		nextPutAll: valueBytes! !!MDKeyedStream methodsFor: 'accessing' stamp: 'cwp 10/13/2005 23:00'!close	stream name = 'a stream' ifFalse: [stream close]! !!MDKeyedStream methodsFor: 'public' stamp: 'avi 4/17/2005 01:58'!flush	stream flush! !!MDKeyedStream methodsFor: 'public' stamp: 'avi 4/19/2005 01:49'!fromPosition: aNumber keysValuesAndPositionsDo: aBlock 	| position key |	stream position: aNumber.	[stream atEnd] whileFalse: 			[key := stream next: self keySize.			position := stream position.			aBlock				value: key				value: self readValue				value: position]! !!MDKeyedStream methodsFor: 'comparing' stamp: 'cwp 12/25/2006 15:25'!hash	^ self stream name hash! !!MDKeyedStream methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:11'!initializeWithStream: aPositionableStream	stream := aPositionableStream.	stream binary! !!MDKeyedStream methodsFor: 'accessing' stamp: 'cwp 4/10/2005 15:14'!keySize	^ 24! !!MDKeyedStream methodsFor: 'public' stamp: 'avi 4/17/2005 02:11'!keysValuesAndPositionsDo: aBlock 	self fromPosition: 0 keysValuesAndPositionsDo: aBlock			! !!MDKeyedStream methodsFor: 'public' stamp: 'avi 4/17/2005 01:38'!nextValuePosition	^ stream size + self keySize! !!MDKeyedStream methodsFor: 'public' stamp: 'cwp 4/10/2005 17:29'!position	^ stream position! !!MDKeyedStream methodsFor: 'private' stamp: 'cwp 10/22/2008 20:44'!readValue	| length |	[length := stream nextInt32]		on: Error		do: [:error | ^ nil].	^ stream next: length.	! !!MDKeyedStream methodsFor: 'accessing' stamp: 'avi 3/22/2006 19:23'!reopen	stream name = 'a stream' ifFalse: [stream reopen; binary]! !!MDKeyedStream methodsFor: 'accessing' stamp: 'cwp 4/10/2005 14:53'!stream	^ stream! !!MDKeyedStream methodsFor: 'public' stamp: 'cwp 10/31/2008 23:49'!valueAtPosition: anInteger	[stream position: anInteger]		on: Error		do: [:err | ^ nil].	^ self readValue! !!MDKeyedStream class methodsFor: 'as yet unclassified' stamp: 'avi 4/17/2005 01:19'!on: aStream	^ self basicNew initializeWithStream: aStream! !TestCase subclass: #MDKeyedStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDKeyedStreamTest instVarNames includes: 'dataStream') ifFalse:	[MDKeyedStreamTest addInstVarName: 'dataStream']!(MDKeyedStreamTest instVarNames includes: 'baseStream') ifFalse:	[MDKeyedStreamTest addInstVarName: 'baseStream']!!MDKeyedStreamTest methodsFor: 'support' stamp: 'cwp 4/10/2005 16:24'!append: aSmallInteger	dataStream 		appendKey: (self key: aSmallInteger)		value: (self value: aSmallInteger).! !!MDKeyedStreamTest methodsFor: 'support' stamp: 'cwp 4/10/2005 16:19'!assert: bytes is: aSmallInteger	self assert: bytes last = aSmallInteger! !!MDKeyedStreamTest methodsFor: 'support' stamp: 'cwp 5/22/2008 00:11'!bytes: count containing: aSmallInteger	| key |	key := ByteArray new: count.	key at: key size put: aSmallInteger.	^ key! !!MDKeyedStreamTest methodsFor: 'support' stamp: 'cwp 4/10/2005 16:02'!key: aSmallInteger	^ self bytes: dataStream keySize containing: aSmallInteger! !!MDKeyedStreamTest methodsFor: 'running' stamp: 'avi 4/17/2005 01:19'!setUp	baseStream := RWBinaryOrTextStream on: (ByteArray new: 100).	dataStream := MDKeyedStream on: baseStream! !!MDKeyedStreamTest methodsFor: 'tests' stamp: 'cwp 4/10/2005 16:11'!testAppend	self append: 1.	dataStream keysValuesAndPositionsDo: 		[:k :v :p |		self assert: k is: 1.		self assert: v is: 1.		self assert: p >= 0]! !!MDKeyedStreamTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:11'!testKeysValuePositions	| index position |	1 to: 3 do: [:i | self append: i].	index := 1.	position := -1.	dataStream keysValuesAndPositionsDo: 		[:k :v :p |		self assert: k is: index.		self assert: v is: index.		self assert: p > position.		position := p.		index := index + 1]! !!MDKeyedStreamTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:11'!testPosition	| position |	position := dataStream nextValuePosition.	self append: 1.	dataStream keysValuesAndPositionsDo: 		[:k :v :p | self assert: p = position].! !!MDKeyedStreamTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:11'!testValueAtPosition	| position |	self append: 1.	dataStream keysValuesAndPositionsDo: 		[:k :v :p | position := p].	self assert: (dataStream valueAtPosition: position) is: 1! !!MDKeyedStreamTest methodsFor: 'support' stamp: 'cwp 4/10/2005 16:07'!value: aSmallInteger	^ self bytes: dataStream keySize * 2 containing: aSmallInteger! !Object subclass: #MDMarshal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Serialization'!!MDMarshal commentStamp: 'cwp 11/17/2008 00:53' prior: 0!I am a stub. The real work of serialization and materialization is done by MDSerializer and MDMaterializer. My purpose is for backward compatibility when updating MC2 itself.!!MDMarshal class methodsFor: 'public' stamp: 'cwp 4/19/2008 19:49'!isMemo: aByteArray	"Evil hack to check whether a serialized object is an instance	MDMemo, without actually materializing it."		^ aByteArray beginsWith: #(23 5 9 7)! !!MDMarshal class methodsFor: 'public' stamp: 'cwp 11/17/2008 00:50'!materialize: aByteArray	^ MDMaterializer materialize: aByteArray! !!MDMarshal class methodsFor: 'public' stamp: 'cwp 11/17/2008 00:50'!materializeFrom: aReadStream	^ MDMaterializer materializeFrom: aReadStream! !!MDMarshal class methodsFor: 'initializing' stamp: 'cwp 11/17/2008 00:50'!resetMap	MDMaterializer initializeTypes! !!MDMarshal class methodsFor: 'public' stamp: 'cwp 11/17/2008 01:05'!serialize: anObject	"Returns a ByteArray containing a serialized version of the parameter."		^ MDSerializer serialize: anObject! !!MDMarshal class methodsFor: 'public' stamp: 'cwp 11/17/2008 00:51'!serialize: anObject on: aWriteStream	^ MDSerializer serialize: anObject on: aWriteStream! !Object subclass: #MDMaterializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Serialization'!(MDMaterializer instVarNames includes: 'decoder') ifFalse:	[MDMaterializer addInstVarName: 'decoder']!(MDMaterializer classVarNames includes: 'Types') ifFalse:	[MDMaterializer addClassVarName: 'Types']!!MDMaterializer methodsFor: 'private' stamp: 'cwp 11/15/2008 12:31'!knownClasses	^ { 		MDSliceElement.		MDDefinitionVariant.		MDRemovalVariant.		MDNullVersion.		MDElementVersion.		MDSnapshot.		MDMemo.		MDFakeElement.		MDClassElement.		MDClassCommentElement.		MDInstVarElement.		MDClassVarElement.		MDClassInstVarElement.		MDPoolImportElement.		MDMethodElement	 }! !!MDMaterializer methodsFor: 'public' stamp: 'cwp 9/1/2008 20:02'!materialize	| type selector |	type := decoder getType.	selector := Types 		at: type		ifAbsent: [ self error: 'unrecognized type' ].	^ self perform: selector! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeArray	| size array |	size := self materialize.	array := Array new: size.	1 	to: size		do:	[:i | array at: i put: self materialize ].	^ array! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeBlockContext	| method sender pc numArgs startpc home context |	context := Object new.	method := self materialize.	sender := self materialize.	pc := self materialize.	numArgs := self materialize.	startpc := self materialize.	home := self materialize.	context become: (BlockContext newForMethod: method).	context		home: home startpc: startpc nargs: numArgs ;		swapSender: sender ;		pc: pc.	^ context! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/1/2008 19:54'!materializeByte	^ decoder getByte! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeClass	| name class |	name := self materialize.	class := Smalltalk at: name.	"consume the inst var names"	self materialize timesRepeat: [ self materialize ].	^ class! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeDictionary	| size dictionary |	size := self materialize.	dictionary := Dictionary new: size.	size timesRepeat: 		[ dictionary 			at: self materialize			put: self materialize ].	^ dictionary! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:30'!materializeFalse	^ false! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/1/2008 19:59'!materializeFloat	^ decoder getFloat! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:46'!materializeHashedObject	| object |	object := self materialize basicNew.	1		to: object class instSize 		do: [:i | object instVarAt: i put: (self materialize)].	object initHashstamp.	^ object! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:45'!materializeHashstamp	| ts |	ts := MDHashstamp new.	decoder getBytesInto: ts.	^ ts! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:32'!materializeKnownClass	| index |	index := self materialize.	^ self knownClasses at: index! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/2/2008 07:31'!materializeLargeNegativeInteger	| size |	size := self materialize.	^ (decoder getIntegerOfSize: size) negated! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/2/2008 07:31'!materializeLargePositiveInteger	| size |	size := self materialize.	^ decoder getIntegerOfSize: size! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeMethodContext	| method sender pc stackp env receiver context |	context := Object new.	method := self materialize.	sender := self materialize.	pc := self materialize.	stackp := self materialize.	env := self materialize.	receiver := self materialize.	context become: (MethodContext newForMethod: method).	context		setSender: sender			receiver: receiver			method: method			arguments: #() ;		pc: pc ;		stackp: stackp ;		myEnv: env.	self readPointersInto: context.	^ context! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:30'!materializeNil	^ nil! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeObject	| theClass object tmp |	object := Object new.	theClass := self materialize.	tmp := theClass isVariable 		ifTrue: [ theClass new: self materialize ]		ifFalse: [ theClass basicNew ].	object become: tmp.	1 		to: object class instSize		do: 			[ : i | 			object 				instVarAt: i				put: self materialize ].	object class isVariable ifTrue: 		[ object class isPointers 			ifTrue: [ self readPointersInto: object ]			ifFalse: [ decoder getBytesInto: object ] ].	^ object! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:35'!materializeProperties	| size dictionary |	size := self materialize.	dictionary := MDPropertyDictionary new: size.	size timesRepeat: 		[ dictionary 			at: self materialize			put: self materialize ].	^ dictionary! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:49'!materializeSet	| size set |	size := self materialize.	set := Set new: size.	size timesRepeat: [ set add: self materialize ].	^ set! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/1/2008 19:55'!materializeSingleton	^ decoder getSingleton! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/1/2008 19:57'!materializeSmallNegativeInteger	^ decoder getSmallInteger negated! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/1/2008 19:58'!materializeSmallPositiveInteger	^ decoder getSmallInteger! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/2/2008 07:35'!materializeSymbol	^ self materializeUtf8String asSymbol! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:45'!materializeTimestamp	| ts |	ts := MDTimestamp new.	decoder getBytesInto: ts.	^ ts! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:30'!materializeTrue	^ true! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/2/2008 07:42'!materializeUtf16String	| size |	size := self materialize.	^ decoder getUtf16StringOfSize: size.	! !!MDMaterializer methodsFor: 'types' stamp: 'cwp 9/2/2008 07:41'!materializeUtf8String	| size |	size := self materialize.	^ decoder getUtf8StringOfSize: size.	! !!MDMaterializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:14'!read: type with: aMarshal	| object |	object := self objectOfType: type.	self readState: object with: aMarshal.	^ object! !!MDMaterializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:14'!readBytes: anObject with: aMarshal	1 		to: anObject byteSize 		do: [:index | anObject byteAt: index put: aMarshal read]! !!MDMaterializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:15'!readPointers: anObject with: aMarshal	1 		to: anObject size 		do: [:index | anObject at: index put: aMarshal materialize]! !!MDMaterializer methodsFor: 'private' stamp: 'cwp 9/3/2008 19:43'!readPointersInto: anObject 	1	to: anObject size		do:	[ :i | anObject at: i put: self materialize ]! !!MDMaterializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/12/2008 21:13'!setClass: aClass	class := aClass! !!MDMaterializer methodsFor: 'initialize-release' stamp: 'cwp 11/15/2008 12:47'!setStream: aStream 	decoder := MDObjectDecoder on: aStream.	! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 4/12/2008 21:13'!class: aClass	^ self new setClass: aClass! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 9/1/2008 19:39'!initialize	self initializeTypes! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:29'!initializeTypes	Types := #(		materializeObject		materializeClass		materializeClass		materializeClass		materializeKnownClass		materializeNil		materializeTrue		materializeFalse		materializeByte				materializeSmallPositiveInteger		materializeSmallNegativeInteger		materializeLargePositiveInteger		materializeLargeNegativeInteger		materializeSymbol		materializeUtf8String		materializeUtf16String		materializeArray		materializeSet		materializeDictionary		materializeProperties		materializeTimestamp		materializeHashstamp		materializeHashedObject	)! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:57'!isMemo: aByteArray	"Evil hack to check whether a serialized object is an instance	MDMemo, without actually materializing it."	^ aByteArray beginsWith: #(23 5 9 7)! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 8/31/2008 15:57'!materialize: aByteArray	^ self materializeFrom: aByteArray readStream! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 8/31/2008 15:59'!materializeFrom: aReadStream	| instance |	instance := self on: aReadStream.	^ instance materialize! !!MDMaterializer class methodsFor: 'as yet unclassified' stamp: 'cwp 8/31/2008 15:56'!on: aReadStream	^ self new setStream: aReadStream! !TestCase subclass: #MDMaterializerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDMaterializerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 4/16/2008 22:04'!isAbstract	^ self name = #MDMaterializerTest! !Object subclass: #MDMemoChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!(MDMemoChunk instVarNames includes: 'memo') ifFalse:	[MDMemoChunk addInstVarName: 'memo']!!MDMemoChunk methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setMemo: aMemo	memo := aMemo! !!MDMemoChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 01:00'!writeOn: aStream	aStream 		nextPut: $";		nextPutAll: memo name;		cr.	memo description do:		[:ch | 		aStream nextPut: ch. 		ch = $" ifTrue: [aStream nextPut: $"].		ch = $!! ifTrue: [aStream nextPut: $!!]].	aStream		nextPutAll: '"!!';		cr! !!MDMemoChunk class methodsFor: 'as yet unclassified' stamp: 'cwp 3/24/2008 23:19'!on: aMemo	^ self new setMemo: aMemo! !Object subclass: #MDMerge	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDMerge instVarNames includes: 'local') ifFalse:	[MDMerge addInstVarName: 'local']!(MDMerge instVarNames includes: 'remote') ifFalse:	[MDMerge addInstVarName: 'remote']!(MDMerge instVarNames includes: 'resolution') ifFalse:	[MDMerge addInstVarName: 'resolution']!!MDMerge methodsFor: 'operations' stamp: 'cwp 3/2/2006 14:57'!applyTo: aWorkingCopy	aWorkingCopy includeVersion: resolution onConflict: [:l :r | r variant]! !!MDMerge methodsFor: 'operations' stamp: 'cwp 5/22/2008 00:10'!chooseLocal	resolution := local! !!MDMerge methodsFor: 'operations' stamp: 'cwp 5/22/2008 00:10'!chooseRemote	resolution := remote! !!MDMerge methodsFor: 'printing' stamp: 'cwp 10/25/2008 14:39'!displayOn: aStream	self remote element printOn: aStream! !!MDMerge methodsFor: 'testing' stamp: 'cwp 3/17/2005 23:21'!isConflict	^ remote conflictsWith: local! !!MDMerge methodsFor: 'testing' stamp: 'cwp 3/17/2005 23:16'!isLocal	^ resolution == local! !!MDMerge methodsFor: 'testing' stamp: 'avi 3/21/2006 00:14'!isNoOp	^ local = remote! !!MDMerge methodsFor: 'testing' stamp: 'cwp 3/17/2005 23:19'!isRemote	^ resolution == remote! !!MDMerge methodsFor: 'testing' stamp: 'cwp 6/9/2005 09:01'!isResolved	^ resolution notNil! !!MDMerge methodsFor: 'accessing' stamp: 'cwp 3/17/2005 23:28'!local	^ local! !!MDMerge methodsFor: 'accessing' stamp: 'cwp 3/17/2005 23:28'!remote	^ remote! !!MDMerge methodsFor: 'accessing' stamp: 'cwp 3/17/2005 23:28'!resolution	^ resolution! !!MDMerge methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:10'!setLocal: localVersion remote: remoteVersion	local := localVersion.	remote := remoteVersion.	resolution := local successor: remote! !!MDMerge class methodsFor: 'instance creation' stamp: 'cwp 5/22/2008 00:10'!toInclude: aVersion in: aWorkingCopy 	| local |	local := aWorkingCopy versionForElement: aVersion element.	^ self basicNew setLocal: local remote: aVersion.! !Notification subclass: #MDMergeRequest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDMergeRequest instVarNames includes: 'merges') ifFalse:	[MDMergeRequest addInstVarName: 'merges']!(MDMergeRequest instVarNames includes: 'workingCopy') ifFalse:	[MDMergeRequest addInstVarName: 'workingCopy']!!MDMergeRequest methodsFor: 'accessing' stamp: 'cwp 3/25/2005 21:23'!merges	^ merges! !!MDMergeRequest methodsFor: 'accessing' stamp: 'dc 6/14/2007 10:17'!merges: aCollection	merges := aCollection! !!MDMergeRequest methodsFor: 'accessing' stamp: 'dc 6/14/2007 10:17'!workingCopy	^ workingCopy ! !!MDMergeRequest methodsFor: 'accessing' stamp: 'dc 6/14/2007 10:17'!workingCopy: aWorkingCopy	workingCopy := aWorkingCopy! !!MDMergeRequest class methodsFor: 'signalling' stamp: 'dc 7/19/2007 09:53'!includeAll: versions in: aWorkingCopy	| merges |	merges := versions				collect: [:ea | MDMerge toInclude: ea in: aWorkingCopy]				thenSelect: [:ea | ea isNoOp not].	^ self new		merges: merges;		workingCopy: aWorkingCopy;		signal! !TestCase subclass: #MDMethodDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Tests'!!MDMethodDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!testAccept	| variant definition source new |	source := 'a ^ $B'.	variant := self variant.	definition := MDMethodDefinition on: variant.	definition callback: [:v | new := v].	definition accept: source notifying: nil.	self deny: new isNil.	self assert: new properties source = source.! !!MDMethodDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!testText	| variant definition |	variant := self variant.	definition := MDMethodDefinition on: variant.	self assert: definition text = variant properties source.! !!MDMethodDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!variant	| variant |	variant := MDDefinitionVariant forElement: 				(MDMethodElement className: #BogusA selector: #a).	variant properties		category: #letters;		initials: 'cwp';		timestamp: MDTimestamp now;		source: 'a ^ $A'.	^ variant! !Object subclass: #MDMockLink	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDMockLink instVarNames includes: 'injected') ifFalse:	[MDMockLink addInstVarName: 'injected']!(MDMockLink instVarNames includes: 'expected') ifFalse:	[MDMockLink addInstVarName: 'expected']!(MDMockLink instVarNames includes: 'open') ifFalse:	[MDMockLink addInstVarName: 'open']!!MDMockLink methodsFor: 'asserting' stamp: 'cwp 1/4/2008 12:32'!assert: actual matches: expectation	actual = expectation ifFalse: [TestFailure signal: 'Unexpected message']! !!MDMockLink methodsFor: 'open/close' stamp: 'cwp 5/22/2008 00:11'!close	open := false! !!MDMockLink methodsFor: 'accessing' stamp: 'cwp 1/4/2008 14:19'!description	^ 'Mock'! !!MDMockLink methodsFor: 'asserting' stamp: 'cwp 1/4/2008 12:26'!expect: aMessage	expected add: aMessage! !!MDMockLink methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:11'!initialize	injected := OrderedCollection new.	expected := OrderedCollection new.	open := false! !!MDMockLink methodsFor: 'asserting' stamp: 'cwp 1/4/2008 12:25'!inject: aMessage	injected add: aMessage! !!MDMockLink methodsFor: 'open/close' stamp: 'cwp 1/4/2008 12:33'!isOpen	^ open! !!MDMockLink methodsFor: 'accessing' stamp: 'cwp 6/5/2008 07:17'!locator	^ MDNetLocator host: 'example.com' port: 7901! !!MDMockLink methodsFor: 'open/close' stamp: 'cwp 5/22/2008 00:11'!open	open := true! !!MDMockLink methodsFor: 'sending' stamp: 'cwp 1/4/2008 12:31'!send: aMessage	self assert: aMessage matches: expected removeFirst.	^ injected removeFirst! !!MDMockLink class methodsFor: 'as yet unclassified' stamp: 'cwp 11/20/2008 18:51'!new	^ self basicNew initialize! !Object subclass: #MDMonticelloAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!(MDMonticelloAdaptor instVarNames includes: 'registry') ifFalse:	[MDMonticelloAdaptor addInstVarName: 'registry']!(MDMonticelloAdaptor instVarNames includes: 'element') ifFalse:	[MDMonticelloAdaptor addInstVarName: 'element']!!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:36'!isLoadable: properties	self subclassResponsibility! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 23:29'!isPresent	self subclassResponsibility! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:36'!isUpToDate: properties	self subclassResponsibility ! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:36'!load: properties	self subclassResponsibility! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:37'!merge: properties into: otherProperties onFailure: aBlock	self subclassResponsibility! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:37'!remove	self subclassResponsibility ! !!MDMonticelloAdaptor methodsFor: 'initialize-release' stamp: 'cwp 3/4/2008 23:46'!setElement: anElement registry: aRegistry	element := anElement.	registry := aRegistry! !!MDMonticelloAdaptor methodsFor: 'public' stamp: 'cwp 3/4/2008 22:38'!update: properties	self subclassResponsibility! !!MDMonticelloAdaptor class methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 23:46'!on: anElement inRegistry: aRegistry	^ self new setElement: anElement registry: aRegistry! !Error subclass: #MDNetError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!Object subclass: #MDNetLink	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDNetLink instVarNames includes: 'locator') ifFalse:	[MDNetLink addInstVarName: 'locator']!(MDNetLink instVarNames includes: 'stream') ifFalse:	[MDNetLink addInstVarName: 'stream']!!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/12/2008 12:38'!close	stream close.	! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/12/2008 13:04'!description	^ locator description! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/12/2008 13:10'!isOpen	^ stream notNil and: [stream isConnected]! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/9/2008 16:03'!locator	^ locator! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!open	stream := locator createStream.	! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:44'!send: aMessage	self isOpen ifFalse: [self error: 'Link is not open'].	aMessage writeOn: stream.	stream flush.	^ MDNetMessage readFrom: stream! !!MDNetLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setLocator: aLocator	locator := aLocator! !!MDNetLink class methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 13:09'!host: aString	^ self locator: (MDNetLocator host: aString)! !!MDNetLink class methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:40'!host: aString port: anInteger	^ self locator: (MDNetLocator host: aString port: anInteger)! !!MDNetLink class methodsFor: 'as yet unclassified' stamp: 'cwp 1/9/2008 14:49'!locator: aLocator	^ self new setLocator: aLocator! !Object subclass: #MDNetListener	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDNetListener instVarNames includes: 'repository') ifFalse:	[MDNetListener addInstVarName: 'repository']!(MDNetListener instVarNames includes: 'port') ifFalse:	[MDNetListener addInstVarName: 'port']!(MDNetListener instVarNames includes: 'socket') ifFalse:	[MDNetListener addInstVarName: 'socket']!(MDNetListener instVarNames includes: 'process') ifFalse:	[MDNetListener addInstVarName: 'process']!!MDNetListener methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:23'!name	^ '[', repository description, ']'! !!MDNetListener methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!run	| connection |	[socket isValid] whileTrue:		[connection := socket waitForAcceptFor: 10 ifTimedOut: [nil].		connection ifNotNil: [MDServerLink 								serve: connection 								repository: repository]]			! !!MDNetListener methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setRepository: aRepository port: anInteger	repository := aRepository.	port := anInteger.	! !!MDNetListener methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!start	socket := Socket newTCP.	socket listenOn: port backlogSize: 10.	process := [self run] 				forkAt: Processor systemBackgroundPriority  				named: self name	! !!MDNetListener methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 23:09'!stop	socket closeAndDestroy! !!MDNetListener class methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!repository: aRepository startOn: anInteger	| listener |	listener := self new setRepository: aRepository port: anInteger.	listener start.	^ listener! !Object subclass: #MDNetLocator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDNetLocator instVarNames includes: 'host') ifFalse:	[MDNetLocator addInstVarName: 'host']!(MDNetLocator instVarNames includes: 'port') ifFalse:	[MDNetLocator addInstVarName: 'port']!!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!createStream	| class stream |	class := Smalltalk at: #FastSocketStream ifAbsent: [Smalltalk at: #SocketStream].	stream := class openConnectionToHostNamed: self host port: self port.	stream binary.	^ stream! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:32'!defaultPort	^ 6101! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:32'!description	^ String streamContents: 		[:stream |		stream nextPutAll: host.		port ifNotNil:			[stream 				nextPut: $:; 				print: port]]! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:32'!host	^ host! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:32'!port	^ port ifNil: [self defaultPort]! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setHost: aString port: anInteger	host := aString.	port := anInteger! !!MDNetLocator methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 21:43'!update: properties	^ properties		host: self host;		port: self port;		yourself! !!MDNetLocator class methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:31'!host: aString 	^ self host: aString port: nil! !!MDNetLocator class methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 21:29'!host: aString port: anInteger	^ self new setHost: aString port: anInteger! !TestCase subclass: #MDNetLocatorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDNetLocatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefaultPort	| locator |	locator := MDNetLocator host: 'source.wiresong.ca'.	self assert: locator port = 6101! !!MDNetLocatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDescription	| locator |	locator := MDNetLocator host: 'source.wiresong.ca' port: 6101.	self assert: locator description = 'source.wiresong.ca:6101'! !!MDNetLocatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDescriptionWithoutPort	| locator |	locator := MDNetLocator host: 'source.wiresong.ca'.	self assert: locator description = 'source.wiresong.ca'! !!MDNetLocatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testHost	| locator |	locator := MDNetLocator host: 'source.wiresong.ca'.	self assert: locator host = 'source.wiresong.ca'! !Object subclass: #MDNetMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 21:06'!assertMessageIs: aClass	(self isKindOf: aClass) ifFalse: [MDProtocolError signal]! !!MDNetMessage methodsFor: 'writing' stamp: 'cwp 1/3/2008 23:05'!bytes	^ ByteArray streamContents: [:stream | self writeOn: stream]! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 19:54'!checkForError	! !!MDNetMessage methodsFor: 'accessing' stamp: 'cwp 1/3/2008 23:15'!id	^ self class id! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 19:53'!isError	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 14:17'!isGoodbye	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 12:36'!isHello	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 14:24'!isMemos	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 12:39'!isObjects	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 21:01'!isRequestObjects	^ false! !!MDNetMessage methodsFor: 'testing' stamp: 'cwp 1/4/2008 20:57'!isThankYou	^ false! !!MDNetMessage methodsFor: 'intialize-release' stamp: 'cwp 1/3/2008 23:23'!setContents: anObject	self subclassResponsibility! !!MDNetMessage methodsFor: 'writing' stamp: 'cwp 1/3/2008 23:32'!writeContentsOn: aStream	! !!MDNetMessage methodsFor: 'writing' stamp: 'cwp 1/3/2008 23:08'!writeOn: aStream	aStream nextPut: self id.	self writeContentsOn: aStream! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/3/2008 23:04'!fromBytes: aByteArray	^ self readFrom: aByteArray readStream! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/3/2008 23:15'!id	self subclassResponsibility! !!MDNetMessage class methodsFor: 'testing' stamp: 'cwp 1/4/2008 00:17'!isConcrete	^ self class includesSelector: #id! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/4/2008 00:17'!messageClassWithId: anInteger	^ self allSubclasses 		detect: [:ea | ea isConcrete and: [ea id = anInteger]]		ifNone: [self messageIdNotFound: anInteger]! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/3/2008 23:58'!messageClasses	^ self allSubclasses select: [:ea | ea class includesSelector: #id]! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/3/2008 23:12'!messageIdNotFound: id	^ self error: 'Message ', id asString, ' not understood'! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 1/3/2008 23:27'!readContentsFrom: aStream	^ self with: (MDMarshal materializeFrom: aStream)! !!MDNetMessage class methodsFor: 'reading' stamp: 'cwp 5/22/2008 00:11'!readFrom: aStream	| class |	class := self messageClassWithId: aStream next.	^ class readContentsFrom: aStream! !!MDNetMessage class methodsFor: 'instance creation' stamp: 'cwp 1/3/2008 23:23'!with: aSet	^ self new setContents: aSet! !Object subclass: #MDNetService	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDNetService instVarNames includes: 'repository') ifFalse:	[MDNetService addInstVarName: 'repository']!!MDNetService methodsFor: 'public' stamp: 'cwp 1/19/2008 01:32'!description	^ repository description! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/4/2008 21:27'!handleGet: message	^ MDObjects with: (repository getAll: message hashstamps)! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/8/2008 18:43'!handleGetHashstamps: message	^ MDAllHashstamps with: (repository allHashstamps)! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/4/2008 22:12'!handleGetMemos: message	^ MDMemos with: (repository memos)! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/4/2008 22:26'!handleGoodbye: message	^ MDGoodbye new! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/4/2008 22:08'!handleHello: message	^ MDHello new! !!MDNetService methodsFor: 'public' stamp: 'cwp 1/4/2008 22:43'!handleMessage: aMessage	^ [aMessage handledBy: self]		on: Error		do: [:err | MDProcessingError with: err description]! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 5/22/2008 00:11'!handleOfferObjects: message	| wanted |	wanted := repository selectFrom: message hashstamps.	^ MDRequestObjects with: wanted! !!MDNetService methodsFor: 'message handlers' stamp: 'cwp 1/4/2008 22:34'!handlePutObjects: message	^ 	[repository putAll: message objects.		MDThankYou with: message objects size]			on: Error			do: [:err | MDStorageFailed with: err description]! !!MDNetService methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:11'!setRepository: aRepository	repository := aRepository! !!MDNetService class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 21:22'!for: aRepository	^ self new setRepository: aRepository! !Object subclass: #MDNotificationAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakPlatform'!(MDNotificationAdaptor classVarNames includes: 'MDInstance') ifFalse:	[MDNotificationAdaptor addClassVarName: 'MDInstance']!!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!announce: anElement toAll: objects startingAt: start	| listener |	(start to: objects size) do: 		[:i | 		[listener := objects at: i.		listener ifNotNil: [listener noteElementChanged: anElement]]			on: Halt, Exception			do: 				[:exc | 				self announce: anElement toAll: objects startingAt: i+1.				exc pass]]! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 5/22/2008 00:08'!noteClassChanged: anEvent	| element |	element := MDClassElement className: anEvent item name.	self noteElementChanged: element! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 5/22/2008 00:08'!noteClassCommented: anEvent	| element |	element := MDClassCommentElement className: (anEvent item name).	self noteElementChanged: element! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 4/7/2008 21:54'!noteClassModified: anEvent	anEvent item isMeta ifFalse: [self processClass: anEvent].	anEvent areInstVarsModified ifTrue: [self processInstVars: anEvent].	anEvent areClassVarsModified ifTrue: [self processClassVars: anEvent].	anEvent areSharedPoolsModified ifTrue: [self processPools: anEvent].! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 7/30/2008 18:30'!noteElementChanged: anElement	MDAnnouncer announce: (MDElementModified for: anElement)! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 3/9/2008 15:00'!noteMethodChanged: anEvent	| element class |	class := anEvent environmentAt: #class.	element := MDMethodElement				className: class theNonMetaClass name				selector: (anEvent environmentAt: #selector)				classIsMeta: class isMeta.	self noteElementChanged: element ! !!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!processClass: anEvent	| element |	(anEvent isSuperclassModified or: [anEvent item category ~= anEvent oldItem category])		ifTrue:			[element := MDClassElement className: anEvent item name.			self noteElementChanged: element].! !!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!processClassVars: anEvent	| changed element |	changed := self xor: anEvent classVarNames with: anEvent oldClassVarNames.	changed do:		[:name |		element := MDClassVarElement className: anEvent item name name: name.		self noteElementChanged: element]! !!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!processInstVars: anEvent	| changed element class |	changed := self xor: anEvent instVarNames with: anEvent oldInstVarNames.	changed do:		[:name |		class := anEvent item isMeta ifTrue: [MDClassInstVarElement] ifFalse: [MDInstVarElement].		element := class className: anEvent item name name: name.		self noteElementChanged: element]! !!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!processPools: anEvent	| changed element name |	changed := self xor: anEvent sharedPools with: anEvent oldSharedPools.	changed do:		[:pool |		name := Smalltalk keyAtValue: pool.		element := MDPoolImportElement className: anEvent item name name: name.		self noteElementChanged: element]! !!MDNotificationAdaptor methodsFor: 'registration' stamp: 'cwp 3/9/2008 15:14'!register	SystemChangeNotifier uniqueInstance 		notify: self 		ofSystemChangesOfItem: #class 		change: #Commented 		using: #noteClassCommented:;				notify: self 		ofSystemChangesOfItem: #class 		change: #Modified 		using: #noteClassModified:;				notify: self		ofSystemChangesOfItem: #class		change: #Added		using: #noteClassChanged:;				notify: self		ofSystemChangesOfItem: #method		using: #noteMethodChanged:.! !!MDNotificationAdaptor methodsFor: 'registration' stamp: 'cwp 3/9/2008 13:25'!registerAll	SystemChangeNotifier uniqueInstance 		notify: self ofAllSystemChangesUsing: #transcribe:! !!MDNotificationAdaptor methodsFor: 'callbacks' stamp: 'cwp 3/9/2008 13:26'!transcribe: anEvent	Transcript cr; show: anEvent asString! !!MDNotificationAdaptor methodsFor: 'registration' stamp: 'cwp 3/9/2008 13:06'!unregister	SystemChangeNotifier uniqueInstance 		noMoreNotificationsFor: self! !!MDNotificationAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:08'!xor: left with: right	| result |	result := Set new.	left do: [:ea | (right includes: ea) ifFalse: [result add: ea]].	right do: [:ea | (left includes: ea) ifFalse: [result add: ea]].	^ result! !!MDNotificationAdaptor class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:10'!default	^ MDInstance ifNil: 		[ MDInstance := self new.		MDInstance register ]! !!MDNotificationAdaptor class methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 21:26'!initialize	self default! !!MDNotificationAdaptor class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:10'!reset	MDInstance ifNotNil: [ MDInstance unregister ].	MDInstance := nil! !Object subclass: #MDObjectDecoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Serialization'!(MDObjectDecoder instVarNames includes: 'stream') ifFalse:	[MDObjectDecoder addInstVarName: 'stream']!!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 8/31/2008 19:30'!getByte	^ stream next! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/2/2008 00:50'!getBytesInto: anObject 	1 		to: anObject byteSize		do: 			[ : index | 			anObject 				byteAt: index				put: stream next ]! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:32'!getFloat	| hi lo |	hi := self getIntegerOfSize: 4.	lo := self getIntegerOfSize: 4.	^ (Float basicNew: 2)		at: 1 put: hi;		at: 2 put: lo;		yourself! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:32'!getIntegerOfSize: size 	| value |	value := 0.	size timesRepeat: [value := (value bitShift: 8) bitOr: stream next].	^ value! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/1/2008 19:34'!getSingleton	| index |	index := stream next.	^ #(nil true false) at: index! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 8/31/2008 16:46'!getSmallInteger	| hi lo |	hi := stream next.	lo := stream next.	^ (hi bitShift: 8) + lo! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 8/31/2008 16:45'!getType	^ stream next! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:44'!getUtf16StringOfSize: size 	| string |	string := String new: size.	1 to: size do: 		[ :index | 		string at: index put: self readUtf16Character ].	^ string! !!MDObjectDecoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:43'!getUtf8StringOfSize: size	| string |	string := String new: size.	1 to: size do: [:index | string at: index put: self readUtf8Character].	^ string! !!MDObjectDecoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:39'!readTwoBytes	| hi lo |	hi := stream next.	lo := stream next.	^ (hi bitShift: 8) bitOr: lo! !!MDObjectDecoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:37'!readUtf16Character	| value |	value := self readTwoBytes.	^ (value < 56320 or: [ value > 57343 ]) 		ifTrue: [ Unicode value: value ]		ifFalse: [ self readUtf16CharacterGiven: value ]! !!MDObjectDecoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:44'!readUtf16CharacterGiven: first	| second |	second := self readTwoBytes.	^ Unicode value: ((first bitShift: 10) bitOr: second) + 16r10000! !!MDObjectDecoder methodsFor: 'private' stamp: 'cwp 9/9/2008 08:00'!readUtf8Character	| value |	value := stream next.	value <= 127 		ifTrue: [ ^ Unicode value: value ]		ifFalse: 			[value <= 223 				ifTrue: 					[ value := (value bitAnd: 31) bitShift: 6.					value := value bitOr: (stream next bitAnd: 63)]				ifFalse: 					[ value := (value bitAnd: 15) bitShift: 12.					value := value bitOr: ((stream next bitAnd: 63) bitShift: 6).					value := value bitOr: (stream next bitAnd: 63)].			^ Unicode value: value ]! !!MDObjectDecoder methodsFor: 'initialize-release' stamp: 'cwp 9/2/2008 07:38'!setStream: aReadStream 	stream := aReadStream.! !!MDObjectDecoder class methodsFor: 'as yet unclassified' stamp: 'cwp 9/2/2008 07:38'!on: aReadStream	^ self new setStream: aReadStream! !Object subclass: #MDObjectEncoder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Serialization'!(MDObjectEncoder instVarNames includes: 'stream') ifFalse:	[MDObjectEncoder addInstVarName: 'stream']!!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 8/31/2008 19:24'!putByte: anInteger	stream nextPut: anInteger! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 9/2/2008 00:44'!putBytesFrom: anObject	1 		to: anObject byteSize 		do: [:index | stream nextPut: (anObject byteAt: index)]! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 8/31/2008 20:19'!putFloat: aFloat	self write32BitInteger: (aFloat at: 1).	self write32BitInteger: (aFloat at: 2).! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:24'!putLargeInteger: anInteger size: size	| byte |	(size - 1 to: 0 by: -1) do:		[:index |		byte := (anInteger bitShift: index * -8) bitAnd: 255.		stream nextPut: byte]! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 11/12/2008 20:39'!putSingleton: anObject	| index |	index := #(nil true false) indexOf: anObject.	stream nextPut: index + 5! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 8/31/2008 16:38'!putSmallInteger: anInteger	stream nextPut: (anInteger bitShift: -8).	stream nextPut: (anInteger bitAnd: 255). 3! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 8/31/2008 16:28'!putType: aByte	stream nextPut: aByte! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:25'!putUtf16String: aString	| value |	aString do:		[:char |		value := char asUnicode.		value < 16r10000 			ifTrue: [self writeTwoByteCode: value]			ifFalse: [self writeFourByteCode: value]]! !!MDObjectEncoder methodsFor: 'public' stamp: 'cwp 9/2/2008 07:25'!putUtf8String: aString		aString do: [ :char | self writeUtf8Code: char asUnicode ]! !!MDObjectEncoder methodsFor: 'initialize-release' stamp: 'cwp 8/31/2008 16:30'!setStream: aWriteStream	stream := aWriteStream! !!MDObjectEncoder methodsFor: 'private' stamp: 'cwp 8/31/2008 20:18'!write32BitInteger: anInteger	stream				nextPut: (anInteger bitShift: -24);		nextPut: ((anInteger bitShift: -16) bitAnd: 255);		nextPut: ((anInteger bitShift: -8) bitAnd: 255);		nextPut: (anInteger bitAnd: 255)! !!MDObjectEncoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:28'!writeFourByteCode: anInteger	| value |	value := 16r10000 - anInteger.	stream nextPut: ((value bitShift: -18) bitOr: 16rD8).	stream nextPut: ((value bitShift: -10) bitAnd: 16rFF).	stream nextPut: ((value bitShift: -8) bitOr: 16rDC).	stream nextPut: (value bitAnd: 16rFF).	! !!MDObjectEncoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:27'!writeTwoByteCode: value	stream nextPut: (value bitShift: -8).	stream nextPut: (value bitAnd: 16rFF).! !!MDObjectEncoder methodsFor: 'private' stamp: 'cwp 8/31/2008 22:23'!writeUtf8Code: value	value <= 16r7F		ifTrue: [stream nextPut: value]		ifFalse:			[value <= 16r7FF				ifTrue: 					[stream nextPut: ((value bitShift: -6) bitOr: 16rC0).					stream nextPut: ((value bitAnd: 16r3F) bitOr: 16r80)]				ifFalse:					[value <= 16rFFFF						ifTrue:							[stream nextPut: ((value bitShift: -12) bitOr: 16rE0).							stream nextPut: (((value bitShift: -6) bitAnd: 16r3F) bitOr: 16r80).							stream nextPut: ((value bitAnd: 16r3F) bitOr: 16r80)]]]! !(MDObjectEncoder class instVarNames includes: 'stream') ifFalse:	[MDObjectEncoder class addInstVarName: 'stream']!!MDObjectEncoder class methodsFor: 'as yet unclassified' stamp: 'cwp 8/31/2008 16:30'!on: aWriteStream	^ self new setStream: aWriteStream! !Object subclass: #MDPlatform	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakPlatform'!!MDPlatform methodsFor: 'testing' stamp: 'cwp 6/23/2008 08:56'!aboriginalAbc	"A wide string containing the first 3 Canadian Aboriginal Syllabics, with unicode	values U+1401, U+1402, U+1403. Each character is encoded as 4 bytes in the array literal"		^ String fromByteArray: #(63 192 20 1 63 192 20 2 63 192 20 3)! !!MDPlatform methodsFor: 'image' stamp: 'cwp 10/20/2008 21:26'!imageName	^ SmalltalkImage current imageName! !!MDPlatform methodsFor: 'image' stamp: 'cwp 11/17/2007 01:25'!initials	^ Utilities authorInitials ! !!MDPlatform methodsFor: 'image' stamp: 'cwp 3/9/2008 16:08'!notifier	^ MDNotificationAdaptor default! !!MDPlatform methodsFor: 'user interface' stamp: 'cwp 12/28/2007 21:06'!prompt: prompt default: default	^ self request: prompt initialAnswer: default! !!MDPlatform methodsFor: 'constructing' stamp: 'cwp 4/7/2008 23:23'!serializationMap	^ MDSerializationMap new! !!MDPlatform methodsFor: 'cursor' stamp: 'cwp 5/3/2008 01:19'!showCursor: aSymbol	| cursor |	"cursor := aSymbol ifNotNil: [Cursor perform: aSymbol].	ActiveHand showTemporaryCursor: cursor.	World doOneCycleNow"! !!MDPlatform methodsFor: 'constructing' stamp: 'cwp 12/22/2006 22:25'!systemEditor	^ Smalltalk! !!MDPlatform methodsFor: 'time' stamp: 'cwp 5/10/2008 18:40'!timestampSeconds	^ Time primSecondsClock - 2498169600! !!MDPlatform methodsFor: 'image' stamp: 'cwp 12/28/2007 21:25'!updateMemoProperties: properties	properties 		initials: Utilities authorInitials;		author: MDAuthorInfo value! !!MDPlatform methodsFor: 'testing' stamp: 'cwp 3/2/2008 12:19'!variablePointersObject	^ (ActionSequence new: 2)		at: 1 put: #a;		at: 2 put: #b;		yourself! !!MDPlatform methodsFor: 'testing' stamp: 'cwp 6/23/2008 08:42'!wideString	^ String fromString: 'abc'! !!MDPlatform methodsFor: 'cursor' stamp: 'cwp 12/22/2007 22:27'!withCursor: aSymbol do: aBlock	self showCursor: aSymbol.	^ aBlock ensure: [self showCursor: nil]! !(MDPlatform class instVarNames includes: 'current') ifFalse:	[MDPlatform class addInstVarName: 'current']!!MDPlatform class methodsFor: 'as yet unclassified' stamp: 'cwp 5/10/2008 18:51'!current	^ current ifNil: [current := self new]! !!MDPlatform class methodsFor: 'as yet unclassified' stamp: 'cwp 5/10/2008 18:51'!current: aPlatform	current := aPlatform! !Dictionary subclass: #MDPropertyDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDPropertyDictionary commentStamp: 'cwp 5/9/2006 23:27' prior: 0!I store the state of particular variant of an element. !(MDPropertyDictionary instVarNames includes: 'localReference') ifFalse:	[MDPropertyDictionary addInstVarName: 'localReference']!!MDPropertyDictionary methodsFor: 'accessing' stamp: 'cwp 4/3/2005 20:33'!at: key	^ self at: key ifAbsent: [nil]! !!MDPropertyDictionary methodsFor: 'accessing' stamp: 'cwp 4/3/2005 20:31'!at: key put: anObject	anObject ifNotNil: [super at: key put: anObject]! !!MDPropertyDictionary methodsFor: 'convenience' stamp: 'cwp 4/3/2005 20:36'!doesNotUnderstand: aMessage	aMessage selector isUnary ifTrue: [^ self at: aMessage selector].	(aMessage selector isKeyword		and: [aMessage arguments size = 1])			ifTrue: [^ self						at: aMessage selector allButLast asSymbol						put: aMessage arguments first].	super doesNotUnderstand: aMessage.! !!MDPropertyDictionary methodsFor: 'accessing' stamp: 'avi 3/14/2005 18:08'!localReference	^ localReference! !!MDPropertyDictionary methodsFor: 'accessing' stamp: 'dc 6/14/2007 06:12'!localReference: anObject	localReference := anObject! !!MDPropertyDictionary methodsFor: 'serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeProperties: self! !!MDPropertyDictionary methodsFor: 'convenience' stamp: 'cwp 12/31/2006 01:09'!name	^ self at: #name! !TestCase subclass: #MDPropertyDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDPropertyDictionaryTest instVarNames includes: 'properties') ifFalse:	[MDPropertyDictionaryTest addInstVarName: 'properties']!!MDPropertyDictionaryTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!setUp	properties := MDPropertyDictionary new.! !!MDPropertyDictionaryTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2005 20:32'!testGetNil	self assert: (properties at: #undefined) isNil! !!MDPropertyDictionaryTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2005 20:29'!testImplicitGet	properties at: #one put: 1.	self assert: properties one = 1! !!MDPropertyDictionaryTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2005 20:28'!testImplicitPut	properties one: 1.	self assert: (properties at: #one) = 1! !!MDPropertyDictionaryTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2005 20:30'!testPutNil	properties at: #undefined put: nil.	self assert: properties isEmpty! !Object subclass: #MDRegistry	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Project'!(MDRegistry instVarNames includes: 'objects') ifFalse:	[MDRegistry addInstVarName: 'objects']!!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 22:23'!commit! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:42'!includesId: id	^ objects includesKey: id! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!initialize	objects := Dictionary new.	! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 6/14/2008 13:32'!objectWithId: id	^ objects at: id ifAbsent: [nil]! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 22:00'!objectWithId: id satisfies: aBlock	^ aBlock value: (objects at: id ifAbsent: [^ false])! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:29'!objects	^ objects values! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 20:57'!register: anObject	objects at: anObject id put: anObject! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/19/2007 23:36'!unregister: anObject	^ self unregisterId: anObject id! !!MDRegistry methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:29'!unregisterId: id	^ objects removeKey: id ifAbsent: [nil]! !!MDRegistry class methodsFor: 'as yet unclassified' stamp: 'cwp 11/20/2008 18:53'!new	^ self basicNew initialize! !TestCase subclass: #MDRegistryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDRegistryTest instVarNames includes: 'registry') ifFalse:	[MDRegistryTest addInstVarName: 'registry']!(MDRegistryTest instVarNames includes: 'slice') ifFalse:	[MDRegistryTest addInstVarName: 'slice']!!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!setUp	registry := MDRegistry new.	slice := MDExplicitSlice new.! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:58'!testIncludesId	registry register: slice.	self assert: (registry includesId: slice id)! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:58'!testObjectWithIdSatsifies	registry register: slice.	self assert: (registry objectWithId: slice id satisfies: [:o | o == slice]) ! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:58'!testRegistration	registry register: slice.	self assert: (registry objectWithId: slice id) == slice ! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/9/2007 21:58'!testRemoval	registry register: slice.	registry unregisterId: slice id.	self assert: registry objects isEmpty! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/19/2007 23:37'!testRemoveId	registry register: slice.	registry unregisterId: slice id.	self assert: registry objects isEmpty! !!MDRegistryTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/19/2007 23:37'!testUnregister	registry register: slice.	registry unregister: slice.	self assert: registry objects isEmpty! !Object subclass: #MDReplicator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDReplicator instVarNames includes: 'source') ifFalse:	[MDReplicator addInstVarName: 'source']!(MDReplicator instVarNames includes: 'dest') ifFalse:	[MDReplicator addInstVarName: 'dest']!!MDReplicator methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:46'!copyAll	source memos do: [:ea | self copyMemo: ea]! !!MDReplicator methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:40'!copyMemo: aMemo	| objects snapshot |	objects := Set new.	objects add: aMemo.	snapshot := source get: aMemo reference.	objects add: snapshot.	objects addAll: (snapshot getVersionsFrom: source).	dest putAll: objects! !!MDReplicator methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 21:03'!reject: aBlock	source memos do:		[:memo | 		(aBlock value: memo) ifFalse: [self copyMemo: memo]]! !!MDReplicator methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:59'!select: aBlock	source memos do:		[:memo | 		(aBlock value: memo) ifTrue: [self copyMemo: memo]]! !!MDReplicator methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:31'!setSource: sourceRepository destination: destRepository	source := sourceRepository.	dest := destRepository.! !!MDReplicator class methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:31'!from: sourceRepository to: destRepository	^ self new setSource: sourceRepository destination: destRepository! !TestCase subclass: #MDReplicatorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDReplicatorTest instVarNames includes: 'source') ifFalse:	[MDReplicatorTest addInstVarName: 'source']!(MDReplicatorTest instVarNames includes: 'dest') ifFalse:	[MDReplicatorTest addInstVarName: 'dest']!(MDReplicatorTest instVarNames includes: 'replicator') ifFalse:	[MDReplicatorTest addInstVarName: 'replicator']!!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 21:00'!assertDestIncludesMemo: memo 	| snapshot |	self assert: (dest memos includes: memo).	self assert: (dest allHashstamps includes: memo reference).	snapshot := dest get: memo reference.	self assert: (dest allHashstamps includesAllOf: snapshot contents)! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:57'!buildSource: aSymbol 	| versions builder snapshot memo properties |	builder := MDTestBuilder new.	versions := #(#alpha #beta #gamma ) collect: 		[ :letter | 		| v |		v := builder 			versionFor: letter			with: letter.		source put: v.		v ].	snapshot := MDSnapshot withVersions: versions.	source put: snapshot.	properties := MDPropertyDictionary new.	properties tag: aSymbol.	memo := MDMemo 		parents: Set new		properties: properties.	memo 		setSnapshot: snapshot		slice: builder slice.	source put: memo! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:56'!setUp	source := MDMemoryRepository new.	dest := MDMemoryRepository new.	replicator := MDReplicator 		from: source		to: dest.	self buildSource: #one! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:52'!testCopyAll	replicator copyAll.	self assert: (dest selectFrom: source allHashstamps) isEmpty! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 20:54'!testCopyAllReferenced	| version |	version := MDTestBuilder new 		versionFor: #zappa		with: #fribbitz.	source put: version.	replicator copyAll.	self deny: (dest includes: version)! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/10/2008 22:15'!testCopyMemo	| memo |	memo := source memos anyOne.	replicator copyMemo: memo.	self assertDestIncludesMemo: memo! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 21:03'!testReject	| memo |	self buildSource: #two.	replicator reject: [:ea | ea properties tag = #two].	self assert: dest memos size = 1.	memo := dest memos anyOne.	self assert: memo properties tag = #one.	self assertDestIncludesMemo: memo! !!MDReplicatorTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/26/2008 21:02'!testSelect	| memo |	self buildSource: #two.	replicator select: [:ea | ea properties tag = #two].	self assert: dest memos size = 1.	memo := dest memos anyOne.	self assert: memo properties tag = #two.	self assertDestIncludesMemo: memo! !TestCase subclass: #MDRepositoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDRepositoryTest instVarNames includes: 'repository') ifFalse:	[MDRepositoryTest addInstVarName: 'repository']!!MDRepositoryTest methodsFor: 'asserting' stamp: 'cwp 7/27/2008 15:28'!assert: anElementVersion isEquivalentTo: otherElementVersion	self assert: (MDMarshal serialize: anElementVersion) = (MDMarshal serialize: otherElementVersion)! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!memo	| memo |	memo := MDMemo new.	memo setSnapshot: self snapshot slice: self slice.	^ memo! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'avi 3/12/2005 00:45'!newRepository	self subclassResponsibility! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'cwp 12/23/2007 00:09'!secondRepository	^ self newRepository! !!MDRepositoryTest methodsFor: 'running' stamp: 'cwp 5/22/2008 00:10'!setUp	repository := self newRepository! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'cwp 1/19/2007 22:31'!slice	^ MDExplicitSlice named: 'Test Slice'! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'cwp 3/23/2005 22:53'!snapshot	^ MDSnapshot withVersions: (Set with: self version)! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testGetUnknownVersion	| snapshot |	snapshot := self snapshot.	self assert: (repository get: snapshot hashstamp) isNil! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/24/2008 13:06'!testId	self assert: (repository id isKindOf: MDHashstamp)! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMemos	| memo memos |		memo := self memo.	repository put: memo.		memos :=  repository memos.		self assert: memos size = 1.	self assert: (memos anyOne = memo).! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testPush	| other version |	other := self secondRepository.	version := self version.	repository put: version.	repository pushTo: other.	self assert: (other includes: version hashstamp)! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testStoreSnapshot	| snapshot |	snapshot := self snapshot.	repository put: snapshot.	self assert: (repository get: snapshot hashstamp) isEquivalentTo: snapshot! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testStoreVersion	| version |	version := self version.	repository put: version.	self assert: (repository get: version hashstamp) isEquivalentTo: version! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSynchronizeWith	| versionOne versionTwo other |	versionOne := self version.	repository put: versionOne.		other := self secondRepository.	versionTwo := self version.	other put: versionTwo.		repository synchronizeWith: other.		self assert: (repository includes: versionTwo hashstamp).	self assert: (other includes: versionOne hashstamp)! !!MDRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/24/2008 13:06'!testTimestamp	self assert: (repository id timestamp isKindOf: MDTimestamp)! !!MDRepositoryTest methodsFor: 'constructing' stamp: 'dc 6/21/2007 18:31'!version	^ (MDFakeElement named: #Alpha) newElementVersion! !!MDRepositoryTest class methodsFor: 'as yet unclassified' stamp: 'avi 3/12/2005 00:46'!isAbstract	^ self name = #MDRepositoryTest! !TestCase subclass: #MDSerializationBytesTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSerializationBytesTest methodsFor: 'asserting' stamp: 'cwp 11/15/2008 12:59'!assert: anObject serializesTo: anArray 	| expected actual |	actual := MDSerializer serialize: anObject.	expected := anArray asByteArray.	self assert: actual = expected! !!MDSerializationBytesTest methodsFor: 'running' stamp: 'cwp 11/15/2008 13:00'!setUp	super setUp.	MDMaterializer initializeTypes! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 18:50'!testArray	self 		assert: #(1 2 3 )		serializesTo: #(17 9 3 9 1 9 2 9 3)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 18:50'!testBytesObject	self 		assert: #(1 2 3 ) asByteArray		serializesTo: #(1 4 14 9 9 66 121 116 101 65 114 114 97 121 9 0 9 3 1 2 3)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 21:41'!testClass	self 		assert: self class		serializesTo: #(2 14 9 24 77 68 83 101 114 105 97 108 					105 122 97 116 105 111 110 66 121 116 					101 115 84 101 115 116 9 1 15 9 12 116 					101 115 116 83 101 108 101 99 116 111 114)		! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 18:50'!testClassCommentElement	self 		assert: (MDClassCommentElement className: #MDBogusA)		serializesTo: #(1 5 9 10 14 9 8 77 68 66 111 103 117 115 65)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 18:50'!testClassElement	self 		assert: (MDClassElement className: #MDBogusA)		serializesTo: #(1 5 9 9 14 9 8 77 68 66 111 103 117 115 65)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 18:51'!testClassInstVarElement	self 		assert: (MDClassInstVarElement 				className: #MDBogusA				name: 'beth')		serializesTo: #(1 5 9 13 14 9 8 77 68 66 111 103 117 115 65 15 9 4 98 101 116 104)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 18:51'!testClassMethodElement	| element |	element := MDMethodElement 		className: #MDBogusA		selector: #one		classIsMeta: true.	self 		assert: element		serializesTo: #(1 5 9 15 14 9 8 77 68 66 111 103 117 115 65 14 9 3 111 110 101 7)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 18:51'!testClassVarElement	self 		assert: (MDClassVarElement className: #MDBogusA name: 'Alpha')		serializesTo: #(1 5 9 12 14 9 8 77 68 66 111 103 117 115 65 15 9 5 65 108 112 104 97)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 18:52'!testDictionary	| dict |	dict := Dictionary new		at: #a put: 1;		at: #b put: 2;		yourself.	self 		assert: dict		serializesTo: #(19 9 2 14 9 1 97 9 1 14 9 1 98 9 2)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 20:06'!testElementDefinition	| definition |	definition := MDTestBuilder new definition. 	self assert: definition serializesTo: #(1 5 9 2 1 5 9 8 14 9 5 65 108 112 104 97 20 9 0)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:02'!testElementRemoval| removal |	removal := MDTestBuilder new removal.	self assert: removal serializesTo: #(1 5 9 3 1 5 9 8 14 9 5 65 108 112 104 97)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:03'!testFakeElement| element |	element := MDTestBuilder new element.	self assert: element serializesTo: #(1 5 9 8 14 9 5 65 108 112 104 97)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:04'!testFalse	self assert: false serializesTo: #(8)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:21'!testHashstamp	| hashstamp |	hashstamp := MDHashstamp 		hashIn: [:stream | stream nextPutAll: 'abc' asByteArray]		timestamp: (MDTimestamp fromInteger: 905800829).	self 		assert: hashstamp 		serializesTo: #(22 53 253 108 125 157 216 208 156 108 					194 80 120 113 37 62 186 106 129 6 71 54 					62 153 169)	! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 19:06'!testInstVarElement	| element |	element := MDInstVarElement className: #MDBogusA name: 'one'.	self assert: element serializesTo: #(1 5 9 11 14 9 8 77 68 66 111 103 117 115 65 15 9 3 111 110 101)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:07'!testLongString	| string |	string := String new: 300.	string atAllPut: $a.	self 		assert: string 		serializesTo: #(15 10 1 44 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 97 					97 97 97 97 97 97 97 97 97 97 97 97 97 97)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/15/2008 12:59'!testMemo	| memo |	memo := MDTestBuilder new memo.	memo instVarAt: 1 put: (MDTimestamp fromInteger: 905801282).	memo instVarAt: 2 put: (MDHashstamp fromString: 'BTpifCLy1McVFvfIDx7ZkWv5YA5quh3d').	MDSerializer serialize: memo.	self 		assert: memo 		serializesTo: #(23 5 9 7 21 53 253 110 66 22 53 253 110 172 229 254 13 138 33 71 186 					212 63 210 101 194 46 199 144 193 246 234 209 105 18 9 0 20 9 2 14 9 2 					105 100 14 9 3 97 98 99 14 9 9 115 108 105 99 101 78 97 109 101 15 9 9 					84 101 115 116 83 108 105 99 101 22 0 0 0 0 17 212 44 152 219 33 225 252 					116 12 115 99 216 130 70 37 73 13 121 119)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 19:11'!testMethodElement	| element |	element := MDMethodElement className: #MDBogusA selector: #one.	self		assert: element		serializesTo: #(1 5 9 15 14 9 8 77 68 66 111 103 117 115 65 14 9 3 111 110 101 8)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:12'!testMultiString	| ws |	ws := MDPlatform current wideString.	self assert: ws serializesTo: #(16 9 3 0 97 0 98 0 99)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:13'!testNegativeLargeInteger	self		assert: SmallInteger minVal - 1		serializesTo: #(13 9 4 64 0 0 1)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:15'!testNegativeOneByteInteger	self		assert: -3		serializesTo: #(11 0 3)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:16'!testNegativeTwoByteInteger	self 		assert: -300		serializesTo: #(11 1 44)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:16'!testNil	self assert: nil serializesTo: #(6)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:17'!testOneByteInteger	self assert: 7 serializesTo: #(9 7)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:18'!testPointersObject	| object |	object := MDPlatform current variablePointersObject.	self 		assert: object 		serializesTo: #(1 3 14 9 14 65 99 116 105 111 110 83 					101 113 117 101 110 99 101 9 0 9 2 14 9 					1 97 14 9 1 98)! !!MDSerializationBytesTest methodsFor: 'tests - smalltalk' stamp: 'cwp 11/12/2008 19:33'!testPoolImportElement| element |	element := MDPoolImportElement 		className: #MDBogusA		name: #MDBogusPoolA.	self		assert: element		serializesTo: #(1 5 9 14 14 9 8 77 68 66 111 103 117 115 					65 14 9 12 77 68 66 111 103 117 115 80 111 					111 108 65)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:34'!testPositiveLargeInteger	self		assert: SmallInteger maxVal + 1		serializesTo: #(12 9 4 64 0 0 0)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:37'!testPropertyDictionary	| properties |	properties := MDPropertyDictionary new		first: 1;		second: 'two';		yourself.	self		assert: properties		serializesTo: #(20 9 2 14 9 5 102 105 114 115 116 9 1 					14 9 6 115 101 99 111 110 100 15 9 3 116 					119 111)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:38'!testSet	self		assert: #(1 2 3) asSet		serializesTo: #(18 9 3 9 1 9 2 9 3)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:39'!testSliceElement| element |	element := MDSliceElement 		forSlice: (MDExplicitSlice named: 'TestSlice')		inProject: MDProject forTesting.	self		assert: element		serializesTo: #(1 5 9 1 22 0 0 0 0 142 78 79 194 108 182 					232 191 8 115 58 206 66 46 6 97 151 111 99 					108 22 0 0 0 0 17 212 44 152 219 33 225 252 					116 12 115 99 216 130 70 37 73 13 121 119)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:47'!testSnapshot| contents snapshot |	contents := #('BTploHISPGtEjxw7iNSRzI4sPrBSpkcx' 'BTploIM6Z+ffONzz9IfyCOaH7I8zZPk-') 		collect: [:ea | MDHashstamp fromString: ea].	snapshot := MDSnapshot new.	snapshot instVarAt: 1 put: (MDTimestamp fromInteger: 905802042).	snapshot instVarAt: 2 put: contents.	self 		assert: snapshot		serializesTo: #(23 5 9 6 21 53 253 113 58 17 9 2 22 53 253 113 209 53 30 109 46 80 					191 223 9 185 151 157 253 65 184 111 115 94 215 10 61 22 53 253 113 					209 70 8 148 10 235 105 159 255 45 74 254 57 169 147 37 66 191 149 188 1)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:53'!testString	self		assert: 'abc'		serializesTo: #(15 9 3 97 98 99)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/17/2008 01:07'!testStringWithAccent	self		assert: 'bc'		serializesTo: #(15 9 3 195 161 98 99)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:54'!testSymbol	self assert: #one serializesTo: #(14 9 3 111 110 101)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:55'!testThreeByteInteger	| number |	number := (2 raisedTo: 16) + 1.	self		assert: number		serializesTo: #(12 9 3 1 0 1)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:58'!testTimestamp	| ts |	ts := MDTimestamp fromInteger: 905803057.	self assert: ts serializesTo: #(21 53 253 117 49)	! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 19:59'!testTrue	self assert: true serializesTo: #(7)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 20:00'!testTwoByteInteger	self assert: 355 serializesTo: #(10 1 99)! !!MDSerializationBytesTest methodsFor: 'tests - core' stamp: 'cwp 11/12/2008 20:04'!testVersion	| version |	version := MDTestBuilder new version.	version instVarAt: 1 put: (MDTimestamp fromInteger: 905803456).	self 		assert: version		serializesTo: #(23 5 9 5 21 53 253 118 192 1 5 9 2 1 5 9 8 14 9 					5 65 108 112 104 97 20 9 0 18 9 0)! !TestCase subclass: #MDSerializationClassTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSerializationClassTest commentStamp: 'cwp 4/19/2008 14:31' prior: 0!This suite of tests ensures that well-known classes are serialized using these class ids:	    -- core --	 1  MDSliceElement	 2  MDDefinitionVariant	 3  MDRemovalVariant	 4  MDNullVersion	 5  MDElementVersion	 6  MDSnapshot	 7  MDMemo	     -- testing --	 8  MDFakeElement	    -- smalltalk --	 9  MDClassElement	10  MDClassCommentElement	11  MDInstVarElement	12  MDClassVarElement	13  MDClassInstVarElement	14  MDMethodElement!!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:22'!assert: anObject hasClassId: anInteger	| bytes |	bytes := MDMarshal serialize: anObject.	self assert: (#(1 23) includes: bytes first).	"type object"	self assert: bytes second = 5.					"well-known class"	self assert: bytes third = 9.					"byte integer"	self assert: bytes fourth = anInteger! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 11:16'!test01SliceElement	self 		assert: MDSliceElement new		hasClassId: 1! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:16'!test02DefinitionVariant	self 		assert: MDDefinitionVariant new		hasClassId: 2! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:17'!test03RemovalVariant	self 		assert: MDRemovalVariant new		hasClassId: 3! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:17'!test04NullVersion	self 		assert: MDNullVersion new		hasClassId: 4! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:23'!test05ElementVersion	self 		assert: MDElementVersion new		hasClassId: 5! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:23'!test06Snapshot	self 		assert: MDSnapshot new		hasClassId: 6! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:24'!test07Memo	self 		assert: MDMemo new		hasClassId: 7! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:25'!test08FakeElement	self 		assert: MDFakeElement new		hasClassId: 8! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:26'!test09ClassElement	self 		assert: MDClassElement new		hasClassId: 9! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:28'!test10ClassCommentElement	self 		assert: MDClassCommentElement new		hasClassId: 10! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:28'!test11InstVarElement	self 		assert: MDInstVarElement new		hasClassId: 11! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:28'!test12ClassVarElement	self 		assert: MDClassVarElement new		hasClassId: 12! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:29'!test13ClassInstVarElement	self 		assert: MDClassInstVarElement new		hasClassId: 13! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/30/2008 07:00'!test14PoolImportElement	self 		assert: MDPoolImportElement new		hasClassId: 14! !!MDSerializationClassTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/30/2008 06:59'!test15MethodElement	self 		assert: MDMethodElement new		hasClassId: 15! !Object subclass: #MDSerializationMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakPlatform'!(MDSerializationMap instVarNames includes: 'classMap') ifFalse:	[MDSerializationMap addInstVarName: 'classMap']!(MDSerializationMap instVarNames includes: 'typeMap') ifFalse:	[MDSerializationMap addInstVarName: 'typeMap']!(MDSerializationMap instVarNames includes: 'defaultSerializer') ifFalse:	[MDSerializationMap addInstVarName: 'defaultSerializer']!!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 10:24'!addHashedSerializersTo: map 	| serializer |	serializer := MDHashedObjectSerializer type: 23.	MDHashedObject allSubclassesDo: 		[ :class | map at: class put: serializer ]! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 6/23/2008 08:31'!addKnownClassesTo: map 	self knownClasses withIndexDo:		[:class :id |		class ifNotNil:			[map 				at: class class				put: (MDKnownClassSerializer id: id)]]! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 13:45'!createClassMap	| map |	map := IdentityDictionary new.	map 		at: UndefinedObject put: (MDSingletonSerializer type: 6);		at: True put: (MDSingletonSerializer type: 7);		at: False put: (MDSingletonSerializer type: 8);		at: SmallInteger put: MDSmallIntegerSerializer new;		at: LargePositiveInteger put: (MDLargeIntegerSerializer type: 12);		at: LargeNegativeInteger put: (MDLargeIntegerSerializer type: 13);		at: ByteSymbol put: (MDUtf8Serializer type: 14);		at: WideSymbol put: (MDUtf8Serializer type: 14);		at: String put: (MDUtf8Serializer type: 15);		at: String put: (MDUtf16Serializer type: 16);		at: Array put: (MDArraySerializer type: 17);		at: Set put: (MDSetSerializer type: 18);		at: Dictionary put: (MDDictionarySerializer type: 19);		at: MDPropertyDictionary put: (MDDictionarySerializer type: 20);		at: MDTimestamp put: (MDBytesSerializer type: 21);		at: MDHashstamp put: (MDBytesSerializer type: 22).	self addHashedSerializersTo: map.	self addKnownClassesTo: map.	^ map! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 13:39'!createTypeMap	^ { 		(MDObjectMaterializer new).		(MDClassMaterializer new).		(MDClassMaterializer new).		(MDClassMaterializer new).		MDKnownClassMaterializer class: self knownClasses.		(MDSingletonMaterializer object: nil).		(MDSingletonMaterializer object: true).		(MDSingletonMaterializer object: false).		(MDSmallIntegerMaterializer new).		(MDSmallIntegerMaterializer new).		(MDSmallIntegerMaterializer new).		(MDLargeIntegerMaterializer class: LargePositiveInteger).		(MDLargeIntegerMaterializer class: LargeNegativeInteger).		(MDUtf8Materializer forSymbol).		(MDUtf8Materializer forString).		(MDUtf16Materializer new).		(MDArrayMaterializer class: Array).		(MDSetMaterializer class: Set).		(MDDictionaryMaterializer class: Dictionary).		(MDDictionaryMaterializer class: MDPropertyDictionary).		(MDBytesMaterializer class: MDTimestamp).		(MDBytesMaterializer class: MDHashstamp).		(MDHashedObjectMaterializer new)	 }! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/12/2008 02:18'!initialize	classMap := self createClassMap.	typeMap := self createTypeMap.	defaultSerializer := MDObjectSerializer type: 1.! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/30/2008 07:01'!knownClasses	^ { 		MDSliceElement.		MDDefinitionVariant.		MDRemovalVariant.		MDNullVersion.		MDElementVersion.		MDSnapshot.		MDMemo.		MDFakeElement.		MDClassElement.		MDClassCommentElement.		MDInstVarElement.		MDClassVarElement.		MDClassInstVarElement.		MDPoolImportElement.		MDMethodElement	 }! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:03'!materializerForType: anInteger 	^ typeMap at: anInteger! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 12:00'!serializerForObject: anObject	^ classMap		at: anObject class		ifAbsent: 			[anObject isBehavior				ifTrue: [MDClassSerializer new]				ifFalse: [defaultSerializer]]! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/7/2008 23:49'!stringClass	^ (Smalltalk hasClassNamed: #String)		ifTrue: [Smalltalk at: #String]		ifFalse: [Smalltalk at: #String]! !!MDSerializationMap methodsFor: 'as yet unclassified' stamp: 'cwp 4/7/2008 23:48'!symbolClass	^ (Smalltalk hasClassNamed: #ByteSymbol)		ifTrue: [Smalltalk at: #ByteSymbol]		ifFalse: [Smalltalk at: #Symbol]! !TestCase subclass: #MDSerializationTypeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSerializationTypeTest commentStamp: 'cwp 4/19/2008 12:04' prior: 0!Here's the type specifications that this class enforces:     1  object     2  class (fixed)     3  class (pointers)     4  class (bytes)     5  class (well-known)     6  nil     7  true     8  false     9  8 bit unsigned integer    10  small positive integer    11  small negative integer    12  large positive integer    13  large negative integer    14  symbol (utf-8)    15  string (utf-8)    16  string (utf-16be)    17  array    18  set    19  dictionary    20  properties    21  timestamp    22  hashstamp    23  hashed object!!MDSerializationTypeTest methodsFor: 'asserting' stamp: 'cwp 3/1/2008 22:57'!assertObject: anObject hasType: anInteger	| bytes |	bytes := MDMarshal serialize: anObject.	self assert: bytes first = anInteger! !!MDSerializationTypeTest methodsFor: 'running' stamp: 'cwp 4/8/2008 20:11'!setUp	super setUp.	MDMarshal resetMap! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 3/2/2008 13:28'!test01Object	self assertObject: self hasType: 1! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 3/2/2008 13:28'!test02FixedClass	self assertObject: self class hasType: 2! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 3/2/2008 13:29'!test03PointersClass	self 		assertObject: MDPlatform current variablePointersObject class		hasType: 3! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 3/2/2008 13:30'!test04BytesClass	self 		assertObject: ByteArray		hasType: 4! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 12:01'!test05WellKnownClass	self 		assertObject: MDElementVersion		hasType: 5! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:14'!test06Nil	self assertObject: nil hasType: 6! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:14'!test07True	self assertObject: true hasType: 7! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:14'!test08False	self assertObject: false hasType: 8! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:14'!test09ByteInteger	self assertObject: 3 hasType: 9! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:14'!test10SmallPostiveInteger	self assertObject: 355 hasType: 10! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:13'!test11SmallNegativeInteger	self assertObject: -300 hasType: 11! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:13'!test12LargePositiveInteger	self assertObject: SmallInteger maxVal + 1 hasType: 12! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:21'!test13LargeNegativeInteger	self assertObject: SmallInteger minVal - 1 hasType: 13! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:13'!test14Symbol	self assertObject: #testSymbol hasType: 14! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:13'!test15Utf8String	self assertObject: 'abc' hasType: 15! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 6/23/2008 08:42'!test16Utf16String	self 		assertObject: (MDPlatform current wideString) 		hasType: 16! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:12'!test17Array	self		assertObject: Array new		hasType: 17! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:12'!test18Set	self		assertObject: Set new		hasType: 18! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:12'!test19Dictionary	self		assertObject: Dictionary new		hasType: 19! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:11'!test20Properties	self		assertObject: MDPropertyDictionary new		hasType: 20! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:11'!test21Timestamp	self		assertObject: MDTimestamp now		hasType: 21! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:11'!test22Hashstamp	self		assertObject: (MDHashstamp fromString: 'AbjG2m8xWqxTBPAOm0Sq4bCsci7JbfKX')		hasType: 22! !!MDSerializationTypeTest methodsFor: 'tests' stamp: 'cwp 4/19/2008 10:11'!test23HashedObject	self		assertObject: (MDSnapshot withVersions: Set new)		hasType: 23! !Object subclass: #MDSerializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Serialization'!(MDSerializer instVarNames includes: 'encoder') ifFalse:	[MDSerializer addInstVarName: 'encoder']!!MDSerializer methodsFor: 'private' stamp: 'cwp 9/4/2008 08:03'!indexOf: anObject in: anIndex ifPresent: pBlock ifAbsent: aBlock	| id |	(anIndex includesKey: anObject)		ifTrue: 			[id := anIndex at: anObject.			pBlock value: id]		ifFalse:			[id := anIndex size + 1.			anIndex at: anObject put: id.			aBlock value: id].			! !!MDSerializer methodsFor: 'private' stamp: 'cwp 11/15/2008 11:54'!knownClasses	^ { 		MDSliceElement.		MDDefinitionVariant.		MDRemovalVariant.		MDNullVersion.		MDElementVersion.		MDSnapshot.		MDMemo.		MDFakeElement.		MDClassElement.		MDClassCommentElement.		MDInstVarElement.		MDClassVarElement.		MDClassInstVarElement.		MDPoolImportElement.		MDMethodElement	 }! !!MDSerializer methodsFor: 'public' stamp: 'cwp 11/20/2008 19:18'!serialize: anObject 	anObject mdSerializeWith: self! !!MDSerializer methodsFor: 'private' stamp: 'cwp 11/11/2008 23:05'!serialize: anObject with: aBlock 	aBlock value! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:24'!serializeArray: anArray	self serialize: anArray with:		[encoder putType: 17.		self serialize: anArray size.		anArray do: [:ea | self serialize: ea]]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 9/23/2008 07:50'!serializeBlockContext: aContext	self serialize: aContext with:		[encoder putType: 21.		self serialize: aContext method.		self serialize: aContext sender.		self serialize: aContext pc.		self serialize: aContext numArgs.		self serialize: aContext startpc.		self serialize: aContext home]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:30'!serializeByte: anInteger 	encoder putType: 9.	encoder putByte: anInteger.	! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/15/2008 11:54'!serializeClass: aClass	| index |	index := self knownClasses indexOf: aClass.	index = 0		ifTrue: [self serializeFullClass: aClass]		ifFalse:			[encoder putType: 5.			self serialize: index]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 22:59'!serializeDictionary: aDictionary	encoder putType: 19.	self serialize: aDictionary size.	aDictionary keys asArray sort do:		[:key |		self serialize: key.		self serialize: (aDictionary at: key)]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 8/31/2008 19:51'!serializeFloat: aFloat	encoder putType: 16.	encoder putFloat: aFloat! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/15/2008 11:51'!serializeFullClass: aClass	| type vars |		type :=  aClass isVariable 		ifFalse: [2]				"named inst vars only"		ifTrue: 			[aClass isPointers 				ifTrue: [3]		"named + indexed object references"				ifFalse: [4]].	"bytes or words"			encoder putType: type.	vars := aClass allInstVarNames.	self serialize: aClass name.	self serialize: vars size.	vars do: [:ea | self serialize: ea]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/15/2008 12:03'!serializeHashedObject: anObject	encoder putType: 23.	self serialize: anObject class.	self serialize: anObject timestamp.	2		to: anObject class instSize		do: [:i | self serialize: (anObject instVarAt: i)]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 22:17'!serializeHashstamp: aHashstamp	encoder putType: 22.	encoder putBytesFrom: aHashstamp! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 21:54'!serializeInteger: anInteger 	anInteger < -65535 ifTrue: 		[ ^ self 			writeLargeInteger: anInteger negated			type: 13 ].	anInteger < 0 ifTrue: [ ^ self serializeSmallNegativeInteger: anInteger ].	anInteger < 256 ifTrue: [ ^ self serializeByte: anInteger ].	anInteger < 65535 ifTrue: [ ^ self serializeSmallPositiveInteger: anInteger ].	self 		writeLargeInteger: anInteger		type: 12! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 22:02'!serializeMethodContext: aContext 	self 		serialize: aContext		with: 			[ encoder putType: 22.			self serialize: aContext method.			self serialize: aContext sender.			self serialize: aContext pc.			self serialize: aContext stackPtr.			self serialize: aContext myEnv.			self serialize: aContext receiver.			self writePointersFrom: aContext ]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 22:03'!serializeObject: anObject 	encoder putType: 1.	self serialize: anObject class.	1	to: anObject class instSize		do: [:i | self serialize: (anObject instVarAt: i)].	anObject class isVariable ifTrue: 		[self serialize: anObject size.		anObject class isPointers 			ifTrue: [self writePointersFrom: anObject]			ifFalse: [encoder putBytesFrom: anObject]]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 23:00'!serializeProperties: aPropertyDictionary	encoder putType: 20.	self serialize: aPropertyDictionary size.	aPropertyDictionary keys asArray sort do:		[:key |		self serialize: key.		self serialize: (aPropertyDictionary at: key)]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 9/3/2008 19:15'!serializeReference: anInteger	encoder putType: 2.	self serialize: anInteger! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 21:43'!serializeSet: aSet	encoder putType: 18.	self serialize: aSet size.	aSet do: [:ea | self serialize: ea]! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:39'!serializeSingleton: anObject	encoder putSingleton: anObject! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:29'!serializeSmallNegativeInteger: anInteger 	encoder putType: 11.	encoder putSmallInteger: anInteger abs.	! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:31'!serializeSmallPositiveInteger: anInteger 	encoder putType: 10.	encoder putSmallInteger: anInteger.	! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 21:11'!serializeSymbol: aSymbol	encoder putType: 14.	self serialize: aSymbol size.	encoder putUtf8String: aSymbol! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 22:11'!serializeTimestamp: aTimestamp	encoder putType: 21.	encoder putBytesFrom: aTimestamp! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:51'!serializeUtf16String: aString	encoder putType: 16.	self serialize: aString size.	encoder putUtf16String: aString! !!MDSerializer methodsFor: 'types' stamp: 'cwp 11/12/2008 20:51'!serializeUtf8String: aString	encoder putType: 15.	self serialize: aString size.	encoder putUtf8String: aString! !!MDSerializer methodsFor: 'initialize-release' stamp: 'cwp 11/11/2008 23:10'!setStream: aWriteStream 	encoder := MDObjectEncoder on: aWriteStream.	! !!MDSerializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:50'!setType: anInteger	type := anInteger! !!MDSerializer methodsFor: 'as yet unclassified' stamp: 'cwp 4/12/2008 02:19'!write: anObject with: aMarshal	aMarshal write: type.	self writeState: anObject with: aMarshal! !!MDSerializer methodsFor: 'private' stamp: 'cwp 9/2/2008 07:23'!writeLargeInteger: anInteger type: type 	| size |	encoder putType: type.	size := (anInteger log: 256) floor + 1.	self serialize: size.	encoder putLargeInteger: anInteger size: size.	^ self! !!MDSerializer methodsFor: 'private' stamp: 'cwp 11/12/2008 22:02'!writePointersFrom: anObject 	1	to: anObject size		do: [ :i | self serialize: (anObject at: i) ]! !!MDSerializer methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2008 23:45'!writeState: anObject with: aMarshal! !!MDSerializer class methodsFor: 'instance creation' stamp: 'cwp 8/31/2008 15:47'!on: aWriteStream	^ self new setStream: aWriteStream! !!MDSerializer class methodsFor: 'serializing' stamp: 'cwp 11/11/2008 23:19'!serialize: anObject	| stream |	stream := (ByteArray new: 100) writeStream.	self serialize: anObject on: stream.	^ stream contents! !!MDSerializer class methodsFor: 'serializing' stamp: 'cwp 11/11/2008 23:19'!serialize: anObject on: aStream	(self on: aStream) serialize: anObject.	! !!MDSerializer class methodsFor: 'as yet unclassified' stamp: 'cwp 4/8/2008 20:49'!type: anInteger	^ self new setType: anInteger! !TestCase subclass: #MDSerializerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/15/2008 23:49'!assert: actual equals: expected	| limit |	limit := actual size min: expected size.	1 to: limit do: [:index | self assert: (actual at: index) = (expected at: index)].	self assert: actual size = expected size! !!MDSerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:19'!assert: anObject yields: expected 	| stream actual |	stream := ByteArray new writeStream.	self serialize: anObject on: stream.	actual := stream contents.	self 		assert: actual		equals: expected! !!MDSerializerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 4/16/2008 22:06'!isAbstract	^ self name = #MDSerializerTest! !Object subclass: #MDServerLink	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDServerLink instVarNames includes: 'stream') ifFalse:	[MDServerLink addInstVarName: 'stream']!(MDServerLink instVarNames includes: 'service') ifFalse:	[MDServerLink addInstVarName: 'service']!(MDServerLink instVarNames includes: 'process') ifFalse:	[MDServerLink addInstVarName: 'process']!!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!handleMessage	|  request response |	[request := MDNetMessage readFrom: stream]		on: ConnectionClosed, ConnectionTimedOut 		do: [:exception | ^ nil].	response := service handleMessage: request.	response writeOn: stream.	stream flush.	response isGoodbye ifTrue: [stream close]! !!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/19/2008 01:32'!name	^ String streamContents:		[:out |		out 			nextPutAll: stream socket remoteAddress asString;			nextPutAll: '->';			nextPutAll: service description]! !!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/19/2008 01:16'!run	[stream isConnected] whileTrue: [self handleMessage]! !!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setSocket: aSocket repository: aRepository	stream := self streamClass on: aSocket.	service := MDNetService for: aRepository.	stream binary! !!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!start	process := [self run] 				forkAt: Processor highIOPriority 				named: self name! !!MDServerLink methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 23:18'!streamClass	^ Smalltalk at: #FastSocketStream ifAbsent: [Smalltalk at: #SocketStream]! !!MDServerLink class methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!serve: aSocket repository: aRepository	| link |	link := self socket: aSocket repository: aRepository.	link start! !!MDServerLink class methodsFor: 'as yet unclassified' stamp: 'cwp 1/18/2008 23:16'!socket: aSocket repository: aRepository	^ self new setSocket: aSocket repository: aRepository! !TestCase subclass: #MDSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSliceTest commentStamp: 'cwp 8/29/2005 00:40' prior: 0!This comment needs to be here, or #testComment won't pass.!(MDSliceTest instVarNames includes: 'slice') ifFalse:	[MDSliceTest addInstVarName: 'slice']!(MDSliceTest instVarNames includes: 'elements') ifFalse:	[MDSliceTest addInstVarName: 'elements']!!MDSliceTest methodsFor: 'asserting' stamp: 'dc 6/26/2007 21:48'!assertAllOf: expectedLabels butNoneOf: forbiddenLabels as: aBlock 	self assertAllOf: expectedLabels butNoneOf: forbiddenLabels enumeratedAs: aBlock.	self assertAllOf: expectedLabels butNoneOf: forbiddenLabels includedAs: aBlock.! !!MDSliceTest methodsFor: 'asserting' stamp: 'cwp 5/22/2008 00:10'!assertAllOf: expectedLabels butNoneOf: forbiddenLabels enumeratedAs: aBlock 	| expected forbidden |	expected := expectedLabels collect: aBlock.	forbidden := forbiddenLabels collect: aBlock.	elements := slice elements.	self assert: (elements includesAllOf: expected).	self deny: (elements includesAnyOf: forbidden)! !!MDSliceTest methodsFor: 'asserting' stamp: 'cwp 3/3/2006 11:28'!assertAllOf: expectedLabels butNoneOf: forbiddenLabels includedAs: aBlock 	| expected forbidden |	expected := expectedLabels collect: aBlock.	expected do: [:ea | self assert: (slice includes: ea)].	forbidden := forbiddenLabels collect: aBlock.	forbidden do: [:ea | self deny: (slice includes: ea)]! !!MDSliceTest methodsFor: 'running' stamp: 'cwp 3/16/2005 01:02'!setUp	slice := self createSlice.! !!MDSliceTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 22:59'!testId	self assert: (slice id isKindOf: MDHashstamp)! !!MDSliceTest methodsFor: 'tests' stamp: 'cwp 6/17/2008 00:18'!testType	| class |	class := MDSlice classForType: slice type.	self assert: slice class == class! !!MDSliceTest class methodsFor: 'testing' stamp: 'cwp 3/16/2005 01:05'!isAbstract	^ self name = #MDSliceTest! !!MDSliceTest class methodsFor: 'testing' stamp: 'cwp 3/16/2005 01:05'!shouldInheritSelectors	^ true! !Object subclass: #MDSqueakElementAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!(MDSqueakElementAdaptor instVarNames includes: 'element') ifFalse:	[MDSqueakElementAdaptor addInstVarName: 'element']!(MDSqueakElementAdaptor instVarNames includes: 'system') ifFalse:	[MDSqueakElementAdaptor addInstVarName: 'system']!!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 3/2/2006 18:08'!display: properties	^ properties asString! !!MDSqueakElementAdaptor methodsFor: 'accessing' stamp: 'cwp 2/6/2005 12:44'!elementClass	^ self elementClassIfAbsent: [nil]! !!MDSqueakElementAdaptor methodsFor: 'accessing' stamp: 'cwp 12/11/2005 11:01'!elementClassIfAbsent: aBlock	^ system at: element theClassName ifAbsent: aBlock! !!MDSqueakElementAdaptor methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:13'!initials	| initials |	initials := self stamp copyUpTo: $ .	^ initials isEmpty ifFalse: [initials] ifTrue: [nil]! !!MDSqueakElementAdaptor methodsFor: 'private' stamp: 'cwp 2/5/2005 21:40'!is: name upToDateIn: properties	^ (properties at: name ifAbsent: [^ true]) = (self perform: name)	! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 2/15/2005 15:47'!isLoadable: properties	self elementClassIfAbsent: [^ false].	^ true! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 2/5/2005 21:40'!isUpToDate: properties 	self propertyNames		do: [:property | (self is: property upToDateIn: properties) ifFalse: [^ false]].	^ true! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 2/12/2005 14:08'!load: properties	self subclassResponsibility! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'avi 3/16/2005 12:21'!merge: aPropertyDictionary into: otherPropertyDictionary onFailure: aBlock	^ aBlock value! !!MDSqueakElementAdaptor methodsFor: 'properties' stamp: 'cwp 2/6/2005 23:39'!propertyNames	^ #()! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 2/12/2005 14:08'!remove	self subclassResponsibility! !!MDSqueakElementAdaptor methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:13'!setElement: anElement system: aSystemEditor	element := anElement.	system := aSystemEditor! !!MDSqueakElementAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:13'!stampFromProperties: properties	| initials timestamp |	initials := properties at: #initials ifAbsent: ['<nobody>'].	timestamp := properties at: #timeStamp ifAbsent: [^ '<no timestamp>'].	^ timestamp printFormat: initials, ' %l/%e/%Y %H:%M'	! !!MDSqueakElementAdaptor methodsFor: 'accessing' stamp: 'cwp 8/4/2008 22:36'!timeStamp	| stamp |	stamp := self stamp.	^ (#('' '<historical>' '<no timestamp>') includes: stamp withBlanksTrimmed)		ifFalse: [MDTimestamp fromSqueakMethodStamp: stamp]		ifTrue: [nil]! !!MDSqueakElementAdaptor methodsFor: 'public' stamp: 'cwp 2/1/2006 21:02'!update: properties	self propertyNames do: 		[:name | (self perform: name) ifNotNilDo: 			[:value | properties at: name put: value]]! !!MDSqueakElementAdaptor class methodsFor: 'instance creation' stamp: 'cwp 12/11/2005 10:57'!forElement: anElement	^ self forElement: anElement inSystem: Smalltalk! !!MDSqueakElementAdaptor class methodsFor: 'instance creation' stamp: 'cwp 12/1/2005 21:58'!forElement: anElement inSystem: aSystemEditor	^ self new setElement: anElement system: aSystemEditor! !TestCase subclass: #MDSqueakInstVarMungingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!(MDSqueakInstVarMungingTest instVarNames includes: 'adaptor') ifFalse:	[MDSqueakInstVarMungingTest addInstVarName: 'adaptor']!!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 07:22'!assertIndex: index in: before yields: expected	| actual |	actual := adaptor installAt: index in: before.	self assert: actual = expected! !!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 07:17'!setUp	| element |	element := MDInstVarElement className: #MDBogusA name: 'two'.	adaptor := MDSqueakInstVarAdaptor forElement: element inSystem: self.	! !!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 08:00'!testAddAndInsertPadding	self 		assertIndex: 3		in: #('one')		yields: #('one' 'instVarAtSlot2' 'two')! !!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 07:54'!testInsertPadding	self 		assertIndex: 3		in: #('one' 'two')		yields: #('one' 'instVarAtSlot2' 'two')! !!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 07:24'!testSwap	self 		assertIndex: 2		in: #('one' 'interloper' 'two')		yields: #('one' 'two' 'interloper')! !!MDSqueakInstVarMungingTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 07:56'!testSwapToEnd	self 		assertIndex: 2		in: #('one' 'interloper' 'three')		yields: #('one' 'two' 'three' 'interloper')! !TestCase subclass: #MDSqueakTimestampParsingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/23/2008 07:27'!testNormal	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'cwp 8/7/2005 18:32'.	self assert: ts year = 2005.	self assert: ts month = 8.	self assert: ts day = 7.	self assert: ts hour = 18.	self assert: ts minute = 32.	self assert: ts second = 0.! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:55'!testYear100	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'MPW 12/31/100 21:50'.	self assert: ts isNil! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:46'!testYear1901	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'MPW 1/1/1901 21:50'.	self assert: ts isNil! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:54'!testYear1979	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'MPW 12/31/1979 21:50'.	self assert: ts isNil! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 19:59'!testYear1997	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'di 9/18/1997 10:10'.	self assert: ts year = 1997.	self assert: ts month = 9.	self assert: ts day = 18.	self assert: ts hour = 10.	self assert: ts minute = 10.	self assert: ts second = 0.! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:01'!testYear2080	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'di 9/18/2080 10:10'.	self assert: ts year = 2080.	self assert: ts month = 9.	self assert: ts day = 18.	self assert: ts hour = 10.	self assert: ts minute = 10.	self assert: ts second = 0.	! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:00'!testYear79	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'di 9/18/79 10:10'.	self assert: ts year = 2079.	self assert: ts month = 9.	self assert: ts day = 18.	self assert: ts hour = 10.	self assert: ts minute = 10.	self assert: ts second = 0.	! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:01'!testYear80	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'di 9/18/80 10:10'.	self assert: ts year = 1980.	self assert: ts month = 9.	self assert: ts day = 18.	self assert: ts hour = 10.	self assert: ts minute = 10.	self assert: ts second = 0.	! !!MDSqueakTimestampParsingTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 19:58'!testYear97	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'di 9/18/97 10:10'.	self assert: ts year = 1997.	self assert: ts month = 9.	self assert: ts day = 18.	self assert: ts hour = 10.	self assert: ts minute = 10.	self assert: ts second = 0.! !TestCase subclass: #MDSqueakTransactionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!(MDSqueakTransactionTest instVarNames includes: 'proxy') ifFalse:	[MDSqueakTransactionTest addInstVarName: 'proxy']!(MDSqueakTransactionTest instVarNames includes: 'commitWasCalled') ifFalse:	[MDSqueakTransactionTest addInstVarName: 'commitWasCalled']!!MDSqueakTransactionTest methodsFor: 'asserting' stamp: 'cwp 5/22/2008 00:13'!assertEditorSetFor: aBlock	| adaptor |	proxy instVarNamed: 'editor' put: self.	adaptor := (aBlock value) adaptedFor: proxy.	self assert: (adaptor instVarNamed: 'system') == self! !!MDSqueakTransactionTest methodsFor: 'callbacks' stamp: 'cwp 5/22/2008 00:13'!commit	commitWasCalled := true! !!MDSqueakTransactionTest methodsFor: 'running' stamp: 'cwp 3/3/2006 15:31'!endTransactionEarly	proxy transaction: [^ self].! !!MDSqueakTransactionTest methodsFor: 'running' stamp: 'cwp 7/23/2008 07:02'!setUp	proxy := MDSqueakDomain new.	commitWasCalled := false! !!MDSqueakTransactionTest methodsFor: 'callbacks' stamp: 'cwp 3/2/2006 21:06'!subject	^ Smalltalk! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:45'!testEditorSetForClassAdaptors	self assertEditorSetFor: [MDClassElement className: self class name].! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:45'!testEditorSetForClassCommentAdaptors	self assertEditorSetFor: [MDClassCommentElement className: self class name]! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:48'!testEditorSetForClassInstVarAdaptors	self assertEditorSetFor: [MDClassInstVarElement 							className: self class name 							name: 'aleph']! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:49'!testEditorSetForClassVarAdaptors	self assertEditorSetFor: [MDClassVarElement 							className: self class name 							name: 'Alpha']! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:50'!testEditorSetForInstVarAdaptors	self assertEditorSetFor: [MDInstVarElement 							className: self class name 							name: 'one']! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:52'!testEditorSetForMethodAdaptors	self assertEditorSetFor: [MDMethodElement 							className: self class name 							selector: #a]! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 4/28/2008 22:04'!testEditorSetForPoolImportAdaptors	self assertEditorSetFor: 		[ MDPoolImportElement 			className: self class name			name: #MDBogusPoolA ]! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 12/24/2006 23:12'!testProxyClearsEditorIfTransactionExitsEarly		self endTransactionEarly.	self assert: (proxy instVarNamed: 'editor') == Smalltalk! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:13'!testProxyCreatesSystemEditor	| editor |	proxy transaction:		[editor := proxy instVarNamed: 'editor'.		self assert: (editor class == MDPlatform current systemEditor class)].! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 21:04'!testProxyHasDefaultEnvironment		self assert: (proxy instVarNamed: 'editor') == Smalltalk! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 12/24/2006 23:12'!testProxyRemovesSystemEditor	proxy transaction: ["do nothing"].	self assert: (proxy instVarNamed: 'editor') == Smalltalk! !!MDSqueakTransactionTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 20:42'!testProxySendsCommitToEditor		proxy transaction: [proxy instVarNamed: 'editor' put: self].	self assert: commitWasCalled! !TestCase subclass: #MDStElementDisplayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:53'!testClass	| element string |	element := MDClassElement className: #MDBogusA.	string := element printString.	self assert: string = 'MDBogusA'! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:54'!testClassComment	| element string |	element := MDClassCommentElement className: #MDBogusA.	string := element printString.	self assert: string = 'MDBogusA comment'! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:47'!testClassInstVar	| element string |	element := MDClassInstVarElement 		className: #MDBogusA		name: 'one'.	string := element printString.	self assert: string = 'MDBogusA: class instance variable ''one'''! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 22:00'!testClassMethod	| element string |	element := MDMethodElement className: #MDBogusA selector: #one classIsMeta: true.	string := element printString.	self assert: string = 'MDBogusA class>>one'! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:44'!testClassVar	| element string |	element := MDClassVarElement 		className: #MDBogusA		name: 'MDAlpha'.	string := element printString.	self assert: string = 'MDBogusA: class variable ''MDAlpha'''! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:46'!testInstVar	| element string |	element := MDInstVarElement 		className: #MDBogusA		name: 'one'.	string := element printString.	self assert: string = 'MDBogusA: instance variable ''one'''! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:56'!testMethod	| element string |	element := MDMethodElement className: #MDBogusA selector: #one.	string := element printString.	self assert: string = 'MDBogusA>>one'! !!MDStElementDisplayTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/22/2008 21:49'!testPoolImport	| element string |	element := MDPoolImportElement		className: #MDBogusA		name: 'one'.	string := element printString.	self assert: string = 'MDBogusA: pool import ''one'''! !Object subclass: #MDTestBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:43'!definition	^ MDDefinitionVariant forElement: self element! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!definition: aSymbol	| definition |	definition := MDDefinitionVariant forElement: (self element: aSymbol).	definition properties at: #one put: 1.	^ definition! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!element	^ self element: #Alpha! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!element: aSymbol	^ MDFakeElement named: aSymbol! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!elements	^ Set		with: (MDFakeElement named: #Alpha)		with: (MDFakeElement named: #Beta)! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 1/19/2007 22:26'!memo	^ self memo: #abc! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 1/19/2007 22:28'!memo: aSymbol	^ MDMemo		snapshot: self snapshot		slice: self slice		parents: Set new		properties: (MDPropertyDictionary new id: aSymbol; yourself)! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 5/27/2008 06:58'!merge	^ self mergeIn: (MDWorkingCopy forDomain: MDFakeDomain new)! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 12/16/2007 22:41'!mergeIn: wc		wc loadVersion: (self versionWith: 'alpha').	^ MDMerge		toInclude: (self versionWith: 'beta')		in: wc.! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:45'!removal	^ MDRemovalVariant forElement: self element! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:45'!removal: aSymbol	^ MDRemovalVariant forElement: (self element: aSymbol)! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 1/19/2007 23:12'!slice	^ MDExplicitSlice named: 'TestSlice'.! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 7/23/2008 07:14'!sliceVariant	| slice element variant |	slice := self slice.	element := MDSliceElement 		projectId: (MDHashstamp fromString: '+++++6tCHw7ghiWz05AunY6i-a4LPqBg')		sliceId: slice id.	variant := MDDefinitionVariant forElement: element.	slice properties keysAndValuesDo: 		[ :k :v | 		variant properties 			at: k			put: v ].	^ variant! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 7/23/2008 07:14'!sliceVersion	^ MDElementVersion variant: self sliceVariant! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:09'!snapshot	^ self snapshot: [:versions | ].! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 7/23/2008 07:10'!snapshot: aBlock	| versions |	versions := Set new.		versions 		add: (self versionFor: #Alpha with: 'alpha');		add: (self versionFor: #Beta with: 'beta')	.	aBlock value: versions.	^ MDSnapshot withVersions: versions! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 10/16/2005 14:12'!updateVersion: anElementVersion property: aSymbol put: anObject 	| newVariant |	newVariant := anElementVersion variant copy.	newVariant properties at: aSymbol put: anObject.	^MDElementVersion 		variant: newVariant		ancestry: anElementVersion fullAncestry! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 10/16/2005 14:39'!version	^ MDElementVersion variant: self definition! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 3/25/2005 22:55'!versionFor: elementName	^ self versionFor: elementName with: elementName asLowercase! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!versionFor: elementName with: value	| element snapshot |	element := MDFakeElement named: elementName.	snapshot := MDDefinitionVariant forElement: element.	snapshot properties at: #one put: value.	^ MDElementVersion variant: snapshot! !!MDTestBuilder methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!versionWith: value	| snapshot |	snapshot := MDDefinitionVariant forElement: self element.	snapshot properties at: #one put: value.	^ MDElementVersion variant: snapshot! !TestCase subclass: #MDTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/24/2008 14:41'!builder	^ MDTestBuilder new! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:43'!definition	^ MDDefinitionVariant forElement: self element! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!definition: aSymbol	| definition |	definition := MDDefinitionVariant forElement: (self element: aSymbol).	definition properties at: #one put: 1.	^ definition! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!element	^ self element: #Alpha! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!element: aSymbol	^ MDFakeElement named: aSymbol! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:31'!elements	^ Set		with: (MDFakeElement named: #Alpha)		with: (MDFakeElement named: #Beta)! !!MDTestCase methodsFor: 'asserting' stamp: 'cwp 3/2/2005 22:51'!fail	self signalFailure: 'Assertion failed'! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 1/19/2007 22:26'!memo	^ self memo: #abc! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 1/19/2007 22:28'!memo: aSymbol	^ MDMemo		snapshot: self snapshot		slice: self slice		parents: Set new		properties: (MDPropertyDictionary new id: aSymbol; yourself)! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:45'!removal	^ MDRemovalVariant forElement: self element! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 10/16/2005 13:45'!removal: aSymbol	^ MDRemovalVariant forElement: (self element: aSymbol)! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 1/19/2007 23:12'!slice	^ MDExplicitSlice named: 'TestSlice'.! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!sliceVersion	| element variant slice |	slice := self slice.	element := MDSliceElement forSlice: slice.	variant := MDDefinitionVariant forElement: element.	slice properties keysAndValuesDo: [:k :v | variant properties at: k put: v].	^ MDElementVersion variant: variant! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:09'!snapshot	^ self snapshot: [:versions | ].! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/24/2008 13:21'!snapshot: aBlock	| versions |	versions := Set new.		versions 		add: (self versionFor: #Alpha with: 'alpha');		add: (self versionFor: #Beta with: 'beta')	.	aBlock value: versions.	^ MDSnapshot withVersions: versions! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 10/16/2005 14:12'!updateVersion: anElementVersion property: aSymbol put: anObject 	| newVariant |	newVariant := anElementVersion variant copy.	newVariant properties at: aSymbol put: anObject.	^MDElementVersion 		variant: newVariant		ancestry: anElementVersion fullAncestry! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 10/16/2005 14:39'!version	^ MDElementVersion variant: self definition! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 3/25/2005 22:55'!versionFor: elementName	^ self versionFor: elementName with: elementName asLowercase! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!versionFor: elementName with: value	| element snapshot |	element := MDFakeElement named: elementName.	snapshot := MDDefinitionVariant forElement: element.	snapshot properties at: #one put: value.	^ MDElementVersion variant: snapshot! !!MDTestCase methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!versionWith: value	| snapshot |	snapshot := MDDefinitionVariant forElement: self element.	snapshot properties at: #one put: value.	^ MDElementVersion variant: snapshot! !!MDTestCase class methodsFor: 'testing' stamp: 'cwp 3/2/2005 22:35'!isAbstract	^ self name = #MDTestCase! !Magnitude variableByteSubclass: #MDTimestamp	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDTimestamp classVarNames includes: 'MDDay') ifFalse:	[MDTimestamp addClassVarName: 'MDDay']!(MDTimestamp classVarNames includes: 'MDHour') ifFalse:	[MDTimestamp addClassVarName: 'MDHour']!(MDTimestamp classVarNames includes: 'MDLeapCycle') ifFalse:	[MDTimestamp addClassVarName: 'MDLeapCycle']!(MDTimestamp classVarNames includes: 'MDMinute') ifFalse:	[MDTimestamp addClassVarName: 'MDMinute']!(MDTimestamp classVarNames includes: 'MDMonths') ifFalse:	[MDTimestamp addClassVarName: 'MDMonths']!(MDTimestamp classVarNames includes: 'MDSecond') ifFalse:	[MDTimestamp addClassVarName: 'MDSecond']!(MDTimestamp classVarNames includes: 'MDYear') ifFalse:	[MDTimestamp addClassVarName: 'MDYear']!!MDTimestamp methodsFor: 'comparing' stamp: 'cwp 9/11/2005 17:25'!< other	^ self asInteger < other asInteger! !!MDTimestamp methodsFor: 'comparing' stamp: 'cwp 9/11/2005 17:25'!= other	self class == other class ifFalse: [^ false].	self byteSize = other byteSize ifFalse: [^ false].	^ self asInteger = other asInteger! !!MDTimestamp methodsFor: 'converting' stamp: 'cwp 9/10/2005 23:30'!asInteger	| integer |	integer := 0.	1 to: self size do: [:i | integer := (integer bitShift: 8) + (self byteAt: i)].	^ integer! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/5/2005 21:19'!byteAt: index	^ self basicAt: index! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/5/2005 21:20'!byteAt: index put: byte	^ self basicAt: index put: byte! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/9/2005 04:59'!byteSize	^ self basicSize! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 6/18/2005 16:04'!day	^ (self decompose at: 4) + 1! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!decompose	| results int reduce |	results := (Array new: 7) writeStream.	int := self asInteger.	reduce := [:unit | results nextPut: int // unit. int := int \\ unit].	reduce value: MDLeapCycle.	int := self reduceYearsIn: int on: results.	int := self reduceMonthsIn: int on: results.	self lowConstants do: reduce.	^ results contents! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 4/9/2005 01:14'!epochYear	^ self class epochYear! !!MDTimestamp methodsFor: 'comparing' stamp: 'cwp 9/11/2005 18:28'!hash	^ self asInteger hash! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 4/16/2005 16:17'!highConstants	^ self class highConstants! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 6/18/2005 16:04'!hour	^ self decompose at: 5! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 4/16/2005 16:18'!lowConstants	^ self class lowConstants! !!MDTimestamp methodsFor: 'printing' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeTimestamp: self! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 6/18/2005 16:04'!minute	^ self decompose at: 6! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/9/2005 04:27'!month	^ self monthFrom: self decompose! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 6/18/2005 16:04'!monthFrom: anArray	^ (anArray at: 3) + 2 \\ 12 + 1! !!MDTimestamp methodsFor: 'printing' stamp: 'cwp 4/9/2005 02:55'!printFormat: aString	^ self printer printFormat: aString! !!MDTimestamp methodsFor: 'printing' stamp: 'cwp 4/9/2005 04:23'!printOn: aStream	self printer printOn: aStream format: '%e %B %Y %i:%M:%S %p' ! !!MDTimestamp methodsFor: 'printing' stamp: 'cwp 6/18/2005 16:04'!printer	| units |	units := self decompose.	^ MDTimestampPrinter		year: (self yearFrom: units)		month: (self monthFrom: units)		day: (units at: 4) + 1		hours: (units at: 5)		minutes: (units at: 6)		seconds: (units at: 7)! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 6/18/2005 16:04'!reduceMonthsIn: anInteger on: aStream	| months int |	months := 0.	int := anInteger.	MDMonths do: [:ea | 				int < ea					ifTrue: [aStream nextPut: months. ^ int]					ifFalse: [int := int - ea].				months := months + 1].	aStream nextPut: months.	^ int! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 8/21/2005 02:37'!reduceYearsIn: anInteger on: aStream	| years |	years := anInteger // MDYear min: 3.	aStream nextPut: years.	^ anInteger - (MDYear * years)! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/23/2008 07:29'!second	^ self decompose at: 7! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 8/9/2005 21:21'!timestamp	^ self! !!MDTimestamp methodsFor: 'accessing' stamp: 'cwp 4/9/2005 04:29'!year	^ self yearFrom: self decompose! !!MDTimestamp methodsFor: 'private' stamp: 'cwp 8/20/2005 21:48'!yearFrom: anArray	| years |	years := anArray first * 4 + (anArray at: 2).	years := years + self epochYear.	^ (anArray at: 3) < 10 ifTrue: [years] ifFalse: [years + 1]! !(MDTimestamp class instVarNames includes: 'parts') ifFalse:	[MDTimestamp class addInstVarName: 'parts']!!MDTimestamp class methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!compose: units	| int accumulate |	parts := units readStream.	accumulate := [:ea | int := parts next * ea + int].	int := 0.	self highConstants do: accumulate.	(MDMonths first: parts next) do: [:ea | int := ea + int].	self lowConstants do: accumulate.	^ int! !!MDTimestamp class methodsFor: 'accessing' stamp: 'cwp 4/9/2005 05:04'!epoch	^ self new! !!MDTimestamp class methodsFor: 'accessing' stamp: 'cwp 4/9/2005 01:29'!epochYear	^ 1980! !!MDTimestamp class methodsFor: 'instance creation' stamp: 'cwp 5/22/2008 00:10'!fromHashstamp: hashstamp	| inst |	inst := self new.	1 to: 4 do: [:i | inst byteAt: i put: (hashstamp byteAt: i)].	^ inst! !!MDTimestamp class methodsFor: 'instance creation' stamp: 'cwp 5/22/2008 00:10'!fromInteger: int		| ts |	int > self range ifTrue: [self error: 'Timestamp out of range'].	ts := self new: 4.	ts byteAt: 1 put: (int bitShift: -24).	ts byteAt: 2 put: ((int bitShift: -16) bitAnd: 16rFF).	ts byteAt: 3 put: ((int bitShift: -8) bitAnd: 16rFF).	ts byteAt: 4 put: (int bitAnd: 16rFF).	^ ts! !!MDTimestamp class methodsFor: '*mc2-squeak' stamp: 'cwp 8/12/2008 20:47'!fromSqueakMethodStamp: aString	| stream month day year hour minute |	stream := ReadStream on: aString.	[stream peek isDigit] whileFalse: [stream next].	month := (stream upTo: $/) asNumber.	day := (stream upTo: $/) asNumber.	year := (stream upTo: Character space) asNumber.	hour := (stream upTo: $:) asNumber.	minute := (stream upTo: Character space) asNumber.	stream atEnd ifFalse: [(stream next: 2) = 'pm' ifTrue: [hour := hour + 12]].		year < 1980 ifTrue:		[year < 100 			ifTrue: [year := year + (year < 80 ifTrue: [2000] ifFalse: [1900])]			ifFalse: [^ nil]].		^ self year: year month: month day: day hour: hour minute: minute second: 0! !!MDTimestamp class methodsFor: 'private' stamp: 'cwp 4/16/2005 16:16'!highConstants	^ Array		with: MDLeapCycle		with: MDYear! !!MDTimestamp class methodsFor: 'initializing' stamp: 'cwp 5/22/2008 00:10'!initialize	MDSecond := 1.	MDMinute := 60 * MDSecond.	MDHour := 60 * MDMinute.	MDDay := 24 * MDHour.	MDYear := MDDay * 365.	MDLeapCycle := MDYear * 4 + MDDay.	self initializeMonths.	! !!MDTimestamp class methodsFor: 'initializing' stamp: 'cwp 5/22/2008 00:10'!initializeMonths	MDMonths := #(31 30 31 30 31 31 30 31 30 31 31) collect: [:ea | ea * MDDay].! !!MDTimestamp class methodsFor: 'accessing' stamp: 'cwp 4/9/2005 01:40'!last	^ self fromInteger: self range! !!MDTimestamp class methodsFor: 'private' stamp: 'cwp 4/16/2005 16:17'!lowConstants	^ Array		with: MDDay		with: MDHour		with: MDMinute		with: MDSecond! !!MDTimestamp class methodsFor: 'instance creation' stamp: 'cwp 4/9/2005 05:04'!new	^ self new: 4! !!MDTimestamp class methodsFor: 'instance creation' stamp: 'cwp 5/10/2008 18:40'!now	| platform |	platform := MDPlatform current.	^ self fromInteger: platform timestampSeconds! !!MDTimestamp class methodsFor: 'accessing' stamp: 'cwp 4/9/2005 01:43'!range	^ 3786825599! !!MDTimestamp class methodsFor: 'instance creation' stamp: 'cwp 5/22/2008 00:10'!year: aYear month: aMonth day: day hour: hour minute: minute second: second	| year month units |	aMonth < 3 		ifTrue: [year := aYear - self epochYear - 1. month := aMonth + 10]		ifFalse: [year := aYear - self epochYear. month := aMonth - 2].	units := Array new: 7.	units at: 1 put: year // 4.	units at: 2 put: year \\ 4.	units at: 3 put: month - 1.	units at: 4 put: day - 1.	units at: 5 put: hour.	units at: 6 put: minute.	units at: 7 put: second.	^ self fromInteger: (self compose: units)! !Object subclass: #MDTimestampPrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!!MDTimestampPrinter commentStamp: 'cwp 4/9/2005 04:06' prior: 0!%V - If the week containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1.%W - the week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.!(MDTimestampPrinter instVarNames includes: 'year') ifFalse:	[MDTimestampPrinter addInstVarName: 'year']!(MDTimestampPrinter instVarNames includes: 'month') ifFalse:	[MDTimestampPrinter addInstVarName: 'month']!(MDTimestampPrinter instVarNames includes: 'day') ifFalse:	[MDTimestampPrinter addInstVarName: 'day']!(MDTimestampPrinter instVarNames includes: 'hours') ifFalse:	[MDTimestampPrinter addInstVarName: 'hours']!(MDTimestampPrinter instVarNames includes: 'minutes') ifFalse:	[MDTimestampPrinter addInstVarName: 'minutes']!(MDTimestampPrinter instVarNames includes: 'seconds') ifFalse:	[MDTimestampPrinter addInstVarName: 'seconds']!(MDTimestampPrinter classVarNames includes: 'MDMap') ifFalse:	[MDTimestampPrinter addClassVarName: 'MDMap']!(MDTimestampPrinter classVarNames includes: 'MDMonthNames') ifFalse:	[MDTimestampPrinter addClassVarName: 'MDMonthNames']!!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 10/2/2008 20:15'!abbreviatedMonthName: aStream 	aStream nextPutAll: ((MDMonthNames at: month) first: 3)! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 04:22'!ampm: aStream	aStream nextPutAll: (hours > 12 ifFalse: ['am'] ifTrue: ['pm'])! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:07'!day	^day! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:07'!day: anObject	day := anObject! !!MDTimestampPrinter methodsFor: 'errors' stamp: 'cwp 10/2/2008 20:15'!doesNotUnderstand: aMessage 	(MDMap values includes: aMessage selector) ifTrue: [ self error: 'Unimplemented specifier' ].	^ super doesNotUnderstand: aMessage! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 10/2/2008 20:15'!fullMonthName: aStream 	aStream nextPutAll: (MDMonthNames at: month)! !!MDTimestampPrinter methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!hour12	| int |	int := hours \\ 12.	int = 0 ifTrue: [int := 12].	^ int! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!hours	^hours! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!hours: anObject	hours := anObject! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!minutes	^minutes! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!minutes: anObject	minutes := anObject! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!month	^month! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!month: anObject	month := anObject! !!MDTimestampPrinter methodsFor: 'private' stamp: 'cwp 4/9/2005 03:52'!pad: anInteger on: aStream	anInteger < 10 ifTrue: [aStream nextPut: $0]! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:52'!paddedDay: aStream	self pad: day on: aStream.	self unpaddedDay: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 5/22/2008 00:10'!paddedHour12: aStream	| int |	int := self hour12.	self pad: int on: aStream.	int printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:58'!paddedHour24: aStream	self pad: hours on: aStream.	hours printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:57'!paddedMinute: aStream	self pad: minutes on: aStream.	minutes printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:51'!paddedMonth: aStream	self pad: month on: aStream.	self unpaddedMonth: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 04:21'!paddedSecond: aStream	self pad: seconds on: aStream.	seconds printOn: aStream! !!MDTimestampPrinter methodsFor: 'printing' stamp: 'cwp 5/22/2008 00:10'!printFormat: aString	| stream |	stream := (String new: 10) writeStream.	self printOn: stream format: aString.	^ stream contents! !!MDTimestampPrinter methodsFor: 'printing' stamp: 'cwp 5/22/2008 00:10'!printOn: aStream format: aString	| specification char |	specification := aString readStream.	[specification atEnd]	 whileFalse: 		[char := specification next.		char = $%			ifTrue: [self printOn: aStream specifier: specification next]			ifFalse: [aStream nextPut: char]]! !!MDTimestampPrinter methodsFor: 'printing' stamp: 'cwp 10/2/2008 20:15'!printOn: aStream specifier: aCharacter 	| selector |	selector := MDMap 		at: aCharacter		ifAbsent: [ self error: 'Unrecognized specifier: ' , aCharacter ].	self 		perform: selector		with: aStream! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:01'!seconds	^seconds! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:01'!seconds: anObject	seconds := anObject! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:52'!unpaddedDay: aStream	day printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 04:20'!unpaddedHour12: aStream	self hour12 printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:47'!unpaddedMonth: aStream	month printOn: aStream! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 04:08'!weekNumberMonday	"From the Unix spec: 'If the week containing 1 January has four or more days	in the new year, then it is considered week 1. Otherwise, it is the last week of	the previous year, and the next week is week 1.'"	self error: 'Unimplemented Specifier'! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 04:08'!weekNumberMonday2	"From the Unix spec: 'If the week containing 1 January has four or more days in the new year, 	then it is considered week 1. Otherwise, it is the last week of the previous year, 	and the next week is week 1.'"	self error: 'Unimplemented Specifier'! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!year	^year! !!MDTimestampPrinter methodsFor: 'accessing' stamp: 'cwp 4/9/2005 03:00'!year: anObject	year := anObject! !!MDTimestampPrinter methodsFor: 'specifiers' stamp: 'cwp 4/9/2005 03:53'!yearLong: aStream	year printOn: aStream! !!MDTimestampPrinter class methodsFor: 'class initialization' stamp: 'cwp 10/2/2008 20:15'!initialize	MDMonthNames := #(		#January		#February		#March		#April		#May		#June		#July		#August		#September		#Ocober		#November		#December	).	MDMap := Dictionary new.	MDMap		at: $a			put: #abbreviatedWeekdayName:;		at: $A			put: #fullWeekdayName:;		at: $b			put: #abbreviatedMonthName:;		at: $B			put: #fullMonthName:;		at: $C			put: #centuryNumber:;		at: $d			put: #paddedDay:;		at: $D			put: #usDate:;		at: $e			put: #unpaddedDay:;		at: $h			put: #unpaddedHour24;		at: $H			put: #paddedHour24:;		at: $i			put: #unpaddedHour12:;		at: $I			put: #paddedHour12:;		at: $j			put: #dayOfYear:;		at: $l			put: #unpaddedMonth:;		at: $m			put: #paddedMonth:;		at: $M			put: #paddedMinute:;		at: $n			put: #newline:;		at: $p			put: #ampm:;		at: $S			put: #paddedSecond:;		at: $t			put: #tab:;		at: $u			put: #weekDayMonday:;		at: $U			put: #weekNumberSunday:;		at: $V			put: #weekNumberMonday:;		at: $w			put: #weekDaySunday:;		at: $W			put: #weekNumberMonday2:;		at: $y			put: #yearShort:;		at: $Y			put: #yearLong:;		at: $%			put: #percent:! !!MDTimestampPrinter class methodsFor: 'instance creation' stamp: 'cwp 4/9/2005 03:03'!year: year month: month day: day hours: hours minutes: minutes seconds: seconds	^ self new		year: year;		month: month;		day: day;		hours: hours;		minutes: minutes;		seconds: seconds;		yourself! !TestCase subclass: #MDTimestampPrinterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDTimestampPrinterTest instVarNames includes: 'ts') ifFalse:	[MDTimestampPrinterTest addInstVarName: 'ts']!!MDTimestampPrinterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!assert: format prints: expected	| actual |	actual := ts printFormat: format.	self assert: expected = actual! !!MDTimestampPrinterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!testNativePrintOn	ts := MDTimestamp			year: 2006			month: 5			day: 4			hour: 3			minute: 2			second: 1.	self assert: '%e %B %Y %i:%M:%S %p' prints: '4 May 2006 3:02:01 am'! !!MDTimestampPrinterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!testSqueakMethodStampAm	ts := MDTimestamp			year: 2006			month: 5			day: 4			hour: 1			minute: 2			second: 1.	self assert: '%l/%e/%Y %H:%M' prints: '5/4/2006 01:02'! !!MDTimestampPrinterTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!testSqueakMethodStampPm	ts := MDTimestamp			year: 2006			month: 5			day: 4			hour: 15			minute: 2			second: 1.	self assert: '%l/%e/%Y %H:%M' prints: '5/4/2006 15:02'! !TestCase subclass: #MDTimestampTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDTimestampTest methodsFor: 'support' stamp: 'cwp 5/22/2008 00:10'!intWithBytes: anArray	| int |	int := 0.	1 to: 4 do: [:i | int := (int bitShift: 8) + (anArray at: i)].	^ int! !!MDTimestampTest methodsFor: 'support' stamp: 'cwp 5/22/2008 00:10'!recompose: units	| int |	int := MDTimestamp compose: units.	^ (MDTimestamp fromInteger: int) decompose! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testAsInteger	| int ts |	int := self intWithBytes: #(1 2 3 4).	ts := MDTimestamp fromInteger: int.	self assert: ts asInteger = int.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testByteOrder	| ts |	ts := self tsWithBytes: #(1 2 3 4).	self assert: (ts byteAt: 1) = 1.	self assert: (ts byteAt: 2) = 2.	self assert: (ts byteAt: 3) = 3.	self assert: (ts byteAt: 4) = 4.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testComposition1	| units |	units := #(1 2 3 4 5 6 7).	self assert: (self recompose: units) = units! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testComposition2	| before after |	before := #(7 3 5 4 3 2 1).	after := self recompose: before.	self assert: before = after! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 4/16/2005 16:50'!testDays	self assert: (self ts: #(2001 02 23 00 00 00)) day = 23.	self assert: (self ts: #(2001 02 23 00 00 01)) day = 23.	self assert: (self ts: #(2001 02 23 23 59 59)) day = 23.	self assert: (self ts: #(2005 02 23 12 00 00)) day = 23.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 4/9/2005 01:38'!testEndOfEpoch	self 	should: [MDTimestamp fromInteger: MDTimestamp last asInteger + 1]	raise: Error! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testEpoch	| ts |	ts := MDTimestamp epoch.	self assert: ts byteSize <= 4.	self assert: ts asInteger = 0! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testEquality	| left right |	left := MDTimestamp now.	right := left copy.	self deny: left == right.	self assert: left = right.! !!MDTimestampTest methodsFor: '*mc2-squeak' stamp: 'cwp 5/22/2008 00:10'!testFromSqueakMethodStamp	| ts |	ts := MDTimestamp fromSqueakMethodStamp: 'cwp 4/7/2005 01:30'.	self assert: ts printString = '7 April 2005 1:30:00 am'! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testHour01	self assert: (self ts: #(2001 02 23 00 00 00)) hour = 0.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testHour02	self assert: (self ts: #(2001 02 23 01 00 01)) hour = 1.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testHour03	self assert: (self ts: #(2001 02 23 23 59 59)) hour = 23.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:20'!testHour04	self assert: (self ts: #(2005 04 07 01 30 00)) hour = 1.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 23:02'!testLeapYear	| ts |	ts := self ts: #(2004 02 29 01 00 00).	self assert: ts day = 29.	self assert: ts month = 2! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMagnitude01	| a b |	a := self tsWithBytes: #(1 2 3 4).	b := self tsWithBytes: #(1 2 3 5).	self assert: a < b! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMagnitude02	| a b |	a := self tsWithBytes: #(1 2 3 4).	b := self tsWithBytes: #(1 2 3 4).	self deny: a < b! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMagnitude03	| a b |	a := self tsWithBytes: #(1 2 3 4).	b := self tsWithBytes: #(1 2 3 3).	self deny: a < b! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMagnitude04	| a b |	a := self tsWithBytes: #(1 2 3 4).	b := self tsWithBytes: #(1 2 4 4).	self assert: a < b! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testMinute01	self assert: (self ts: #(2001 02 23 00 00 00)) minute = 0.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testMinute02	self assert: (self ts: #(2001 02 23 01 01 01)) minute = 1.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:19'!testMinute03	self assert: (self ts: #(2001 02 23 23 59 59)) minute = 59.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testMonths	| base increment ts |	base :=  24969600. 			"Value of Dec 15, the year of the epoch"	increment := 86400 * 30.		"Number of seconds in 30 days"		"Start at Jan 15, and add 30 days at a time, to test each month."	1 to: 12 do: 		[:i | 		ts := MDTimestamp fromInteger: i * increment + base.		self assert: ts month = i]! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testNow	| ts |	ts := MDTimestamp now.	self assert: ts size <= 4.	self assert: ts asInteger positive! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 6/18/2005 16:04'!testPrinting1	| ts |	ts := self ts: #(2000 03 01 00 00 00).	self assert: ts printString = '1 March 2000 12:00:00 am'.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 6/18/2005 16:04'!testPrinting2	| ts |	ts := self ts: #(2005 04 07 23 28 31).	self assert: ts printString = '7 April 2005 11:28:31 pm'! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 6/18/2005 16:04'!testPrinting3	| ts |	ts := self ts: #(2005 04 07 03 28 31).	self assert: ts printString = '7 April 2005 3:28:31 am'! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testRange	| begin end |	begin := MDTimestamp epoch.	end := MDTimestamp last.	self assert: MDTimestamp range = (end asInteger - begin asInteger)! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:18'!testSecond01	self assert: (self ts: #(2001 02 23 00 00 00)) second = 0.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:18'!testSecond02	self assert: (self ts: #(2001 02 23 01 01 01)) second = 1.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 9/10/2005 23:18'!testSecond03	self assert: (self ts: #(2001 02 23 23 59 59)) second = 59.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:28'!testYear01	self assert: (self ts: #(1984 02 28 00 01 00)) year = 1984.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:28'!testYear02	self assert: (self ts: #(1984 02 29 00 01 00)) year = 1984.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:28'!testYear03	self assert: (self ts: #(1984 03 01 00 01 00)) year = 1984.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:28'!testYear04	self assert: (self ts: #(2001 02 23 00 01 00)) year = 2001.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:28'!testYear05	self assert: (self ts: #(2001 02 28 23 59 59)) year = 2001.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:29'!testYear06	self assert: (self ts: #(2001 03 01 00 00 00)) year = 2001.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:29'!testYear07	self assert: (self ts: #(2001 03 01 00 00 01)) year = 2001.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:29'!testYear08	self assert: (self ts: #(2003 02 23 00 01 00)) year = 2003.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:30'!testYear09	self assert: (self ts: #(2003 02 23 00 01 00)) year = 2003.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:38'!testYear10	self assert: (self ts: #(2004 02 23 00 01 00)) year = 2004.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:33'!testYear11	self assert: (self ts: #(2004 02 29 00 01 00)) year = 2004.	! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:34'!testYear12	self assert: (self ts: #(2004 04 29 00 01 00)) year = 2004.! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 21:34'!testYear13	self assert: (self ts: #(2005 02 23 00 01 00)) year = 2005.	! !!MDTimestampTest methodsFor: 'tests' stamp: 'cwp 8/20/2005 20:30'!testYear14	self assert: (self ts: #(2004 01 07 09 11 00)) year = 2004.! !!MDTimestampTest methodsFor: 'support' stamp: 'cwp 6/18/2005 16:04'!ts: anArray	| parts |	parts := Array new: 6.	parts atAllPut: 0.	anArray withIndexDo: [:ea :i | parts at: i put: ea].	^ MDTimestamp		year: (parts at: 1)		month: (parts at: 2)		day: (parts at: 3)		hour: (parts at: 4)		minute: (parts at: 5)		second: (parts at: 6)! !!MDTimestampTest methodsFor: 'support' stamp: 'cwp 9/11/2005 18:25'!tsWithBytes: anArray	^ MDTimestamp fromInteger: (self intWithBytes: anArray)! !Object subclass: #MDVariant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDVariant commentStamp: 'dc 6/14/2007 06:15' prior: 0!A variant describes the state of a particular element. That state might be "not present in the image," in the case of a RemovalVariant, or the properties of the element, in the case of a DefinitionVariant. One of the things that we noticed with MC1 is that the exact components of a definition are most likely to change, so we encode them using a PropertyDictionary instead of dedicated objects.!(MDVariant instVarNames includes: 'element') ifFalse:	[MDVariant addInstVarName: 'element']!!MDVariant methodsFor: 'comparing' stamp: 'dc 6/14/2007 06:21'!= other	^ self species = other species		and: [self element = other element]! !!MDVariant methodsFor: 'accessing' stamp: 'cwp 10/16/2005 14:43'!element	^ element! !!MDVariant methodsFor: 'comparing' stamp: 'dc 6/14/2007 06:20'!hash	^ element hash! !!MDVariant methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 06:18'!initializeWithElement: anImageElement	element := anImageElement! !!MDVariant methodsFor: '*mc2-squeakui' stamp: 'cwp 7/26/2008 16:39'!name	^ self element printString! !!MDVariant methodsFor: 'converting' stamp: 'dc 6/21/2007 18:32'!newElementVersion	"Creates a new version based on the receiver."	^ MDElementVersion variant: self! !!MDVariant class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 06:17'!forElement: anElement	^ self new		initializeWithElement: anElement;		yourself! !Object subclass: #MDVersionedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Utilities'!(MDVersionedObject instVarNames includes: 'id') ifFalse:	[MDVersionedObject addInstVarName: 'id']!!MDVersionedObject methodsFor: 'comparing' stamp: 'cwp 5/31/2008 14:17'!= other 	^ id = other id! !!MDVersionedObject methodsFor: 'comparing' stamp: 'cwp 5/31/2008 14:14'!hash	^ id hash! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:13'!id	^ id! !!MDVersionedObject methodsFor: 'private' stamp: 'cwp 5/31/2008 14:15'!initId		id := MDHashstamp 			hashIn: [:s | MDMarshal serialize: self properties on: s]			timestamp: MDTimestamp epoch! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:22'!load: properties	self subclassResponsibility! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:26'!name	^ self subclassResponsibility! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:15'!properties	^ self update: MDPropertyDictionary new! !!MDVersionedObject methodsFor: 'private' stamp: 'cwp 5/31/2008 14:14'!setId: aHashstamp	id := aHashstamp! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 18:25'!timestamp	^ nil! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:26'!type	^ self class type! !!MDVersionedObject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:08'!update: properties	^ properties		name: self name;		type: self type;		yourself! !!MDVersionedObject class methodsFor: 'instance creation' stamp: 'cwp 5/31/2008 18:02'!classForType: type 	| class |	class := self allSubclasses 		detect: [ :ea | ea type = type ]		ifNone: [ self error: 'Couldn''t find an appropriate type' ].	^ class! !!MDVersionedObject class methodsFor: 'instance creation' stamp: 'cwp 5/31/2008 14:28'!id: aHashstamp	^ self new setId: aHashstamp! !!MDVersionedObject class methodsFor: 'instance creation' stamp: 'cwp 11/20/2008 18:51'!new	^ self basicNew initialize! !!MDVersionedObject class methodsFor: 'accessing' stamp: 'cwp 6/17/2008 00:21'!type	^ nil! !!MDVersionedObject class methodsFor: 'instance creation' stamp: 'cwp 5/31/2008 17:58'!withProperties: properties 	^ (self classForType: properties type) new		load: properties;		initId;		yourself! !Object subclass: #MDVolatileValue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakPlatform'!(MDVolatileValue instVarNames includes: 'lastImageName') ifFalse:	[MDVolatileValue addInstVarName: 'lastImageName']!(MDVolatileValue instVarNames includes: 'value') ifFalse:	[MDVolatileValue addInstVarName: 'value']!!MDVolatileValue methodsFor: 'accessing' stamp: 'cwp 10/20/2008 21:26'!value	^ lastImageName = MDPlatform current imageName		ifTrue: [value]		ifFalse: [nil]! !!MDVolatileValue methodsFor: 'accessing' stamp: 'cwp 10/21/2008 07:41'!value: anObject 	lastImageName := MDPlatform current imageName.	^ value := anObject! !Object subclass: #MDWorkingCopy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!!MDWorkingCopy commentStamp: 'dc 6/14/2007 08:30' prior: 0!I'm not terribly happy with this name, but I can't think of a better one. It keeps track of the state of the image with respect to versioning. It knows, for example, which versions image is based on, and can perform tasks like creating new versions based on the state of the image, or loading existing versions into the image.!(MDWorkingCopy instVarNames includes: 'domains') ifFalse:	[MDWorkingCopy addInstVarName: 'domains']!(MDWorkingCopy instVarNames includes: 'versions') ifFalse:	[MDWorkingCopy addInstVarName: 'versions']!(MDWorkingCopy instVarNames includes: 'slush') ifFalse:	[MDWorkingCopy addInstVarName: 'slush']!(MDWorkingCopy instVarNames includes: 'transaction') ifFalse:	[MDWorkingCopy addInstVarName: 'transaction']!!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 20:14'!changeForElement: anElement do: aBlock	| version variant domain |	domain := self domainForElement: anElement.	version := versions 		at: anElement 		ifAbsent: [MDNullVersion forElement: anElement].	^ (domain isUpToDate: version variant) ifFalse:		[variant := domain updateVariant: version variant copy.		aBlock value: (MDChange version: version variant: variant)]! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 8/3/2008 20:58'!changeFromVersion: aVersion do: aBlock 	| variant domain |	domain := self domainForElement: aVersion element.	(domain isUpToDate: aVersion variant) ifFalse:		[variant := domain updateVariant: aVersion variant copy.		aBlock value: (MDChange version: aVersion variant: variant) ]! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 5/26/2008 20:10'!createVersionForElement: anElement 	| variant version domain |	domain := self domainForElement: anElement.	(domain hasElement: anElement) 		ifFalse: [^MDNullVersion forElement: anElement].	variant := (MDDefinitionVariant forElement: anElement) updateFrom: domain.	version := MDElementVersion variant: variant.	versions at: anElement put: version.	^version! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 5/26/2008 21:40'!domainAt: index in: aCollection transaction: aBlock	^ (aCollection size < index) 		ifTrue: aBlock		ifFalse: 			[(aCollection at: index) transaction: 				[self domainAt: index + 1 in: aCollection transaction: aBlock]]! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 22:02'!domainAt: aSymbol put: aDomain	domains at: aSymbol put: aDomain! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 6/17/2008 00:10'!domainForElement: anElement	^ domains 		at: anElement domain		ifAbsentPut: [MDDomain defaultForType: anElement domain]! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 10/17/2005 08:31'!ensureTransactionDuring: aBlock	^ transaction		ifNil: [self transaction: aBlock]		ifNotNil: [aBlock value]! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 23:26'!hasDomainNamed: aSymbol	^ domains includesKey: aSymbol! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 20:07'!includeVersion: anElementVersion onConflict: twoArgBlock 	| current successor element domain |	element := anElementVersion element.	current := self versionForElement: element.	domain := self domainForElement: element.	successor := current 		successor: anElementVersion		onConflict: 			[ current 				resolveConflictWith: anElementVersion				in: domain				using: twoArgBlock ].	successor == current ifTrue: [ ^ false ].	self loadVersion: successor.	^ true! !!MDWorkingCopy methodsFor: 'initialize-release' stamp: 'cwp 5/26/2008 19:53'!initialize	domains := Dictionary new.	versions := Dictionary new.	slush := Set new.! !!MDWorkingCopy methodsFor: 'private' stamp: 'dc 7/4/2007 16:38'!loadSlush	"Tries to load all versions in slush. Keeps trying until nothing is loadable anymore."	[| oldSize 	 |oldSize := slush size.	 slush := self loadSlush: slush.	 slush size ~= oldSize] whileTrue.	! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 5/26/2008 21:44'!loadSlush: elementVersions 	"Tries to load all element versions in the parameter. Collect all versions that can't be loaded and return them."	| unloadable domain |	unloadable := Set new.	elementVersions do: 		[:ea | 		domain := self domainForElement: ea element.		(domain isLoadable: ea variant) 			ifTrue: [domain loadVariant: ea variant]			ifFalse: [unloadable add: ea]].	^ unloadable! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 2/4/2006 20:45'!loadVersion: anElementVersion	self ensureTransactionDuring: 		[versions at: anElementVersion element put: anElementVersion.		transaction add: anElementVersion]! !!MDWorkingCopy methodsFor: 'private' stamp: 'cwp 5/26/2008 20:04'!newVersionForElement: anImageElement 	| oldVersion newVariant domain |	oldVersion := versions at: anImageElement.	newVariant := oldVersion variant copy.	domain := self domainForElement: anImageElement.	^ versions 		at: anImageElement		put: (MDElementVersion 				variant: (domain updateVariant: newVariant)				ancestry: oldVersion fullAncestry)! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 21:40'!transaction: aBlock	| result |	transaction := OrderedCollection new.	result := aBlock value.	slush := transaction, slush asOrderedCollection.	transaction := nil.	self domainAt: 1 in: domains asArray transaction: [self loadSlush].	^ result! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 5/26/2008 20:02'!versionForElement: anElement	| old |	old := versions 			at: anElement 			ifAbsent: [^ self createVersionForElement: anElement].	^ ((self domainForElement: anElement) isUpToDate: old variant)		ifTrue: [old]		ifFalse: [self newVersionForElement: anElement]! !!MDWorkingCopy methodsFor: 'public' stamp: 'cwp 12/22/2007 22:10'!versionForHashstamp: aHashstamp ifPresent: pBlock ifAbsent: aBlock	versions do: [:ea | ea hashstamp = aHashstamp ifTrue: [^ pBlock value: ea]].	^ aBlock value! !!MDWorkingCopy class methodsFor: 'instance creation' stamp: 'cwp 5/27/2008 06:58'!forDomain: aDomain 	^ self new		domainAt: aDomain name			put: aDomain;		yourself! !!MDWorkingCopy class methodsFor: 'instance creation' stamp: 'cwp 5/26/2008 22:01'!forTesting	^ self new 		domainAt: #fake put: MDFakeDomain new;		yourself! !!MDWorkingCopy class methodsFor: 'instance creation' stamp: 'cwp 11/20/2008 18:54'!new	^ self basicNew initialize! !!MethodReference methodsFor: '*monticello2' stamp: 'cwp 3/3/2005 02:15'!asElement	^ MDMethodElement 		className: classSymbol 		selector: methodSymbol		classIsMeta: classIsMeta! !!Object methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeObject: self! !!Set methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeSet: self! !!String methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aMarshal 	aMarshal writeString: self! !!Symbol methodsFor: '*monticello2' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeSymbol: self! !!SystemDictionary methodsFor: '*mc2-squeak' stamp: 'cwp 12/22/2006 22:35'!commit	! !!UndefinedObject methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	^ aSerializer serializeSingleton: self! !!String methodsFor: '*monticello2-serialization' stamp: 'cwp 11/20/2008 19:18'!mdSerializeWith: aSerializer 	aSerializer serializeUtf16String: self! !MDTestCase subclass: #MDAncestryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDAncestryTest instVarNames includes: 'parent') ifFalse:	[MDAncestryTest addInstVarName: 'parent']!(MDAncestryTest instVarNames includes: 'child') ifFalse:	[MDAncestryTest addInstVarName: 'child']!!MDAncestryTest methodsFor: 'constructing' stamp: 'cwp 3/2/2005 23:15'!null	^ MDNullVersion forElement: self element! !!MDAncestryTest methodsFor: 'running' stamp: 'cwp 3/2/2005 22:46'!setUp	parent := self version.	child := self 				updateVersion: parent				property: #foo				put: 'alpha2'! !!MDAncestryTest methodsFor: 'constructing' stamp: 'cwp 3/2/2005 22:55'!sibling	^self 		updateVersion: parent		property: #bar		put: 'bar'! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:47'!testChildConflictsWithParent	self deny: (child conflictsWith: parent)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:14'!testChildConflictsWithSibling	self assert: (child conflictsWith: self sibling)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:47'!testChildPrecedesParent	self deny: (child precedes: parent)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:17'!testChildPreceedsNull	self deny: (child precedes: self null)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:16'!testChildSucceedsNull	self assert: (child succeeds: self null)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:47'!testChildSucceedsParent	self assert: (child succeeds: parent)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:18'!testChildSuccessorNull	self assert: (child successor: self null onConflict: [:p | self fail]) == child! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:19'!testChildSuccessorParent	self assert: (child successor: parent onConflict: [:p | self fail]) == child! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:07'!testChildSuccessorSibling	| result merged sibling |	sibling := self sibling.	merged := child successor: sibling				onConflict: 					[result := self definition.					result properties at: #merged put: true.					result].	self assert: (merged succeeds: child).	self assert: (merged succeeds: sibling).	self assert: merged variant properties merged! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:14'!testNullPrecedesChild	self assert: (self null precedes: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:16'!testNullSucceedsChild	self deny: (self null succeeds: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:18'!testNullSuccessorChild	self assert: (child successor: self null onConflict: [:p | self fail]) == child! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:46'!testParentConflictsWithChild	self deny: (parent conflictsWith: child).! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:48'!testParentPrecedesChild	self assert: (parent precedes: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 22:48'!testParentSucceedsChild	self deny: (parent succeeds: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:19'!testParentSuccessorChild	self assert: (parent successor: child onConflict: [:p | self fail]) == child! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:15'!testSiblingConflictsWithChild	self assert: (self sibling conflictsWith: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/2/2005 23:59'!testSiblingPreceedsChild	self deny: (self sibling precedes: child)! !!MDAncestryTest methodsFor: 'tests' stamp: 'cwp 3/3/2005 00:00'!testSiblingSucceedsChild	self deny: (self sibling succeeds: child)! !MDImageElement subclass: #MDClassAwareElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!(MDClassAwareElement instVarNames includes: 'theClassName') ifFalse:	[MDClassAwareElement addInstVarName: 'theClassName']!!MDClassAwareElement methodsFor: 'comparing' stamp: 'dc 6/14/2007 05:29'!= other	^ (self species = other species)		and: [self theClassName = other theClassName]! !!MDClassAwareElement methodsFor: 'accessing' stamp: 'cwp 5/26/2008 21:50'!domain	^ #smalltalk! !!MDClassAwareElement methodsFor: 'comparing' stamp: 'dc 6/14/2007 05:29'!hash	^ theClassName hash! !!MDClassAwareElement methodsFor: 'adapting' stamp: 'dc 6/14/2007 05:28'!isIncludedInSlice: aSlice	self subclassResponsibility! !!MDClassAwareElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:42'!printStdIdOn: aStream with: aString	aStream		nextPutAll: self theClassName;		nextPutAll: ': ';		nextPutAll: aString;		nextPutAll: ' ''';		nextPutAll: self name;		nextPut: $'! !!MDClassAwareElement methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 05:30'!setClassName: aSymbol 	theClassName := aSymbol! !!MDClassAwareElement methodsFor: 'accessing' stamp: 'dc 6/14/2007 05:30'!theClassName	^ theClassName! !!MDClassAwareElement class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 05:39'!className: aSymbol	^ self new		setClassName: aSymbol;		yourself! !MDChunk subclass: #MDClassChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDClassChunk methodsFor: 'writing' stamp: 'cwp 5/22/2008 00:11'!formatKeyword	| format |	format := properties format.	format = #normal ifTrue: [^ 'subclass:'].	format = #bytes ifTrue: [^ 'variableByteSubclass:'].	format = #variable ifTrue: [^ 'variableSubclass:'].	format = #words ifTrue: [^ 'variableWordSubclass:'].	format = #weak ifTrue: [^ 'weakSubclass:'].	self error: 'Unrecognized format'! !!MDClassChunk methodsFor: 'harmonizing' stamp: 'cwp 5/19/2008 01:09'!hasSuperclass: aSymbol	^ properties		ifNil: [false]		ifNotNil: [properties superclassName = aSymbol]! !!MDClassChunk methodsFor: 'harmonizing' stamp: 'cwp 5/2/2008 23:00'!isSuperOf: aChunk	^ aChunk hasSuperclass: element theClassName! !!MDClassChunk methodsFor: 'harmonizing' stamp: 'cwp 4/26/2008 20:33'!name	^ element theClassName! !!MDClassChunk methodsFor: 'harmonizing' stamp: 'cwp 4/26/2008 20:32'!reactToClass: aSymbol	^ self! !!MDClassChunk methodsFor: 'harmonizing' stamp: 'cwp 3/30/2008 23:48'!typeChar	^ $a! !!MDClassChunk methodsFor: 'writing' stamp: 'cwp 3/28/2008 00:17'!writeDefinitionOn: aStream	aStream 		nextPutAll: properties superclassName;		space;		nextPutAll: self formatKeyword;		space;		print: element theClassName;		crtab;		nextPutAll: 'instanceVariableNames: ''''';		crtab;		nextPutAll: 'classVariableNames: ''''';		crtab;		nextPutAll: 'poolDictionaries: ''''';		crtab;		nextPutAll: 'category: ';		nextPut: $';		nextPutAll: properties category;		nextPut: $';		nextPut: $!!;		cr! !!MDClassChunk methodsFor: 'writing' stamp: 'cwp 3/28/2008 00:18'!writeRemovalOn: aStream	aStream 		nextPutAll: 'Smalltalk removeClassNamed: #';		nextPutAll: element theClassName;		nextPut: $!!;		cr! !!MDClassChunk class methodsFor: 'as yet unclassified' stamp: 'cwp 3/25/2008 00:19'!forElement: anElement	^ self new setElement: anElement! !MDChunkTest subclass: #MDClassChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionA	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #normal;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object subclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionB	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusB).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #normal;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object subclass: #BogusB	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionBytes	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #bytes;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object variableByteSubclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionCategory	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Griffle';					format: #normal;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object subclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Griffle''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionSuperclass	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #normal;					superclassName: #String;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'String subclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionVariable	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #variable;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object variableSubclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionWeak	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #weak;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object weakSubclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:41'!testDefinitionWords	| chunk properties result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	properties := MDPropertyDictionary new					category: #'Bogus-Base';					format: #words;					superclassName: #Object;					yourself.	chunk load: properties.	result := self write: chunk.	self assert: result = 'Object variableWordSubclass: #BogusA	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Bogus-Base''!!'! !!MDClassChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testRemoval	| chunk result |	chunk := MDClassChunk forElement: (MDClassElement className: #BogusA).	chunk remove.	result := self write: chunk.	self assert: result = 'Smalltalk removeClassNamed: #BogusA!!'! !MDChunk subclass: #MDClassCommentChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDClassCommentChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:48'!typeChar	^ $b! !!MDClassCommentChunk methodsFor: 'as yet unclassified' stamp: 'cwp 7/2/2008 23:06'!writeDefinitionOn: aStream	aStream		nextPut: $!!;		nextPutAll: element theClassName;		nextPutAll: ' commentStamp: ''';		nextPutAll: (properties initials ifNil: ['<unknown author>']);		space.	properties timeStamp ifNotNilDo:		[:stamp | stamp printer printOn: aStream format: '%l/%e/%Y %H:%M'].	aStream		nextPutAll: ''' prior: 0!!';		cr.	properties text do:		[:ch |		aStream nextPut: ch.		ch = $!! ifTrue: [aStream nextPut: $!!]].	aStream		nextPut: $!!;		cr! !!MDClassCommentChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 23:37'!writeRemovalOn: aStream	aStream		nextPut: $!!;		nextPutAll: element theClassName;		nextPutAll: ' classComment: nil stamp: nil!!';		cr! !MDChunkTest subclass: #MDClassCommentChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDClassCommentChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 00:43'!testClassIsRemoved	| chunk actual class |	class := MDClassChunk forElement: (MDClassElement className: #BogusA).	class remove.	chunk := MDClassCommentChunk forElement: (MDClassCommentElement className: #BogusA).	chunk load: MDPropertyDictionary new.	chunk reactToClass: class.	actual := self write: chunk.	self assert: actual isEmpty! !!MDClassCommentChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionWithBang	| chunk properties actual |	chunk := MDClassCommentChunk forElement: (MDClassCommentElement className: #BogusA).	properties := MDPropertyDictionary new					initials: 'cwp';					timeStamp: (MDTimestamp fromInteger: 886029518);					text: 'Comment!! for BogusA'					yourself.	chunk load: properties.	actual := self write: chunk.	self assert: actual =  '!!BogusA commentStamp: ''cwp 3/28/2008 23:18'' prior: 0!!Comment!!!! for BogusA!!'! !!MDClassCommentChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionWithStamp	| chunk properties actual |	chunk := MDClassCommentChunk forElement: (MDClassCommentElement className: #BogusA).	properties := MDPropertyDictionary new					initials: 'cwp';					timeStamp: (MDTimestamp fromInteger: 886029518);					text: 'Comment for BogusA'					yourself.	chunk load: properties.	actual := self write: chunk.	self assert: actual =  '!!BogusA commentStamp: ''cwp 3/28/2008 23:18'' prior: 0!!Comment for BogusA!!'! !!MDClassCommentChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testRemoval	| chunk actual |	chunk := MDClassCommentChunk forElement: (MDClassCommentElement className: #BogusA).	chunk remove.	actual := self write: chunk.	self assert: actual =  '!!BogusA classComment: nil stamp: nil!!'! !MDDefinitionTest subclass: #MDClassDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Tests'!!MDClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/1/2008 22:16'!expectedText	^ 'Object subclass: BogusA	category: ''Bogus-Base'''! !!MDClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/1/2008 22:16'!newText	^ 'Object subclass: BogusA	category: ''Bogus-Format'''! !!MDClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!variant	| variant |	variant := MDDefinitionVariant forElement: 				(MDClassElement className: #BogusA).	variant properties		category: #'Bogus-Base';		format: #normal;		superclassName: #Object.	^ variant! !MDRepositoryTest subclass: #MDDirectoryRepositoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDDirectoryRepositoryTest instVarNames includes: 'directory') ifFalse:	[MDDirectoryRepositoryTest addInstVarName: 'directory']!(MDDirectoryRepositoryTest instVarNames includes: 'tearDownRepositories') ifFalse:	[MDDirectoryRepositoryTest addInstVarName: 'tearDownRepositories']!!MDDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/18/2008 20:03'!directoryName	^ 'TestRepository'! !!MDDirectoryRepositoryTest methodsFor: 'constructing' stamp: 'cwp 10/27/2008 23:45'!newRepository	^ self noteRepository: (MDDirectoryRepository on: directory)! !!MDDirectoryRepositoryTest methodsFor: 'running' stamp: 'cwp 10/27/2008 23:45'!noteRepository: aRepository 	^ tearDownRepositories add: aRepository! !!MDDirectoryRepositoryTest methodsFor: 'constructing' stamp: 'cwp 10/27/2008 23:45'!secondRepository	| dirName dir |	dirName := self directoryName , '2'.	dir := FileDirectory default directoryNamed: dirName.	^ self noteRepository: (MDDirectoryRepository on: dir)! !!MDDirectoryRepositoryTest methodsFor: 'running' stamp: 'cwp 10/27/2008 23:43'!setUp	directory := FileDirectory default directoryNamed: self directoryName.	tearDownRepositories := OrderedCollection new.	super setUp! !!MDDirectoryRepositoryTest methodsFor: 'running' stamp: 'cwp 10/25/2008 18:30'!tearDown	super tearDown.	tearDownRepositories do: 		[:ea | 		ea close.		(ea instVarNamed: 'directory') recursiveDelete].! !!MDDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/25/2008 15:37'!testDiscovery	| version retrieved file |	version := MDTestBuilder new version.	file := MDFileRepository on: 		(directory newFileNamed: 'fb6a3295-edc1-47c3-aaa2-588649a0c11d.mcr').	file put: version.	file close.	retrieved := repository get: version hashstamp.	self assert: retrieved = version! !!MDDirectoryRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 22:44'!testLoad	| newName properties |	newName := repository name , '-Renamed'.	properties := MDPropertyDictionary new		type: repository class type;		name: newName;		yourself.	repository properties: properties.	self assert: repository name = newName.	self assert: (FileDirectory default directoryExists: newName).! !!MDDirectoryRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 23:45'!testLoadNewInstance	| id newName properties newRepository |	id := MDHashstamp fromString: '+++++8cdN1p7Wv6oyR1zmR0Mf3oRYhjR'.	newName := repository name , '-Renamed'.	properties := MDPropertyDictionary new		type: repository class type;		name: newName;		yourself.	newRepository := MDDirectoryRepository id: id.	self noteRepository: newRepository.	newRepository properties: properties.	self assert: newRepository name = newName.	self assert: (FileDirectory default directoryExists: newName)! !!MDDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/21/2008 20:23'!testNameFromDirectory	self assert: repository name = 'TestRepository'! !!MDDirectoryRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 22:35'!testProperties	| properties |	properties := repository properties.	self assert: properties type = #McrDirectory.	self assert: properties name = 'TestRepository'! !MDAnnouncement subclass: #MDElementChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!(MDElementChange instVarNames includes: 'element') ifFalse:	[MDElementChange addInstVarName: 'element']!!MDElementChange methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:26'!element	^ element! !!MDElementChange methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:26'!setElement: anElement	element := anElement! !!MDElementChange class methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 07:26'!for: anElement	^ self new setElement: anElement! !MDNetMessage subclass: #MDEmptyMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDEmptyMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:04'!= other	^ self species = other species! !!MDEmptyMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:04'!hash	^ self species hash! !!MDEmptyMessage class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:05'!readContentsFrom: aStream	^ self new! !MDNetMessage subclass: #MDErrorMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDErrorMessage instVarNames includes: 'description') ifFalse:	[MDErrorMessage addInstVarName: 'description']!!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:26'!= other	^ self species = other species and: [self description = other description]! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:54'!checkForError	MDPeerError signal: description! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:29'!description	^ description! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:27'!hash	^ description hash! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:53'!isError	^ true! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setContents: aString	description := aString! !!MDErrorMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:28'!writeContentsOn: aStream	MDMarshal serialize: description on: aStream! !MDAdaptionTest subclass: #MDFakeAdaptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDFakeAdaptionTest methodsFor: 'converting' stamp: 'cwp 5/26/2008 19:39'!proxyClass	^ MDFakeDomain! !MDFakeClassDescription subclass: #MDFakeClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!(MDFakeClass instVarNames includes: 'subclasses') ifFalse:	[MDFakeClass addInstVarName: 'subclasses']!(MDFakeClass instVarNames includes: 'classPool') ifFalse:	[MDFakeClass addInstVarName: 'classPool']!(MDFakeClass instVarNames includes: 'sharedPools') ifFalse:	[MDFakeClass addInstVarName: 'sharedPools']!(MDFakeClass instVarNames includes: 'environement') ifFalse:	[MDFakeClass addInstVarName: 'environement']!(MDFakeClass instVarNames includes: 'category') ifFalse:	[MDFakeClass addInstVarName: 'category']!!MDFakeClass methodsFor: 'mutation' stamp: 'cwp 8/27/2005 10:37'!addClassVarName: aString	classPool at: aString asSymbol put: nil! !!MDFakeClass methodsFor: 'mutation' stamp: 'cwp 5/22/2008 00:13'!addSharedPool: aSharedPool 	(self sharedPools includes: aSharedPool)		ifTrue: [^self error: 'This is already in my shared pool list'].	sharedPools == nil		ifTrue: [sharedPools := OrderedCollection with: aSharedPool]		ifFalse: [sharedPools add: aSharedPool]! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!category	^category! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!category: anObject	category := anObject! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!classPool	^classPool! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!classPool: anObject	classPool := anObject! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 10:48'!classVarNames	^ classPool keys! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!environement	^environement! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!environement: anObject	environement := anObject! !!MDFakeClass methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:13'!initializeFromClass: aClass	superclass := aClass superclass.	methodDict := aClass methodDict copy.	format := aClass format.	name := aClass name.	organization := aClass organization copy.	instanceVariables := aClass instVarNames.	classPool := aClass classPool copy.	sharedPools := aClass sharedPools copy.	! !!MDFakeClass methodsFor: 'testing' stamp: 'cwp 8/27/2005 12:50'!isMeta	^ false! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!sharedPools	^sharedPools! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!sharedPools: anObject	sharedPools := anObject! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!subclasses	^subclasses! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/26/2005 18:35'!subclasses: anObject	subclasses := anObject! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:55'!theMetaClass	^MDFakeMetaclass basedOn: self theRealClass class! !!MDFakeClass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:52'!theNonMetaClass	^ self! !!MDFakeClass class methodsFor: 'instance creation' stamp: 'cwp 8/27/2005 11:50'!basedOn: aClass	^ self new initializeFromClass: aClass theNonMetaClass! !MDDomain subclass: #MDFakeDomain	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Fakes'!(MDFakeDomain instVarNames includes: 'dict') ifFalse:	[MDFakeDomain addInstVarName: 'dict']!!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/12/2005 14:04'!adaptorForClassCommentElement: anElement	^ self adaptorForElement: anElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:18'!adaptorForClassElement: aClassElement 	^ self adaptorForElement: aClassElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 3/4/2005 14:46'!adaptorForClassInstVarElement: anElement	^ self adaptorForElement: anElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:29'!adaptorForClassVarElement: anClassVarElement	^ self adaptorForElement: anClassVarElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 5/11/2008 22:02'!adaptorForElement: anElement 	^ MDFakeElementAdaptor		forElement: anElement		inImage: self! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:29'!adaptorForInstVarElement: anInstVarElement	^ self adaptorForElement: anInstVarElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 3/15/2005 22:36'!adaptorForLogElement: anElement	^ self adaptorForElement: anElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 3/22/2005 23:13'!adaptorForMetadataElement: anElement	^ self adaptorForElement: anElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/5/2005 19:05'!adaptorForMethodElement: aMethodElement 	^ self adaptorForElement: aMethodElement! !!MDFakeDomain methodsFor: 'adapting' stamp: 'cwp 2/7/2005 00:01'!adaptorForPoolImportElement: aPoolImportElement 	^ self adaptorForElement: aPoolImportElement! !!MDFakeDomain methodsFor: 'accessing' stamp: 'cwp 5/18/2008 20:07'!allElements	^ dict keys! !!MDFakeDomain methodsFor: 'private' stamp: 'cwp 5/11/2008 22:24'!at: anElement	(self includesElement: anElement) ifFalse:		[dict at: anElement put: Dictionary new].	^ dict at: anElement! !!MDFakeDomain methodsFor: 'private' stamp: 'cwp 5/11/2008 12:32'!at: anElement ifAbsent: aBlock	^ dict at: anElement ifAbsent: aBlock! !!MDFakeDomain methodsFor: 'private' stamp: 'cwp 11/28/2004 15:25'!at: anElement put: aPropertyDictionary	dict at: anElement put: aPropertyDictionary! !!MDFakeDomain methodsFor: 'accessing' stamp: 'cwp 5/18/2008 20:08'!elements	| result |	result := Set new.	dict keysAndValuesDo: [ :element :version | version ifNotNil: [ result add: element ] ].	^ result! !!MDFakeDomain methodsFor: 'private' stamp: 'cwp 5/11/2008 22:07'!includesElement: anElement 	^ (dict at: anElement ifAbsent: [^ false]) notNil! !!MDFakeDomain methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 06:43'!initialize	dict := Dictionary new! !!MDFakeDomain methodsFor: 'accessing' stamp: 'cwp 5/26/2008 22:04'!name	^ #fake! !!MDFakeDomain methodsFor: 'private' stamp: 'cwp 5/11/2008 22:02'!removeElement: anElement	(dict includesKey: anElement)		ifTrue: [dict at: anElement put: nil]! !!MDFakeDomain class methodsFor: 'as yet unclassified' stamp: 'cwp 6/15/2008 20:31'!type	^ #fake! !MDImageElement subclass: #MDFakeElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Fakes'!(MDFakeElement instVarNames includes: 'name') ifFalse:	[MDFakeElement addInstVarName: 'name']!!MDFakeElement methodsFor: 'comparing' stamp: 'cwp 2/5/2005 19:27'!= other	self species = other species ifFalse: [^ false].	^ self name = other name! !!MDFakeElement methodsFor: 'public' stamp: 'cwp 2/5/2005 19:03'!adaptedFor: anImageProxy 	^ anImageProxy adaptorForElement: self! !!MDFakeElement methodsFor: 'printing' stamp: 'cwp 4/25/2005 04:11'!displayOn: aStream	aStream nextPutAll: name! !!MDFakeElement methodsFor: 'accessing' stamp: 'cwp 5/26/2008 22:00'!domain	^ #fake! !!MDFakeElement methodsFor: 'comparing' stamp: 'cwp 2/5/2005 19:27'!hash	^ name hash! !!MDFakeElement methodsFor: 'accessing' stamp: 'cwp 2/5/2005 18:58'!name	^ name! !!MDFakeElement methodsFor: 'accessing' stamp: 'cwp 5/22/2008 00:10'!name: aSymbol	name := aSymbol! !!MDFakeElement methodsFor: 'printing' stamp: 'cwp 11/20/2008 19:05'!printOn: aStream 	aStream print: self class.	aStream nextPut: $<.	aStream nextPutAll: name.	aStream nextPut: $>! !!MDFakeElement class methodsFor: 'instance creation' stamp: 'cwp 2/5/2005 19:02'!named: aSymbol	^ self new name: aSymbol! !MDFakeClassDescription subclass: #MDFakeMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Fakes'!!MDFakeMetaclass methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:13'!initializeFromMetaclass: aMetaclass	superclass := aMetaclass superclass.	methodDict := aMetaclass methodDict copy.	format := aMetaclass format.	name := aMetaclass theNonMetaClass name.	organization := aMetaclass organization copy.	instanceVariables := aMetaclass instVarNames.! !!MDFakeMetaclass methodsFor: 'testing' stamp: 'cwp 8/27/2005 12:50'!isMeta	^ true! !!MDFakeMetaclass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:53'!name	^ name, ' class'! !!MDFakeMetaclass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:52'!theMetaClass	^ self! !!MDFakeMetaclass methodsFor: 'accessing' stamp: 'cwp 8/27/2005 11:55'!theNonMetaClass	^ MDFakeClass basedOn: self theRealClass! !!MDFakeMetaclass class methodsFor: 'as yet unclassified' stamp: 'cwp 8/27/2005 11:56'!basedOn: aMetaclass	^ self new initializeFromMetaclass: aMetaclass theMetaClass! !MDRepositoryTest subclass: #MDFileRepositoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDFileRepositoryTest instVarNames includes: 'second') ifFalse:	[MDFileRepositoryTest addInstVarName: 'second']!(MDFileRepositoryTest instVarNames includes: 'tearDownRepositories') ifFalse:	[MDFileRepositoryTest addInstVarName: 'tearDownRepositories']!!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/25/2008 15:38'!addTearDownFilename: aString	^ tearDownFilenames add: aString! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 12/23/2007 00:06'!destroyRepository: aRepository named: aString	aRepository close.	FileDirectory default deleteFileNamed: (aString, '.mcr')! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/25/2008 19:16'!isWindows	"Some tests won't work on Windows, because they simulate the interaction of	several images using a file repository at the same time. The Windows VM doesn't	allow more than one filestream on a given file at the same time, so the test fail,	even though the code works correctly in actual usage. Rather than create more	elaborate tests, we just skip them on Windows... they run fine with Mac and Unix."		^ FileDirectory default class = DosFileDirectory ! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/27/2008 23:45'!newRepository	^ self noteRepository: (MDFileRepository named: self repositoryFileName)! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/27/2008 23:45'!noteRepository: aRepository 	^ tearDownRepositories add: aRepository! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 1/1/2007 10:02'!repositoryFileName	^ 'test-file-repository'! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 12/23/2007 00:10'!secondFileName	^ 'test-file-repository2'! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/27/2008 23:45'!secondRepository	^ second := self noteRepository: (MDFileRepository named: self secondFileName)! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/25/2008 19:10'!setUp	tearDownRepositories := OrderedCollection new.	super setUp! !!MDFileRepositoryTest methodsFor: 'running' stamp: 'cwp 10/25/2008 18:59'!tearDown	super tearDown.	tearDownRepositories do: 		[:each | 		each close.		FileDirectory default deleteFileNamed: each name].	tearDownRepositories := nil! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 23:45'!testConcurrentAppend	| version get |	self isWindows ifTrue: [ ^ self ].	second := self noteRepository: self newRepository.	version := self version.	repository put: version.	self 		assert: (repository get: version hashstamp)		isEquivalentTo: version.	get := second get: version hashstamp.	self assert: get notNil.	self 		assert: get		isEquivalentTo: version! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/25/2008 14:54'!testDeletedFile	| version result |	version := self version.	repository put: version.	repository close.	FileDirectory default deleteFileNamed: self repositoryFileName , '.mcr'.	(repository instVarNamed: 'dataStream') stream reopen.		result := repository get: version hashstamp.	self assert: result isNil! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/25/2008 18:54'!testLoad	| properties newName directory |	newName := 'test-renamed-repository.mcr'.	directory := FileDirectory default.	properties := MDPropertyDictionary new name: newName; yourself.	repository properties: properties.	self assert: repository name = newName.	self assert: (directory fileExists: newName)! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 23:45'!testLoadNewInstance	| properties newName directory id newRepository |	id := MDHashstamp fromString: '+++++973ucQcsL3sjjw-+yt-8Hm+W+YD'.	newName := 'test-renamed-repository.mcr'.	directory := FileDirectory default.	properties := MDPropertyDictionary new		name: newName;		yourself.	newRepository := MDFileRepository id: id.	newRepository properties: properties.	self noteRepository: newRepository.	self assert: newRepository name = newName.	self assert: (directory fileExists: newName)! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 22:35'!testProperties	| properties expectedName |	properties := repository properties.	self assert: properties type = #McrFile.	expectedName := self repositoryFileName , repository class extension.	self assert: properties name = expectedName! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/27/2008 23:45'!testReopen	| version |	version := self version.	repository put: version.	self 		assert: (repository get: version hashstamp)		isEquivalentTo: version.	repository close.	repository := self noteRepository: self newRepository.	self 		assert: (repository get: version hashstamp)		isEquivalentTo: version! !!MDFileRepositoryTest methodsFor: 'tests' stamp: 'cwp 10/25/2008 19:13'!testTruncatedFile	| result builder alpha beta other |	self isWindows ifTrue: [^ self].	builder := MDTestBuilder new.	alpha := builder versionWith: #alpha.	beta := builder versionWith: #beta.	repository put: alpha.	repository put: beta.		FileDirectory default deleteFileNamed: self repositoryFileName , '.mcr'.	other := self newRepository.	other put: alpha.	(repository instVarNamed: 'dataStream') stream reopen.		result := repository get: alpha hashstamp.	self deny: result isNil.		result := repository get: beta hashstamp.	self assert: result isNil.! !MDNetMessage subclass: #MDHashstampMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDHashstampMessage instVarNames includes: 'hashstamps') ifFalse:	[MDHashstampMessage addInstVarName: 'hashstamps']!!MDHashstampMessage methodsFor: 'comparing' stamp: 'cwp 1/4/2008 00:02'!= other	^ self species = other species and: [self hashstamps = other hashstamps]! !!MDHashstampMessage methodsFor: 'comparing' stamp: 'cwp 1/4/2008 00:02'!hash	^ hashstamps hash! !!MDHashstampMessage methodsFor: 'accessing' stamp: 'cwp 1/4/2008 00:02'!hashstamps	^ hashstamps! !!MDHashstampMessage methodsFor: 'intialize-release' stamp: 'cwp 5/22/2008 00:11'!setContents: aCollection	hashstamps := aCollection asSet! !!MDHashstampMessage methodsFor: 'writing' stamp: 'cwp 1/4/2008 00:02'!writeContentsOn: aStream	MDMarshal serialize: hashstamps on: aStream! !MDVersionPanel subclass: #MDLocalPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Panels'!!MDLocalPanel methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 22:49'!variant	^ node localVariant! !MDHashedObject subclass: #MDMemo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!(MDMemo instVarNames includes: 'reference') ifFalse:	[MDMemo addInstVarName: 'reference']!(MDMemo instVarNames includes: 'parents') ifFalse:	[MDMemo addInstVarName: 'parents']!(MDMemo instVarNames includes: 'properties') ifFalse:	[MDMemo addInstVarName: 'properties']!(MDMemo instVarNames includes: 'sliceId') ifFalse:	[MDMemo addInstVarName: 'sliceId']!!MDMemo methodsFor: 'comparing' stamp: 'cwp 12/31/2007 14:55'!<= aMemo	^ self hashstamp <= aMemo hashstamp! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 4/1/2008 23:35'!description	^ String streamContents: 		[:stream |		self printPropertiesOn: stream.		stream cr.		properties comment ifNotNilDo: [:c | stream nextPutAll: c]]! !!MDMemo methodsFor: 'testing' stamp: 'cwp 1/19/2007 20:49'!isMemo	^ true! !!MDMemo methodsFor: 'testing' stamp: 'cwp 1/19/2007 22:42'!matchesSlice: aSlice	^ sliceId = aSlice id! !!MDMemo methodsFor: 'printing' stamp: 'cwp 12/28/2007 23:38'!name		^ String streamContents:		[:stream | 		self 			printWithSliceName: properties sliceName 			on: stream]! !!MDMemo methodsFor: 'printing' stamp: 'cwp 12/28/2007 23:38'!nameForSlice: aSlice		^ String streamContents:		[:stream | 		self printWithSliceName: aSlice name on: stream]! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 1/15/2007 22:17'!parents	^ parents! !!MDMemo methodsFor: 'printing' stamp: 'cwp 4/1/2008 23:37'!printPropertiesOn: aStream		| print dict |	print := [:key :value |			aStream 				nextPutAll: key asString;				nextPut: $:;				space;				print: value;				cr].	print value: #timestamp value: self timestamp.	dict := properties copy		removeKey: #initials ifAbsent: [];		removeKey: #ordinal ifAbsent: [];		removeKey: #comment ifAbsent: [];		removeKey: #sliceName ifAbsent: [];		yourself.	dict keys asSortedArray do: [:key | print value: key value: (dict at: key)]! !!MDMemo methodsFor: 'printing' stamp: 'cwp 5/22/2008 00:10'!printWithSliceName: aString on: aStream	| segment |	aStream nextPutAll: aString.	(segment := properties initials) ifNotNil: 		[aStream position > 0 ifTrue: [aStream nextPut: $-].		aStream nextPutAll: segment].	(segment := properties ordinal) ifNotNil: 		[aStream position > 0 ifTrue: [aStream nextPut: $.].		aStream print: segment]! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 1/15/2007 22:17'!properties	^ properties! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 1/15/2007 22:16'!reference	^ reference! !!MDMemo methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:10'!setParents: anArray properties: propdict	self initialize.	parents := anArray.	properties := propdict.! !!MDMemo methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:10'!setSnapshot: aSnapshot slice: aSlice	reference := aSnapshot hashstamp.	sliceId := aSlice id.	properties sliceName: aSlice name.	self initHashstamp! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 1/19/2007 22:24'!sliceId	^ sliceId! !!MDMemo methodsFor: 'accessing' stamp: 'cwp 1/19/2007 23:03'!sliceName	^ properties sliceName! !!MDMemo class methodsFor: 'instance creation' stamp: 'cwp 3/6/2008 19:37'!new	^ self parents: Array new properties: MDPropertyDictionary new! !!MDMemo class methodsFor: 'instance creation' stamp: 'cwp 3/6/2008 19:37'!parents: anArray	^ self parents: anArray properties: MDPropertyDictionary new! !!MDMemo class methodsFor: 'instance creation' stamp: 'cwp 1/16/2007 19:56'!parents: anArray properties: properties	^ self basicNew setParents: anArray properties: properties! !!MDMemo class methodsFor: 'instance creation' stamp: 'cwp 1/19/2007 22:26'!snapshot: aSnapshot slice: aSlice parents: aSet properties: aPropertyDictionary	^ (self parents: aSet properties: aPropertyDictionary)		setSnapshot: aSnapshot slice: aSlice;		yourself! !MDChunkTest subclass: #MDMemoChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDMemoChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 00:44'!testDescription	| memo chunk actual expected  |	memo := MDBogusRepositoryResource new setUp repository memos anyOne.	chunk := MDMemoChunk on: memo.	actual := self write: chunk.	expected := '"', memo name, String cr, memo description, '"!!', String cr.	self assert: actual = expected! !!MDMemoChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 00:52'!testDescriptionWithBang	| memo chunk actual  |	memo := (MDBogusRepositoryResource new setUp repository memos anyOne) copy.	memo properties description: 'This contains a !! inside it'.	chunk := MDMemoChunk on: memo.	actual := self write: chunk.	self assert: (actual includesSubString: '!!!!')! !!MDMemoChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 00:52'!testDescriptionWithDoubleQuote	| memo chunk actual  |	memo := (MDBogusRepositoryResource new setUp repository memos anyOne) copy.	memo properties description: 'This contains a "quoted" phrase'.	chunk := MDMemoChunk on: memo.	actual := self write: chunk.	self assert: (actual includesSubString: '""')! !MDTestCase subclass: #MDMemoTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDMemoTest instVarNames includes: 'memo') ifFalse:	[MDMemoTest addInstVarName: 'memo']!(MDMemoTest instVarNames includes: 'snapshot') ifFalse:	[MDMemoTest addInstVarName: 'snapshot']!(MDMemoTest instVarNames includes: 'slice') ifFalse:	[MDMemoTest addInstVarName: 'slice']!!MDMemoTest methodsFor: 'accessing' stamp: 'cwp 1/19/2007 22:27'!parents	^ Set		with: (self memo: #a)		with: (self memo: #b)! !!MDMemoTest methodsFor: 'accessing' stamp: 'cwp 1/15/2007 22:13'!properties	^ MDPropertyDictionary new! !!MDMemoTest methodsFor: 'running' stamp: 'cwp 5/22/2008 00:10'!setUp	memo := MDMemo 		parents: self parents		properties: self properties.	snapshot := self snapshot.	slice := self slice.	memo setSnapshot: snapshot slice: slice! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 4/1/2008 23:42'!testDescription	memo instVarNamed: 'cache' put: (MDTimestamp fromInteger: 886029518).	memo properties 		author: 'Colin Putney <cputney@wireong.ca>';		comment: 'Snapshot for testing.';		initials: 'cwp';		ordinal: 1;		sliceName: 'Bogus'.	self assert: memo description = 'timestamp: 28 March 2008 11:18:38 pmauthor: ''Colin Putney <cputney@wireong.ca>''Snapshot for testing.'! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 11/17/2007 01:27'!testName	memo properties initials: 'abc'.	memo properties ordinal: 23.	self assert: memo name = 'TestSlice-abc.23'! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 22:36'!testParents	self assert: memo parents size = 2.	self assert: (memo parents allSatisfy: [:ea | ea isKindOf: MDMemo]).! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 22:36'!testProperties	self assert: (memo properties isKindOf: MDPropertyDictionary)! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 22:38'!testSlice	self assert: (memo matchesSlice: slice)! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 23:01'!testSliceName	self assert: (memo sliceName = slice name)! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 1/19/2007 22:37'!testSnapshot	self assert: (memo hashstamp isKindOf: MDHashstamp).	self assert: (memo reference isKindOf: MDHashstamp).	self assert: memo reference = snapshot hashstamp.	self deny: memo reference = memo hashstamp.! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSortByAuthor	| other |	other := memo deepCopy.		memo properties initials: 'abd'.	memo properties ordinal: 23.		other properties initials: 'abc'.	other properties ordinal: 23.	self assert: other <= memo! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSortByOrdinal	| other |	other := memo deepCopy.		memo properties initials: 'abc'.	memo properties ordinal: 23.		other properties initials: 'abc'.	other properties ordinal: 22.	self assert: other <= memo! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSortByOrdinalFirst	| other |	other := memo deepCopy.		memo properties initials: 'abc'.	memo properties ordinal: 23.		other properties initials: 'abd'.	other properties ordinal: 22.	self assert: other <= memo! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSortWithoutAuthors	| other |	other := memo deepCopy.	memo properties ordinal: 23.	other properties ordinal: 22.	self assert: other <= memo! !!MDMemoTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSortWithoutOrdinals	| other |	other := memo deepCopy.	memo properties initials: 'abd'.	other properties initials: 'abc'.	self assert: other <= memo! !MDRepositoryTest subclass: #MDMemoryRepositoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDMemoryRepositoryTest methodsFor: 'constructing' stamp: 'avi 3/12/2005 02:39'!assert: anElementVersion isEquivalentTo: otherElementVersion	^ anElementVersion == otherElementVersion! !!MDMemoryRepositoryTest methodsFor: 'constructing' stamp: 'cwp 5/24/2008 13:07'!newRepository	^ MDMemoryRepository named: 'test'! !!MDMemoryRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/31/2008 22:42'!testLoad	| properties |	properties := MDPropertyDictionary new		name: 'renamed';		type: #Memory;		yourself.	repository properties: properties.	self assert: repository name = 'renamed'! !!MDMemoryRepositoryTest methodsFor: 'tests' stamp: 'cwp 5/31/2008 22:39'!testProperties	| properties |	properties := repository properties.	self assert: properties type = #Memory.	self assert: properties name = 'test'! !MDChunk subclass: #MDMethodChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDMethodChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:55'!typeChar	^ element classIsMeta		ifTrue: [$h]		ifFalse: [$f]! !!MDMethodChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 01:08'!writeDefinitionOn: aStream 	aStream		nextPut: $!!;		nextPutAll: element theClassName.	element classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].	aStream		space;		nextPutAll: 'methodsFor: ''';		nextPutAll: properties category.	self writeStampOn: aStream.	aStream		nextPutAll: '''!!';		cr.	properties source do:		[:ch |		aStream nextPut: ch.		ch = $!! ifTrue: [aStream nextPut: $!!]].	aStream		nextPutAll: '!! !!';		cr! !!MDMethodChunk methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:40'!writeInitializerOn: aStream	(element classIsMeta and: [element selector = #initialize]) ifTrue:		[aStream 			nextPutAll: element theClassName;			space;			nextPutAll: 'initialize!!';			cr;			cr]! !!MDMethodChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/31/2008 00:03'!writeRemovalOn: aStream	aStream nextPutAll: element theClassName.	element classIsMeta ifTrue: [aStream nextPutAll: ' class'].	aStream 		nextPutAll: ' removeSelector: #';		nextPutAll: element selector;		nextPut: $!!;		cr! !MDChunkTest subclass: #MDMethodChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:40'!initializeExpected	^ 'BogusA initialize!!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:57'!methodA	^ MDMethodChunk forElement: 		(MDMethodElement 			className: #BogusA 			selector: #a			classIsMeta: true)! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:59'!methodAExpected	^ '!!BogusA class methodsFor: ''capitals'' stamp: ''cwp 3/28/2008 23:18''!!a	^ $A!! !!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/31/2008 00:01'!methodAExpected2	^ '!!BogusA class methodsFor: ''capitals''!!a	^ $A!! !!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/31/2008 00:02'!methodAExpected3	^ 'BogusA class removeSelector: #a!!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/18/2008 23:51'!methodInitialize	^ MDMethodChunk forElement: 		(MDMethodElement 			className: #BogusA 			selector: #initialize			classIsMeta: true)! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/19/2008 00:36'!methodInstanceInitialize	^ MDMethodChunk forElement: 		(MDMethodElement 			className: #BogusA 			selector: #initialize			classIsMeta: false)! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/28/2008 23:37'!methodOne	^ MDMethodChunk forElement: 		(MDMethodElement 			className: #BogusA 			selector: #one)! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:22'!methodOneExpected	^ '!!BogusA methodsFor: ''numbers'' stamp: ''cwp 3/28/2008 23:18''!!one	^ self!! !!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:22'!methodOneExpected2	^ '!!BogusA methodsFor: ''numbers''!!one	^ self!! !!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 00:59'!methodOneExpected3	^ 'BogusA removeSelector: #one!!'! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:26'!testAInitializer	| chunk properties stream |	chunk := self methodA.	properties := MDPropertyDictionary new		category: #capitals;		initials: 'cwp';		timeStamp: (MDTimestamp fromInteger: 886029518);		source: 'initialize';		yourself.	chunk load: properties.	stream := WriteStream on: String new.	chunk writeInitializerOn: stream.	self assert: stream contents isEmpty! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:25'!testClassDefinitionWithStamp	| chunk properties actual expected |	chunk := self methodA.	properties := MDPropertyDictionary new					category: #capitals;					initials: 'cwp';					timeStamp: (MDTimestamp fromInteger: 886029518);					source: ('a', String cr, '	^ $A');					yourself.	chunk load: properties.	actual := self write: chunk.	expected := self methodAExpected.	self assert: actual = expected.! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassDefinitionWithoutStamp	| chunk properties actual expected |	chunk := self methodA.	properties := MDPropertyDictionary new					category: #capitals;					source: ('a', String cr, '	^ $A');					yourself.	chunk load: properties.	actual := self write: chunk.	expected := self methodAExpected2.	self assert: actual = expected.! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/26/2008 20:41'!testClassIsRemoved	| chunk actual class |	class := MDClassChunk forElement: (MDClassElement className: #BogusA).	class remove.	chunk := self methodA.	chunk remove.	chunk reactToClass: class.	actual := self write: chunk.	self assert: actual isEmpty! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClassRemoval	| chunk actual expected |	chunk := self methodA.	chunk remove.	actual := self write: chunk.	expected := self methodAExpected3.	self assert: actual = expected.! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:26'!testDefinitionWithBang	| chunk properties actual |	chunk := self methodOne.	properties := MDPropertyDictionary new					category: #numbers;					initials: 'cwp';					timeStamp: (MDTimestamp fromInteger: 886029518);					source: ('one', String cr, '	^ ''Sha!!bang''');					yourself.	chunk load: properties.	actual := self write: chunk.	self assert: (actual includesSubString: '!!!!')! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:26'!testDefinitionWithStamp	| chunk properties actual expected |	chunk := self methodOne.	properties := MDPropertyDictionary new					category: #numbers;					initials: 'cwp';					timeStamp: (MDTimestamp fromInteger: 886029518);					source: ('one', String cr, '	^ self');					yourself.	chunk load: properties.	actual := self write: chunk.	expected := self methodOneExpected.	self assert: actual = expected.! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDefinitionWithoutStamp	| chunk properties actual expected |	chunk := self methodOne.	properties := MDPropertyDictionary new					category: #numbers;					source: ('one', String cr, '	^ self');					yourself.	chunk load: properties.	actual := self write: chunk.	expected := self methodOneExpected2.	self assert: actual = expected.! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:26'!testInitializer	| chunk properties actual expected stream |	chunk := self methodInitialize.	properties := MDPropertyDictionary new		category: #capitals;		initials: 'cwp';		timeStamp: (MDTimestamp fromInteger: 886029518);		source: 'initialize';		yourself.	chunk load: properties.	stream := WriteStream on: String new.	chunk writeInitializerOn: stream.	actual := stream contents.	expected := self initializeExpected.	self assert: actual = expected! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/12/2008 20:26'!testInstanceInitializer	| chunk properties stream |	chunk := self methodInstanceInitialize.	properties := MDPropertyDictionary new		category: #capitals;		initials: 'cwp';		timeStamp: (MDTimestamp fromInteger: 886029518);		source: 'initialize';		yourself.	chunk load: properties.	stream := WriteStream on: String new.	chunk writeInitializerOn: stream.	self assert: stream contents isEmpty! !!MDMethodChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/26/2008 20:03'!testRemoval	| chunk actual expected |	chunk := self methodOne.	chunk remove.	actual := self write: chunk.	expected := self methodOneExpected3.	self assert: actual = expected.! !MDAdaptionTest subclass: #MDMonticelloAdaptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDMonticelloAdaptionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:03'!setUp	| registry |	registry := MDRegistry new.	registry register: (MDProject forTesting name: 'TestProject').	proxy := MDMonticelloDomain on: registry! !!MDMonticelloAdaptionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 13:00'!testParent	self tryAdapting: (MDParentElement 						forSlice: (MDExplicitSlice named: 'test')						inProject: MDProject forTesting)! !!MDMonticelloAdaptionTest methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 22:58'!testProject	self tryAdapting: (MDProjectElement id: 'TestProject')! !!MDMonticelloAdaptionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:49'!testRepository	self tryAdapting: (MDRepositoryElement 						forRepository: (MDMemoryRepository named: 'test')						inProject: MDProject forTesting)! !!MDMonticelloAdaptionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:22'!testSlice	self tryAdapting: (MDSliceElement 						forSlice: (MDExplicitSlice named: 'test')						inProject: MDProject forTesting)! !!MDMonticelloAdaptionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 00:00'!shouldInheritSelectors 	^ false! !MDAdaptorTest subclass: #MDMonticelloAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!(MDMonticelloAdaptorTest instVarNames includes: 'registry') ifFalse:	[MDMonticelloAdaptorTest addInstVarName: 'registry']!!MDMonticelloAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/27/2008 22:21'!adaptor	^ self adaptorClass on: self element inRegistry: registry! !!MDMonticelloAdaptorTest methodsFor: 'constructing' stamp: 'cwp 6/1/2008 11:29'!adaptorForElement: anElement	^ self adaptorClass on: anElement inRegistry: registry! !!MDMonticelloAdaptorTest methodsFor: 'running' stamp: 'cwp 6/1/2008 21:15'!editDuring: aBlock	^ aBlock value! !!MDMonticelloAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 22:13'!project	^ registry objectWithId: self projectId! !!MDMonticelloAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:55'!projectId	^ MDHashstamp fromString: '+++++6tCHw7ghiWz05AunY6i-a4LPqBg'! !!MDMonticelloAdaptorTest methodsFor: 'running' stamp: 'cwp 8/3/2008 23:03'!runCase	MDAnnouncer isolate: [super runCase]! !!MDMonticelloAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:21'!setUp	super setUp.	registry := MDRegistry new.! !!MDMonticelloAdaptorTest class methodsFor: 'as yet unclassified' stamp: 'cwp 5/29/2008 07:38'!isAbstract	^ self name = #MDMonticelloAdaptorTest! !MDAdaptionTest subclass: #MDMonticelloDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Tests'!!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/19/2008 18:49'!adaptorSelectors	^ #(text selection accept:notifying:)! !!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/19/2008 18:49'!setUp	proxy := MDVariantDefinition! !!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/24/2008 07:12'!testParent	self tryAdapting: (MDParentElement 						projectId: MDHashstamp new 						sliceId: MDHashstamp new)! !!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/24/2008 07:11'!testProject	self tryAdapting: (MDProjectElement id: MDHashstamp new)! !!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/24/2008 07:05'!testRepository	self tryAdapting: (MDRepositoryElement 						projectId: MDHashstamp new 						repositoryId: MDHashstamp new)! !!MDMonticelloDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/19/2008 18:58'!testSlice	self tryAdapting: (MDSliceElement 						projectId: MDHashstamp new 						sliceId: MDHashstamp new)! !!MDMonticelloDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 7/19/2008 18:52'!shouldInheritSelectors	^ false! !MDDomain subclass: #MDMonticelloDomain	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!(MDMonticelloDomain instVarNames includes: 'registry') ifFalse:	[MDMonticelloDomain addInstVarName: 'registry']!!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 13:01'!adaptorForParentElement: anElement	^ MDParentAdaptor on: anElement inRegistry: registry! !!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 3/5/2008 22:04'!adaptorForProjectElement: anElement	^ MDProjectAdaptor on: anElement inRegistry: registry! !!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:54'!adaptorForRepositoryElement: anElement	^ MDRepositoryAdaptor on: anElement inRegistry: registry! !!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:19'!adaptorForSliceElement: anElement	^ MDSliceAdaptor on: anElement inRegistry: registry! !!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 5/26/2008 22:04'!name	^ #monticello! !!MDMonticelloDomain methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 00:10'!setRegistry: aRegistry	registry := aRegistry! !(MDMonticelloDomain class instVarNames includes: 'default') ifFalse:	[MDMonticelloDomain class addInstVarName: 'default']!!MDMonticelloDomain class methodsFor: 'as yet unclassified' stamp: 'cwp 6/15/2008 20:42'!default	^ default ifNil: [default := self on: MDProject registry]! !!MDMonticelloDomain class methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 00:09'!on: aRegistry	^ self new setRegistry: aRegistry! !!MDMonticelloDomain class methodsFor: 'as yet unclassified' stamp: 'cwp 6/15/2008 20:41'!type	^ #monticello! !MDImageElement subclass: #MDMonticelloElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!!MDMonticelloElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/26/2008 21:50'!domain	^ #monticello! !MDSliceTest subclass: #MDMonticelloSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!(MDMonticelloSliceTest instVarNames includes: 'project') ifFalse:	[MDMonticelloSliceTest addInstVarName: 'project']!!MDMonticelloSliceTest methodsFor: 'asserting' stamp: 'cwp 11/10/2008 06:11'!assertIncludesRepositoryNamed: repositoryName 	| element theRepository |	theRepository := project repositories detect: [ :ea | ea name = repositoryName ].	element := MDRepositoryElement 		projectId: project id		repositoryId: theRepository id.	self assert: (slice elements includes: element).	self assert: (slice includes: element)! !!MDMonticelloSliceTest methodsFor: 'asserting' stamp: 'cwp 11/10/2008 06:11'!assertIncludesSliceNamed: sliceName 	| element theSlice |	theSlice := project slices detect: [ :ea | ea name = sliceName ].	element := MDSliceElement 		projectId: project id		sliceId: theSlice id.	self assert: (slice elements includes: element).	self assert: (slice includes: element)! !!MDMonticelloSliceTest methodsFor: 'asserting' stamp: 'cwp 11/10/2008 06:11'!denyIncludesRepositoryNamed: repositoryName 	| element theRepository |	theRepository := project repositories detect: [ :ea | ea name = repositoryName ].	element := MDRepositoryElement 		projectId: project id		repositoryId: theRepository id.	self deny: (slice elements includes: element).	self deny: (slice includes: element)! !!MDMonticelloSliceTest methodsFor: 'asserting' stamp: 'cwp 11/10/2008 06:11'!denyIncludesSliceNamed: sliceName 	| element theSlice |	theSlice := project slices detect: [ :ea | ea name = sliceName ].	element := MDSliceElement 		projectId: project id		sliceId: theSlice id.	self deny: (slice elements includes: element).	self deny: (slice includes: element)! !!MDMonticelloSliceTest methodsFor: 'running' stamp: 'cwp 11/10/2008 06:18'!setUp	project := MDProject forTesting.	project addSlice: (MDExplicitSlice named: 'FirstSlice').	project addSlice: (MDExplicitSlice named: 'SecondSlice').	project addRepository: (MDMemoryRepository named: 'FirstRepository').	project addRepository: (MDMemoryRepository named: 'SecondRepository').	project register.	slice := self createSlice! !!MDMonticelloSliceTest methodsFor: 'running' stamp: 'cwp 11/10/2008 06:12'!tearDown	MDProject registry unregister: project! !!MDMonticelloSliceTest class methodsFor: 'as yet unclassified' stamp: 'cwp 11/11/2008 19:35'!isAbstract	^ self name = #MDMonticelloSliceTest! !MDTestCase subclass: #MDNetClientTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDNetClientTest instVarNames includes: 'link') ifFalse:	[MDNetClientTest addInstVarName: 'link']!(MDNetClientTest instVarNames includes: 'repository') ifFalse:	[MDNetClientTest addInstVarName: 'repository']!!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setUp	link := MDMockLink new.	repository := MDNetRepository link: link! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 14:15'!testClose	link		open;		expect: (MDGoodbye new);		inject: (MDGoodbye new).	repository close.	self deny: link isOpen! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 20:51'!testCloseProtocolError		link		open;		expect: (MDGoodbye new);		inject: (MDHello new).		self		should: [repository close]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 14:20'!testDescription	self assert: repository description = 'Mock'! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGet	| version result |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: {version}).	result := repository get: version hashstamp.	self assert: result = version.! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetAll	| version result |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: {version}).	result := repository getAll: {version hashstamp}.	self assert: result anyOne = version.! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetAllNotFound	| version result |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: #()).	result := repository getAll: {version hashstamp}.	self assert: result isEmpty! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetAllProtocolError	| version |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDGoodbye new).		self		should: [repository getAll: {version hashstamp}]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetNotFound	| version result |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: #()).	result := repository get: version hashstamp.	self assert: result isNil! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetProtocolError		| hashstamp |	hashstamp := self version hashstamp.	link		open;		expect: (MDGetObjects with: {hashstamp});		inject: (MDGoodbye new).		self		should: [repository get: hashstamp]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetSome	| a b result |	a := self versionWith: #a.	b := self versionWith: #b.	link		open;		expect: (MDGetObjects with: {a hashstamp. b hashstamp});		inject: (MDObjects with: {a}).	result := repository getAll: {a hashstamp. b hashstamp}.	self assert: result size = 1.	self assert: result anyOne = a! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testHashstamps	| memo result |	memo := self memo.	link		open;		expect: (MDGetHashstamps new);		inject: (MDAllHashstamps with: {memo}).	result := repository allHashstamps.	self assert: result size = 1.	self assert: result anyOne = memo! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 20:52'!testHelloProtocolError		link		expect: (MDHello new);		inject: (MDGoodbye new).		self		should: [repository memos]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testImplicitOpen	| version |	version := self version.	link		expect: MDHello new;		inject: MDHello new;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: {version}).	repository get: version hashstamp.! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testImplicitReopen	| version |	version := self version.	link		open;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: {version}).	repository get: version hashstamp.	link 		close;		expect: MDHello new;		inject: MDHello new;		expect: (MDGetObjects with: {version hashstamp});		inject: (MDObjects with: {version}).	repository get: version hashstamp.! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testMemos	| memo result |	memo := self memo.	link		open;		expect: (MDGetMemos new);		inject: (MDMemos with: {memo}).	result := repository memos.	self assert: result size = 1.	self assert: result anyOne = memo! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 20:50'!testMemosProtocolError		link		open;		expect: (MDGetMemos new);		inject: (MDHello new).		self		should: [repository memos]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPut	| version |	version := self version.	link		open;		expect: (MDPutObjects with: {version});		inject: (MDThankYou with: 1).	repository put: version.	! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutAll	| version |	version := self version.	link		open;		expect: (MDOfferObjects with: {version hashstamp});		inject: (MDRequestObjects with: {version hashstamp});		expect: (MDPutObjects with: {version});		inject: (MDThankYou with: 1).	repository putAll: {version}.	! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutAllFailed	| version |	version := self version.	link		open;		expect: (MDOfferObjects with: {version hashstamp});		inject: (MDRequestObjects with: {version hashstamp});		expect: (MDPutObjects with: {version});		inject: (MDStorageFailed with: 'Just testing').	self 		should: [repository putAll: {version}]		raise: MDPeerError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutAllProtocolError1	| version |	version := self version.	link		open;		expect: (MDOfferObjects with: {version hashstamp});		inject: (MDThankYou new).	self		should: [repository putAll: {version}]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutAllProtocolError2	| version |	version := self version.	link		open;		expect: (MDOfferObjects with: {version hashstamp});		inject: (MDRequestObjects with: {version hashstamp});		expect: (MDPutObjects with: {version});		inject: (MDHello new).	self		should: [repository putAll: {version}]		raise: MDProtocolError	! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutFailed	| version |	version := self version.	link		open;		expect: (MDPutObjects with: {version});		inject: (MDStorageFailed with: 'Just testing').		self		should: [repository put: version]		raise: MDPeerError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutNone	| a b |	a := self versionWith: #a.	b := self versionWith: #b.	link		open;		expect: (MDOfferObjects with: {a hashstamp. b hashstamp});		inject: (MDRequestObjects with: #()).	repository putAll: {a. b}.	link		close		expect: (MDGoodbye new);		inject: (MDGoodbye new).	repository close! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutProtocolError	| version |	version := self version.	link		open;		expect: (MDPutObjects with: {self version});		inject: (MDHello new).		self 		should: [repository put: version]		raise: MDProtocolError! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutSome	| a b |	a := self versionWith: #a.	b := self versionWith: #b.	link		open;		expect: (MDOfferObjects with: {a hashstamp. b hashstamp});		inject: (MDRequestObjects with: {a hashstamp});		expect: (MDPutObjects with: {a});		inject: (MDThankYou with: 1).	repository putAll: {a. b}.	! !!MDNetClientTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testSelectFrom	| hashstamp result |	hashstamp := self version hashstamp.	link		open;		expect: (MDOfferObjects with: {hashstamp});		inject: (MDRequestObjects with: {hashstamp}).			result := repository selectFrom: {hashstamp} asSet.	self assert: result size = 1.	self assert: result anyOne = hashstamp! !MDTestCase subclass: #MDNetLinkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testClose	| link |	link := MDNetLink locator: (MDFakeLocator new).	link open.	link locator mocket 		execute: [link close];		expectClose;		done.! !!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testDescription	| link |	link := MDNetLink locator: (MDFakeLocator new).	self assert: link description = 'Fake'! !!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testOpen	| link |	link := MDNetLink locator: (MDFakeLocator new).	link open.	self assert: link isOpen.	self assert: link locator mocket isConnected.! !!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testSend	| link mocket msg |	link := MDNetLink locator: (MDFakeLocator new).	mocket := link locator mocket.	msg := MDHello with: 'test'.	mocket		execute: [link open; send: msg];		expect: msg bytes;		done! !!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testSendBeforeOpen	| link msg |	link := MDNetLink locator: (MDFakeLocator new).	msg := MDHello with: 'test'.	self 		should: [link send: msg]		raise: Error! !!MDNetLinkTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testSendResponse	| link mocket msg result |	link := MDNetLink locator: (MDFakeLocator new).	mocket := link locator mocket.	msg := MDHello with: 'test'.	mocket		execute: 			[link open.			result := link send: msg.			self assert: result class = MDHello];		expect: msg bytes;		inject: msg bytes! !MDRepositoryTest subclass: #MDNetRepositoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDNetRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 1/8/2008 18:00'!newRepository	^ MDFakeLink repositoryForTesting ! !!MDNetRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 01:26'!testLoad	| properties |	properties := MDPropertyDictionary new		host: 'example.com';		port: 7902;		yourself.	repository properties: properties.	self assert: repository locator host = 'example.com'.	self assert: repository locator port = 7902.! !!MDNetRepositoryTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 01:13'!testProperties	| properties |	properties := repository properties.	self assert: properties type = #Mnrp.	self assert: properties host = 'fakehost.com'.	self assert: properties port = 7901.! !MDTestCase subclass: #MDNetSerializationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDNetSerializationTest methodsFor: 'asserting' stamp: 'cwp 5/22/2008 00:11'!assertEqualityOf: anObject	| bytes other |	bytes := anObject bytes.	other := MDNetMessage fromBytes: bytes.	self assert: anObject = other! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:30'!testAuthenticationFailed	self assertEqualityOf: (MDAuthenticationFailed with: 'Unknown user')! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/8/2008 18:38'!testGetHashstamps	self assertEqualityOf: MDGetHashstamps new! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/3/2008 23:32'!testGetMemos	self assertEqualityOf: MDGetMemos new! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/3/2008 23:25'!testGetObjects	self assertEqualityOf: (MDGetObjects with: (Set with: self version hashstamp))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:40'!testGoodbye	self assertEqualityOf: (MDGoodbye with: 'colin@wiresong.ca')! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/8/2008 18:17'!testHashstamps	self assertEqualityOf: (MDAllHashstamps with: (Set with: self version hashstamp))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:37'!testHello	self assertEqualityOf: (MDHello with: 'colin@wiresong.ca')! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:11'!testIdConflict	| messages others |	messages := MDNetMessage allSubclasses select: [:ea | ea isConcrete].	messages do:		[:msg |		others := messages copyWithout: msg.		others do: [:other | self deny: msg id = other id]]! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:09'!testMemos	self assertEqualityOf: (MDMemos with: (Set with: self memo))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:34'!testObjectNotFound	self assertEqualityOf: (MDStorageFailed with: 'Disk full')! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:08'!testObjects	self assertEqualityOf: (MDObjects with: (Set with: self version))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:23'!testOfferObjects	self assertEqualityOf: (MDOfferObjects with: (Set with: self version hashstamp))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:07'!testPutObjects	self assertEqualityOf: (MDPutObjects with: (Set with: self version))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:23'!testRequestObjects	self assertEqualityOf: (MDRequestObjects with: (Set with: self version hashstamp))! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/3/2008 23:53'!testThankYou	self assertEqualityOf: (MDThankYou with: 4)! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:31'!testUnauthorized	self assertEqualityOf: (MDUnauthorized with: 'That version is private')! !!MDNetSerializationTest methodsFor: 'tests' stamp: 'cwp 1/4/2008 00:26'!testUnrecognizedMessage	self assertEqualityOf: (MDUnrecognizedMessage with: 'Message id 555 not implemented')! !MDTestCase subclass: #MDNetServiceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDNetServiceTest instVarNames includes: 'service') ifFalse:	[MDNetServiceTest addInstVarName: 'service']!(MDNetServiceTest instVarNames includes: 'repository') ifFalse:	[MDNetServiceTest addInstVarName: 'repository']!!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setUp	repository := MDMemoryRepository new.	service := MDNetService for: repository.! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetMemos	| memo result |	memo := self memo.	repository put: memo.	result := service handleMessage: (MDGetMemos new).	self assert: result isMemos.	self assert: (result objects includes: memo)! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetNotFound	| a b result |	a := self versionWith: #a.	b := self versionWith: #b.	repository put: b.	result := service handleMessage: (MDGetObjects with: {a hashstamp. b hashstamp}).	self assert: result isObjects.	self assert: result objects size = 1.	self assert: result objects anyOne = b.! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetObjects	| version result |	version := self version.	repository put: version.	result := service handleMessage: (MDGetObjects with: {version hashstamp}).	self assert: result isObjects.	self assert: (result objects includes: version)! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGetPartial	| version result |	version := self version.	result := service handleMessage: (MDGetObjects with: {version hashstamp}).	self assert: result isObjects.	self assert: result objects isEmpty! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testGoodbye	| result |	result := service handleMessage: MDGoodbye new.	self assert: result isGoodbye! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testHello		| result |	result := service handleMessage: MDHello new.	self assert: result isHello.! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testOfferObjects	| result a b |	a := self versionWith: #a.	b := self versionWith: #b.	repository put: a.	result := service handleMessage: (MDOfferObjects with: {a hashstamp. b hashstamp}).	self assert: result isRequestObjects.	self assert: result hashstamps size = 1.	self assert: result hashstamps anyOne = b hashstamp.! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testOfferObjectsUnneeded	| result version |	version := self version.	repository put: version.	result := service handleMessage: (MDOfferObjects with: {version hashstamp}).	self assert: result isRequestObjects.	self assert: result hashstamps isEmpty! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutObjects	| version result |	version := self version.	result := service handleMessage: (MDPutObjects with: {version}).	self assert: result isThankYou.	self assert: (repository get: version hashstamp) = version! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testPutObjectsFailed	| version result |	version := self version.	service instVarNamed: 'repository' put: nil.	result := service handleMessage: (MDPutObjects with: {version}).	self assert: result class = MDStorageFailed.	self assert: result description = 'MessageNotUnderstood: UndefinedObject>>putAll:'! !!MDNetServiceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!testServerError	| version result |	version := self version.	service instVarNamed: 'repository' put: nil.	result := service handleMessage: (MDGetObjects with: {version hashstamp}).	self assert: result class = MDProcessingError.	self assert: result description = 'MessageNotUnderstood: UndefinedObject>>getAll:'! !MDChunk subclass: #MDNullChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDNullChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:39'!sortKey	^ ''! !!MDNullChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 00:10'!writeOn: aStream! !MDDefinition subclass: #MDNullDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDNullDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 21:40'!callback: aBlock! !!MDNullDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/16/2007 23:33'!text	^ '-- null --'! !MDNetMessage subclass: #MDObjectsMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDObjectsMessage instVarNames includes: 'objects') ifFalse:	[MDObjectsMessage addInstVarName: 'objects']!!MDObjectsMessage methodsFor: 'comparing' stamp: 'cwp 1/3/2008 23:17'!= other	^ self species = other species		and: [objects = other objects]! !!MDObjectsMessage methodsFor: 'comparing' stamp: 'cwp 1/3/2008 23:17'!hash	^ objects hash! !!MDObjectsMessage methodsFor: 'accessing' stamp: 'cwp 1/3/2008 23:17'!objects	^ objects! !!MDObjectsMessage methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:11'!setContents: aCollection	objects := aCollection asSet! !!MDObjectsMessage methodsFor: 'writing' stamp: 'cwp 1/3/2008 23:08'!writeContentsOn: aStream	MDMarshal serialize: objects on: aStream! !!MDObjectsMessage class methodsFor: 'as yet unclassified' stamp: 'cwp 1/3/2008 23:14'!readContentsFrom: aStream	^ self with: (MDMarshal materializeFrom: aStream)! !MDSliceTest subclass: #MDParentsSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!(MDParentsSliceTest instVarNames includes: 'project') ifFalse:	[MDParentsSliceTest addInstVarName: 'project']!!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 06:54'!setUp	project := MDProject forTesting. 	project addSlice: (MDExplicitSlice named: 'FirstSlice').	project addSlice: (MDExplicitSlice named: 'SecondSlice').	project addRepository: (MDMemoryRepository named: 'FirstRepository').	project addRepository: (MDMemoryRepository named: 'SecondRepository').	slice := MDParentsSlice on: project.! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:01'!testElements	| expected |	expected := project slices asSet collect: [:ea | MDParentElement projectId: project id sliceId: ea id].	elements := slice elements.	self assert: expected = elements.	! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:07'!testElementsWrongProject	| element |	element := MDParentElement projectId: MDHashstamp new sliceId: project slices anyOne id.	self deny: (slice elements includes: element)! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:07'!testElementsWrongSlice	| element |	element := MDParentElement projectId: project id sliceId: MDHashstamp new.	self deny: (slice elements includes: element)! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:02'!testIncludes	elements := project slices asSet collect: [:ea | MDParentElement projectId: project id sliceId: ea id].	elements do: [:ea | self assert: (slice includes: ea)]! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:05'!testWrongProject	| element |	element := MDParentElement projectId: MDHashstamp new sliceId: project slices anyOne id.	self deny: (slice includes: element)! !!MDParentsSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:05'!testWrongSlice	| element |	element := MDParentElement projectId: project id sliceId: MDHashstamp new.	self deny: (slice includes: element)! !MDNetError subclass: #MDPeerError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!MDVersionedObject subclass: #MDProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Project'!(MDProject instVarNames includes: 'name') ifFalse:	[MDProject addInstVarName: 'name']!(MDProject instVarNames includes: 'workspace') ifFalse:	[MDProject addInstVarName: 'workspace']!(MDProject instVarNames includes: 'slices') ifFalse:	[MDProject addInstVarName: 'slices']!(MDProject instVarNames includes: 'store') ifFalse:	[MDProject addInstVarName: 'store']!(MDProject instVarNames includes: 'historians') ifFalse:	[MDProject addInstVarName: 'historians']!(MDProject classVarNames includes: 'MDProjectRegistry') ifFalse:	[MDProject addClassVarName: 'MDProjectRegistry']!!MDProject methodsFor: 'actions' stamp: 'cwp 7/28/2008 21:05'!addRepository: aRepository	| element |	store addRepository: aRepository.	element := MDRepositoryElement projectId: self id repositoryId: aRepository id.	MDAnnouncer announce: (MDElementAdded for: element).! !!MDProject methodsFor: 'actions' stamp: 'cwp 7/28/2008 20:57'!addSlice: aSlice	| element |	slices register: aSlice.	historians at: aSlice id put: (MDHistorian forSlice: aSlice).		element := MDSliceElement projectId: self id sliceId: aSlice id.	MDAnnouncer announce: (MDElementAdded for: element).! !!MDProject methodsFor: 'accessing' stamp: 'cwp 6/14/2008 22:48'!allElementsForSlice: aSlice do: aBlock	| elements parents snapshot elem memo |	elements := aSlice elements.	elements do: aBlock.	parents := (self historianForSliceId: aSlice id ifAbsent: [^ self]) parents.	parents isEmpty ifTrue: [^ self].	memo := (store get: parents first) ifNil: [^ self].	snapshot := (store get: memo reference) ifNil: [^ self].	(snapshot getVersionsFrom: store) do:		[:version |		elem := version element.		(elements includes: elem) ifFalse: [aBlock value: elem]]! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/29/2008 07:19'!annElementChanged: announcement	self noteElementChanged: announcement element! !!MDProject methodsFor: 'accessing' stamp: 'cwp 8/3/2008 21:14'!changesForSlice: aSlice	| result parents memo snapshot |	result := Set new.	parents := (self historianForSliceId: aSlice id ifAbsent: [^ self]) parents.	parents isEmpty ifTrue: [^ result].	memo := (store get: parents first) ifNil: [^ result].	snapshot := (store get: memo reference) ifNil: [^ result].	(aSlice expandVersions: (snapshot getVersionsFrom: store)) do:		[:version |		workspace changeFromVersion: version do: [:change | result add: change]].	^ result! !!MDProject methodsFor: 'accessing' stamp: 'cwp 3/8/2008 13:03'!historianForSliceId: aHashstamp	^ historians at: aHashstamp! !!MDProject methodsFor: 'accessing' stamp: 'cwp 6/13/2008 21:18'!historianForSliceId: aHashstamp ifAbsent: aBlock	^ historians at: aHashstamp ifAbsent: aBlock! !!MDProject methodsFor: 'actions' stamp: 'cwp 5/22/2008 00:10'!include: aMemo	| slice snapshot |	slice := slices objectWithId: aMemo sliceId.	snapshot := store get: aMemo reference.	[slice include: snapshot from: store in: workspace]		on: MDMergeRequest		do: [:req | MDConflictBrowser handleRequest: req].	(self historianForSliceId: aMemo sliceId) noteInclude: aMemo! !!MDProject methodsFor: 'initialize-release' stamp: 'cwp 5/27/2008 20:42'!initialize	workspace := MDWorkingCopy new.	slices := MDRegistry new.	store := MDStore new.	historians := Dictionary new.! !!MDProject methodsFor: 'notifications' stamp: 'cwp 6/13/2008 21:29'!isDirty: aSlice	^ (self historianForSliceId: aSlice id ifAbsent: [^ false]) isDirty! !!MDProject methodsFor: 'actions' stamp: 'cwp 8/3/2008 21:47'!load: aMemo	| slice snapshot |	slice := (slices objectWithId: aMemo sliceId) ifNil:		[MDExplicitSlice named: 'temporary'].	snapshot := store get: aMemo reference.	slice load: snapshot from: store to: workspace.	(self historianForSliceId: aMemo sliceId ifAbsent: [^ self]) 		noteLoad: aMemo! !!MDProject methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:34'!name	^ name ! !!MDProject methodsFor: 'accessing' stamp: 'cwp 7/28/2008 22:26'!name: aString	| element |	name := aString.		element := MDProjectElement for: self.	MDAnnouncer announce: (MDElementModified for: element)! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/30/2008 18:48'!noteClean: aSlice 	^ (self historianForSliceId: aSlice id) markClean! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/30/2008 18:46'!noteDirty: aSlice	^ (self historianForSliceId: aSlice id) markDirty! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/29/2008 07:18'!noteElementChanged: anElement	historians do: [:ea | ea noteElementChanged: anElement]! !!MDProject methodsFor: 'registry' stamp: 'cwp 10/2/2008 20:16'!register	MDProjectRegistry register: self! !!MDProject methodsFor: 'actions' stamp: 'cwp 7/28/2008 21:11'!removeRepository: aRepository	| element |	store removeRepository: aRepository.		element := MDRepositoryElement projectId: self id repositoryId: aRepository id.	MDAnnouncer announce: (MDElementRemoved for: element)! !!MDProject methodsFor: 'actions' stamp: 'cwp 7/28/2008 21:03'!removeSlice: aSlice	| element |	slices unregister: aSlice.	historians removeKey: aSlice id ifAbsent: [].		element := MDSliceElement projectId: self id sliceId: aSlice id.	MDAnnouncer announce: (MDElementRemoved for: element).! !!MDProject methodsFor: 'accessing' stamp: 'cwp 11/11/2007 21:48'!repositories	^ store repositories! !!MDProject methodsFor: 'actions' stamp: 'cwp 5/22/2008 00:10'!save: aSlice	| memo historian |	historian := self historianForSliceId: aSlice id.	memo := historian memo.	^ memo ifNotNil:		[aSlice saveFrom: workspace to: store memo: memo.		historian noteSave: memo.		memo]! !!MDProject methodsFor: 'initialize-release' stamp: 'cwp 5/31/2008 14:33'!setName: aString	name := aString.	self initId! !!MDProject methodsFor: 'accessing' stamp: 'cwp 11/10/2007 00:57'!slices	^ slices objects! !!MDProject methodsFor: 'accessing' stamp: 'cwp 11/10/2007 00:55'!store	^ store! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/28/2008 07:32'!subscribe	MDAnnouncer default 		observe: MDElementChange		send: #annElementChanged:		to: self! !!MDProject methodsFor: 'accessing' stamp: 'cwp 8/3/2008 20:51'!unsavedChangesForSlice: aSlice	| result |	result := Set new.	self allElementsForSlice: aSlice do:		[:element |		workspace 			changeForElement: element 			do: [:change | result add: change]].	^ result! !!MDProject methodsFor: 'notifications' stamp: 'cwp 7/28/2008 07:31'!unsubscribe	MDAnnouncer default unsubscribe: self! !!MDProject methodsFor: 'accessing' stamp: 'cwp 11/10/2007 00:55'!workspace	^ workspace! !!MDProject class methodsFor: 'instance creation' stamp: 'cwp 5/31/2008 14:32'!forDomain: aDomain 	| inst |	inst := self named: aDomain name.	inst workspace 		domainAt: aDomain name		put: aDomain.	^ inst! !!MDProject class methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 06:58'!forTesting	^ self forDomain: MDFakeDomain new! !!MDProject class methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:16'!initialize	MDProjectRegistry := MDRegistry new! !!MDProject class methodsFor: 'instance creation' stamp: 'cwp 5/27/2008 20:49'!named: aString	^ self new setName: aString! !!MDProject class methodsFor: 'accessing' stamp: 'cwp 10/2/2008 20:16'!registry	^ MDProjectRegistry! !!MDProject class methodsFor: 'accessing' stamp: 'cwp 6/17/2008 00:20'!type	^ #Project! !MDMonticelloAdaptor subclass: #MDProjectAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:33'!createProject	^ MDProject id: element id! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:43'!isLoadable: properties	"Always loadable"		^ true! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:44'!isPresent	^ registry includesId: element id! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:52'!isUpToDate: properties	^ self project name = properties name! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 23:00'!load: properties	| project |	(registry includesId: element id)		ifTrue: [self project name: properties name]		ifFalse: 			[project := self createProject.			project name: properties name.			registry register: project.			project subscribe]! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:50'!project	^ registry objectWithId: element id! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 23:13'!remove	| project |	project := self project.	project ifNotNil: [project unsubscribe].	registry unregisterId: element id.! !!MDProjectAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 21:55'!update: properties	properties name: self project name! !MDMonticelloAdaptor subclass: #MDProjectPartElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!!MDProjectPartElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:43'!isLoadable: properties	^ registry includesId: element projectId! !!MDProjectPartElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:40'!project	^ registry objectWithId: element projectId! !MDDefinition subclass: #MDPropertiesDefintion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!(MDPropertiesDefintion instVarNames includes: 'object') ifFalse:	[MDPropertiesDefintion addInstVarName: 'object']!!MDPropertiesDefintion methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 14:46'!printPropertiesOn: aStream	self propertiesDo: 		[:key :value |		aStream 			nextPutAll: key asString;			nextPut: $:;			space;			print: value;			cr].! !!MDPropertiesDefintion methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 15:31'!properties	^ object properties! !!MDPropertiesDefintion methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!propertiesDo: aBlock	| dict |	self timestamp ifNotNilDo: [:ts | aBlock value: #timestamp value: ts].	dict := self properties.	dict keys asSortedArray do: [:key | aBlock value: key value: (dict at: key)]! !!MDPropertiesDefintion methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!setObject: anObject	object := anObject! !!MDPropertiesDefintion methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 14:46'!text	^ String streamContents: [:stream | self printPropertiesOn: stream]			! !!MDPropertiesDefintion methodsFor: 'accessing' stamp: 'cwp 12/31/2007 15:34'!timestamp	^ object timestamp! !!MDPropertiesDefintion class methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 15:03'!on: anObject	^ self new setObject: anObject! !MDNetError subclass: #MDProtocolError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!MDTestCase subclass: #MDProxyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDProxyTest instVarNames includes: 'proxy') ifFalse:	[MDProxyTest addInstVarName: 'proxy']!!MDProxyTest methodsFor: 'asserting' stamp: 'cwp 3/25/2005 22:37'!assertElement: elem property: prop hasValue: value	self assert: (self atElement: (self element: elem) property: prop) = value! !!MDProxyTest methodsFor: 'asserting' stamp: 'cwp 3/25/2005 22:52'!assertElementHasDefaultValue: aSymbol	self assertElement: aSymbol property: #one hasValue: aSymbol asLowercase! !!MDProxyTest methodsFor: 'asserting' stamp: 'cwp 3/25/2005 22:46'!assertElementHasValue: value	self assert: (self atElement: self element property: #one) = value! !!MDProxyTest methodsFor: 'proxy access' stamp: 'cwp 2/27/2005 20:58'!atElement: element property: property	^ (proxy at: element) at: property ifAbsent: [nil]! !!MDProxyTest methodsFor: 'proxy access' stamp: 'cwp 2/4/2005 23:54'!atElement: element property: property put: value	"This will need to be overriden in tests that use a real image proxy."		(proxy at: element) at: property put: value! !!MDProxyTest methodsFor: 'proxy access' stamp: 'cwp 2/5/2005 20:16'!atProperty: aSymbol	^ self atElement: self element property: aSymbol! !!MDProxyTest methodsFor: 'proxy access' stamp: 'cwp 2/5/2005 20:17'!atProperty: aSymbol put: aValue	self atElement: self element property: aSymbol put: aValue! !!MDProxyTest methodsFor: 'configuration' stamp: 'cwp 5/26/2008 19:39'!proxyClass	^ MDFakeDomain! !!MDProxyTest methodsFor: 'running' stamp: 'cwp 5/22/2008 00:10'!setUp	proxy := self proxyClass new! !!MDProxyTest class methodsFor: 'testing' stamp: 'abc 2/13/2005 12:37'!isAbstract	^ self name = #MDProxyTest! !MDVersionPanel subclass: #MDRemotePanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Panels'!!MDRemotePanel methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 22:49'!variant	^ node remoteVariant! !MDVariant subclass: #MDRemovalVariant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDRemovalVariant commentStamp: 'dc 6/14/2007 06:27' prior: 0!A variant describes the state of a particular element. That state is "not present in the image," in the case of this class.!!MDRemovalVariant methodsFor: 'conflicts' stamp: 'cwp 10/16/2005 14:47'!autoMergeWith: aVariant in: anImageProxy 	^aVariant autoMergeWithRemoval: self in: anImageProxy! !!MDRemovalVariant methodsFor: 'conflicts' stamp: 'avi 3/16/2005 12:16'!autoMergeWithDefinition: anElementDefinition in: anImageProxy	^ anElementDefinition autoMergeWithRemoval: self in: anImageProxy! !!MDRemovalVariant methodsFor: '*mc2-squeakui' stamp: 'cwp 12/16/2007 23:32'!definition	^ MDNullDefinition new! !!MDRemovalVariant methodsFor: 'image proxy' stamp: 'cwp 5/24/2005 07:44'!displayFor: anImageProxy	^ '-- removed --'! !!MDRemovalVariant methodsFor: 'image proxy' stamp: 'cwp 2/13/2005 19:52'!isLoadableInto: anImageProxy	"Removals are always loadable."		^ true! !!MDRemovalVariant methodsFor: 'testing' stamp: 'avi 12/2/2004 01:51'!isRemoval	^ true! !!MDRemovalVariant methodsFor: 'testing' stamp: 'avi 12/2/2004 01:56'!isUpToDateFor: anImageProxy	^ (anImageProxy hasElement: element) not! !!MDRemovalVariant methodsFor: 'image proxy' stamp: 'avi 12/2/2004 01:27'!loadInto: anImageProxy	element removeFrom: anImageProxy! !!MDRemovalVariant methodsFor: 'image proxy' stamp: 'cwp 10/16/2005 13:44'!updateFrom: anImageProxy	^ (MDDefinitionVariant forElement: element) updateFrom: anImageProxy! !MDVersionedObject subclass: #MDRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Repositories'!!MDRepository commentStamp: 'dc 6/14/2007 06:45' prior: 0!Repositories are similar to those in MC1, but have a different protocol and different performance characteristics. Conceptually, repositories are dictionaries, mapping hashstamps to versions or snapshots. This makes for a very fine-grained protocol - versions are loaded individually. That makes directory or HTTP repositories impractical, since loading a slice for a medium-size package would involve opening and reading hundreds of files. (A snapshot of OB, for example runs at over 600 versions).!!MDRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:45'!allHashstamps	self subclassResponsibility ! !!MDRepository methodsFor: 'public' stamp: 'cwp 12/29/2006 18:02'!close! !!MDRepository methodsFor: 'public' stamp: 'cwp 5/31/2008 14:41'!description	^ self name! !!MDRepository methodsFor: 'public' stamp: 'dc 6/14/2007 07:17'!get: aHashstamp 	self subclassResponsibility ! !!MDRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:10'!getAll: aSet	| result |	result := Set new.	aSet do: [:hashstamp | (self get: hashstamp) ifNotNilDo: [:obj | result add: obj]].	^ result! !!MDRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:48'!includes: aHashstamp	self subclassResponsibility! !!MDRepository methodsFor: 'public' stamp: 'dc 6/14/2007 07:17'!memos	self subclassResponsibility ! !!MDRepository methodsFor: 'synchronization' stamp: 'cwp 5/22/2008 00:10'!pushTo: aRepository	| wanted |	wanted := aRepository selectFrom: self allHashstamps.	aRepository putAll: (wanted collect: [:ea | self get: ea])! !!MDRepository methodsFor: 'public' stamp: 'dc 6/14/2007 07:17'!put: aHashedObject	self subclassResponsibility ! !!MDRepository methodsFor: 'public' stamp: 'cwp 12/22/2007 22:26'!putAll: aSet	aSet do: [:ea | self put: ea]! !!MDRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:49'!selectFrom: aSet	^ aSet reject: [:ea | self includes: ea]! !!MDRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:53'!synchronizeWith: aRepository	self pushTo: aRepository.	aRepository pushTo: self! !MDNetMessage subclass: #MDSalutationMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDSalutationMessage instVarNames includes: 'description') ifFalse:	[MDSalutationMessage addInstVarName: 'description']!!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:39'!= other	^ self species = other species and: [self description = other description]! !!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:32'!defaultDescription	^ NetNameResolver localHostName! !!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:30'!description	^ description ifNil: [self defaultDescription]! !!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:39'!hash	^ description hash! !!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!setContents: aString	description := aString! !!MDSalutationMessage methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:29'!writeContentsOn: aStream	MDMarshal serialize: self description on: aStream! !MDTestCase subclass: #MDSerializationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSerializationTest methodsFor: 'asserting' stamp: 'cwp 3/4/2005 17:39'!assertEqualityOf: anObject	^ self assertEqualityOf: anObject using: [:before :after | self assert: after = before]! !!MDSerializationTest methodsFor: 'asserting' stamp: 'cwp 3/8/2005 00:22'!assertEqualityOf: anObject using: aBlock 	| other buffer |	buffer := MDMarshal serialize: anObject.	other := MDMarshal materialize: buffer.	aBlock value: anObject value: other! !!MDSerializationTest methodsFor: 'asserting' stamp: 'cwp 3/2/2008 11:04'!assertIdentityOf: anObject	^ self assertEqualityOf: anObject using: [:before :after | self assert: after == before]! !!MDSerializationTest methodsFor: 'running' stamp: 'cwp 4/8/2008 20:10'!setUp	super setUp.	MDMarshal resetMap! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:13'!testArray	self assertEqualityOf: #(1 2 3)! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 14:02'!testBytesObject	self assertEqualityOf: #(1 2 3) asByteArray! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:45'!testClass	self assertIdentityOf: self class! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:20'!testClassCommentElement	self assertEqualityOf: (MDClassCommentElement className: #MDBogusA)! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:20'!testClassElement	self assertEqualityOf: (MDClassElement className: #MDBogusA)! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:22'!testClassInstVarElement	self assertEqualityOf: (MDClassInstVarElement className: #MDBogusA name: 'beth')! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/9/2005 21:45'!testClassMethodElement	self assertEqualityOf: (MDMethodElement 							className: #MDBogusA 							selector: #one 							classIsMeta: true)! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:21'!testClassVarElement	self assertEqualityOf: (MDClassVarElement className: #MDBogusA name: 'Alpha')! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:29'!testDictionary	| dict |	dict := Dictionary new			at: #a put: 1;			at: #b put: 2;			yourself.	self assertEqualityOf: dict! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 17:21'!testElementDefinition	self assertEqualityOf: self definition! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 17:04'!testElementRemoval	self assertEqualityOf: self removal.! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 15:35'!testFakeElement	self assertEqualityOf: self element! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:04'!testFalse	self assertIdentityOf: false ! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/25/2005 20:41'!testHashstamp	self assertEqualityOf: (MDHashstamp hashIn: [:stream | stream nextPutAll: 'abc' asByteArray])! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:21'!testInstVarElement	self assertEqualityOf: (MDInstVarElement className: #MDBogusA name: 'one')! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 5/22/2008 00:10'!testLongString	| string |	string := String new: 300.	string atAllPut: $a.	self assertEqualityOf: string! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 1/19/2007 22:27'!testMemo	self assertEqualityOf: self memo ! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 3/7/2005 16:23'!testMethodElement	self assertEqualityOf: (MDMethodElement className: #MDBogusA selector: #one)! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 6/23/2008 13:22'!testMultiString	| ws |	ws := MDPlatform current wideString.	ws ifNotNil: [self assertEqualityOf: ws]! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 10:26'!testNegativeLargeInteger	self assertEqualityOf: SmallInteger minVal - 1! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 02:03'!testNegativeOneByteInteger	self assertEqualityOf: -3! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 10:20'!testNegativeTwoByteInteger	self assertEqualityOf: -300! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:05'!testNil	self assertIdentityOf: nil! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 16:27'!testOneByteInteger	self assertEqualityOf: 7! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 14:06'!testPointersObject	self assertEqualityOf: MDPlatform current variablePointersObject ! !!MDSerializationTest methodsFor: 'tests - smalltalk' stamp: 'cwp 4/28/2008 22:04'!testPoolImportElement	self assertEqualityOf: (MDPoolImportElement 			className: #MDBogusA			name: #MDBogusPoolA)! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 10:26'!testPositiveLargeInteger	self assertEqualityOf: SmallInteger maxVal + 1! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 5/22/2008 00:10'!testPropertyDictionary	| properties |	properties := MDPropertyDictionary new.	properties		first: 1;		second: 'two'.	self assertEqualityOf: properties! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:25'!testSet	self assertEqualityOf: #(1 2 3) asSet! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 5/24/2008 13:25'!testSliceElement	self assertEqualityOf: (MDSliceElement 							forSlice: (MDExplicitSlice named: 'TestSlice')							inProject: MDProject forTesting)! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/10/2005 23:41'!testSnapshot	self assertEqualityOf: self snapshot ! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/4/2005 17:22'!testString	self assertEqualityOf: 'abc'.! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 4/15/2008 21:40'!testStringWithAccent	self assertEqualityOf: 'bc'.! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 17:15'!testSymbol	self assertEqualityOf: #one using: [:before :after | self assert: before == after]! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 6/5/2008 22:29'!testThreeByteInteger	self assertEqualityOf: (2 raisedTo: 16) + 1! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 4/13/2008 23:28'!testTimestamp	| ts buffer |	ts := MDTimestamp now.	buffer := MDMarshal serialize: ts.	self assert: buffer size = 5.	self assert: (MDMarshal materialize: buffer) = ts! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/2/2008 11:04'!testTrue	self assertIdentityOf: true! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 3/7/2005 16:44'!testTwoByteInteger	self assertEqualityOf: 355! !!MDSerializationTest methodsFor: 'tests - core' stamp: 'cwp 10/16/2005 14:42'!testVersion	self 		assertEqualityOf: self version 		using: [:before :after |				self assert: before variant = after variant.				self assert: before hashstamp = after hashstamp.				self assert: before ancestry = after ancestry]! !MDVersionedObject subclass: #MDSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Slices'!!MDSlice commentStamp: 'dc 6/14/2007 07:32' prior: 0!A slice is sub-set of the elements in the image. It's main responsibility is to define which elements are part of the slice and which are not. Slices can be based on any set of criteria - PackageInfo, ChangeSets, an explicit collection, whatever. Slices can overlap. Elements can belong to more than one slice at the same time.!!MDSlice methodsFor: 'converting' stamp: 'cwp 3/14/2005 22:28'!asExplicitSlice	^ MDExplicitSlice basedOn: self! !!MDSlice methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!basicLoad: aSnapshot from: aRepository to: aWorkingCopy	| versions expanded |	versions := aSnapshot getVersionsFrom: aRepository for: aWorkingCopy.	expanded := self expandVersions: versions.	aWorkingCopy transaction: 		[expanded do: [:ea | aWorkingCopy loadVersion: ea]]! !!MDSlice methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!basicSaveFrom: aWorkingCopy to: aRepository memo: aMemo	| objects snapshot |	objects := Set new.		self do: [:ea | objects add: (aWorkingCopy versionForElement: ea)].	snapshot := MDSnapshot withVersions: objects.	objects add: snapshot.	aMemo ifNotNil: 		[aMemo setSnapshot: snapshot slice: self.		objects add: aMemo].	aRepository putAll: objects.	^ snapshot! !!MDSlice methodsFor: 'enumerating' stamp: 'cwp 5/7/2008 07:42'!do: aBlock	self elementsDo: aBlock! !!MDSlice methodsFor: 'accessing' stamp: 'dc 6/14/2007 07:41'!elements	| result |	result := Set new.	self do: [:ea | result add: ea].	^ result! !!MDSlice methodsFor: 'enumerating' stamp: 'cwp 1/19/2007 00:00'!elementsDo: aBlock! !!MDSlice methodsFor: 'private' stamp: 'dc 6/14/2007 07:44'!expandVersions: versions	| existingElements result |	existingElements := versions collect: [:ea | ea element]. 	result := versions copy.	self do: [:el | (existingElements includes: el) 					ifFalse: [result add: (MDNullVersion forElement: el)]].	^ result! !!MDSlice methodsFor: 'public' stamp: 'cwp 12/22/2007 23:31'!include: aSnapshot from: aRepository in: aWorkingCopy	| versions |	MDPlatform current 		withCursor: #read 		do: [versions := aSnapshot getVersionsFrom: aRepository for: aWorkingCopy].	MDMergeRequest		includeAll: (self expandVersions: versions)		in: aWorkingCopy! !!MDSlice methodsFor: 'testing' stamp: 'dc 8/3/2007 11:55'!includes: anElement	self subclassResponsibility ! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:51'!includesClass: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:51'!includesClassComment: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:51'!includesClassInstVar: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:52'!includesClassVar: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:52'!includesInstVar: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:52'!includesMethod: anElement	^ false! !!MDSlice methodsFor: '*mc2-monticello-dispatch' stamp: 'cwp 6/7/2008 15:26'!includesParentElement: anElement	^ false! !!MDSlice methodsFor: '*mc2-squeak-dispatch' stamp: 'cwp 6/7/2008 15:52'!includesPoolImport: anElement	^ false! !!MDSlice methodsFor: '*mc2-monticello-dispatch' stamp: 'cwp 6/7/2008 15:26'!includesProjectElement: anElement	^ false! !!MDSlice methodsFor: '*mc2-monticello-dispatch' stamp: 'cwp 6/7/2008 15:27'!includesRepositoryElement: anElement	^ false! !!MDSlice methodsFor: '*mc2-monticello-dispatch' stamp: 'cwp 6/7/2008 15:27'!includesSliceElement: anElement	^ false! !!MDSlice methodsFor: 'public' stamp: 'cwp 12/22/2007 22:03'!load: aSnapshot from: aRepository to: aWorkingCopy		MDPlatform current 		withCursor: #read 		do: [self basicLoad: aSnapshot from: aRepository to: aWorkingCopy]! !!MDSlice methodsFor: 'public' stamp: 'cwp 12/22/2007 22:20'!saveFrom: aWorkingCopy to: aRepository memo: aMemo	^ MDPlatform current 		withCursor: #write 		do: [self basicSaveFrom: aWorkingCopy to: aRepository memo: aMemo].	! !!MDSlice methodsFor: 'private' stamp: 'cwp 11/16/2007 00:55'!withCursor: aSymbol do: aBlock	MDPlatform current showCursor: aSymbol.	aBlock ensure: [MDPlatform current showCursor: nil]! !MDDefinitionTest subclass: #MDSliceDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Tests'!!MDSliceDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:28'!expectedText	^ 'elements: a Set()name: ''TestSlice''type: #Explicit'! !!MDSliceDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:28'!newText	^ 'elements: a Set()name: ''TestSlice2''type: #Explicit'! !!MDSliceDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:32'!testAccept	| variant definition new |	variant := self variant.	definition := variant definition.	definition callback: [:v | new := v].	definition accept: self newText notifying: nil.	self deny: new isNil! !!MDSliceDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:24'!variant	^ MDTestBuilder new sliceVariant! !MDAnnouncement subclass: #MDSliceTouched	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!(MDSliceTouched instVarNames includes: 'slice') ifFalse:	[MDSliceTouched addInstVarName: 'slice']!!MDSliceTouched methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 21:41'!setSlice: aSlice	slice := aSlice! !!MDSliceTouched methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 21:41'!slice	^ slice! !!MDSliceTouched class methodsFor: 'as yet unclassified' stamp: 'cwp 8/3/2008 21:41'!for: aSlice	^ self new setSlice: aSlice! !MDSliceTest subclass: #MDSmalltalkSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:51'!testClassInstVarClasses	self 		assertAllOf: #(MDBogusA)		butNoneOf: #(MDNonexistentClass)		as: [:name | MDClassInstVarElement 								className: name 								name: #aleph]. 		! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:03'!testClassInstVars	self 		assertAllOf: #(aleph)		butNoneOf: #(doesntexist)		as: [:name | MDClassInstVarElement 								className: #MDBogusA 								name: name]. 		! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:54'!testClassMethodClasses	self 		assertAllOf: #(MDSliceTest)		butNoneOf: #(MDNonexistentClass)		as: 			[:name | 			MDMethodElement 				className: name				selector: #bogusMethodA				classIsMeta: true]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:03'!testClassMethods	self 		assertAllOf: #(#bogusMethodA #bogusMethodB )		butNoneOf: #(#methodDoesntExist )		as: 			[:sel | 			MDMethodElement 				className: #MDSliceTest				selector: sel				classIsMeta: true]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 10/2/2008 20:22'!testClassVarClasses	self 		assertAllOf: #(MDBogusA)		butNoneOf: #(MDNonexistentClass)		as: [:name | MDClassVarElement className: name name: #MDAlpha]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 10/2/2008 20:22'!testClassVars	self 		assertAllOf: #('MDAlpha' )		butNoneOf: #('DoesntExist' )		as: [:name | MDClassVarElement className: #MDBogusA name: name]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:41'!testClasses	self 		assertAllOf: #(#MDBogusA #MDSliceTest )		butNoneOf: #(#MDNonexistentClass)		as: [:name | MDClassElement className: name]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:54'!testComments	self 		assertAllOf: #(#MDSliceTest )		butNoneOf: #(#MDNonexistentClass)		as: [:name | MDClassCommentElement className: name]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:03'!testIncludedComments	self 		assertAllOf: #(MDBogusA MDSliceTest)		butNoneOf: #(Object)		includedAs: [:name | MDClassCommentElement className: name]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:46'!testInstVarClasses	self 		assertAllOf: #(MDBogusA)		butNoneOf: #(MDNonexistentClass)		as: [:name | MDInstVarElement className: name name: 'one']! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:03'!testInstVars	self 		assertAllOf: #('one' )		butNoneOf: #('doesntexist' )		as: [:name | MDInstVarElement className: #MDBogusA name: name]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:56'!testMethodClasses	self 		assertAllOf: #(MDSliceTest)		butNoneOf: #(MDNonexistentClass)		as: [:name | MDMethodElement className: name selector: #classes]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:03'!testMethods	self 		assertAllOf: #(#classes #methods )		butNoneOf: #(#methodDoesntExist )		as: [:sel | MDMethodElement className: #MDSliceTest selector: sel]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 12:57'!testPoolImportClasses	self 		assertAllOf: #(MDBogusA)		butNoneOf: #(MDNonexistentClass)		as: 			[ :name | 			MDPoolImportElement 				className: name				name: #MDBogusPoolA ]! !!MDSmalltalkSliceTest methodsFor: 'tests' stamp: 'cwp 6/1/2008 23:04'!testPoolImports	self 		assertAllOf: #(#MDBogusPoolA #TextConstants )		butNoneOf: #(#PoolDoesntExist )		as: 			[ :name | 			MDPoolImportElement 				className: #MDBogusA				name: name ]! !!MDSmalltalkSliceTest class methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:21'!isAbstract	^ self name = #MDSmalltalkSliceTest! !MDHashedObject subclass: #MDSnapshot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!!MDSnapshot commentStamp: 'dc 6/14/2007 08:13' prior: 0!This is a set of Versions which "go together." A snapshot is equivalent to an MCVersion in MC1. It's the unit at which code is moved between images.!(MDSnapshot instVarNames includes: 'contents') ifFalse:	[MDSnapshot addInstVarName: 'contents']!!MDSnapshot methodsFor: 'accessing' stamp: 'cwp 3/27/2005 22:39'!contents	^ contents! !!MDSnapshot methodsFor: 'repository' stamp: 'cwp 1/19/2007 23:27'!getVersionsFrom: aRepository	^ contents collect: [:ea | aRepository get: ea]! !!MDSnapshot methodsFor: 'repository' stamp: 'cwp 5/22/2008 00:10'!getVersionsFrom: aRepository for: aWorkingCopy	| versions missing |	versions := Set new.	missing := Set new.	contents do:		[:hashstamp |		aWorkingCopy 			versionForHashstamp: hashstamp			ifPresent: [:v | versions add: v]			ifAbsent: [missing add: hashstamp]].	versions addAll: (aRepository getAll: missing).	^ versions! !!MDSnapshot methodsFor: 'testing' stamp: 'cwp 1/1/2007 09:34'!isSnapshot	^ true! !!MDSnapshot methodsFor: 'initialize-release' stamp: 'cwp 6/23/2008 08:52'!setVersions: aSet	contents := (aSet collect: [:ea | ea hashstamp]) asSet.	self initHashstamp.! !!MDSnapshot class methodsFor: 'serialization' stamp: 'avi 3/12/2005 02:52'!extension	^ 'snap'! !!MDSnapshot class methodsFor: 'instance creation' stamp: 'cwp 3/23/2005 22:52'!withVersions: versions	^ self new setVersions: versions! !MDAdaptionTest subclass: #MDSqueakAdaptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakAdaptionTest methodsFor: 'converting' stamp: 'cwp 5/26/2008 19:41'!proxyClass	^ MDSqueakDomain! !MDSqueakElementAdaptor subclass: #MDSqueakClassAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakClassAdaptor methodsFor: 'accessing' stamp: 'cwp 2/6/2005 12:39'!category	^ self elementClass category! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 2/5/2005 22:30'!classVariablesString	^ self send: #classVariablesString toClassIfNil: ['']! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 12/2/2005 22:47'!elementClass	^ system at: element theClassName ifAbsent: [nil]! !!MDSqueakClassAdaptor methodsFor: 'accessing' stamp: 'cwp 2/6/2005 12:39'!format	^ self elementClass typeOfClass! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 2/5/2005 22:30'!instanceVariablesString	^ self send: #instanceVariablesString toClassIfNil: ['']! !!MDSqueakClassAdaptor methodsFor: 'public' stamp: 'cwp 2/15/2005 15:31'!isLoadable: properties 	self superclassFrom: properties ifAbsent: [^ false].	^ true! !!MDSqueakClassAdaptor methodsFor: 'public' stamp: 'cwp 12/1/2005 22:31'!isPresent	^ (system at: element theClassName ifAbsent: [^ false])		isBehavior! !!MDSqueakClassAdaptor methodsFor: 'public' stamp: 'cwp 5/22/2008 00:13'!load: properties	| superClass |	superClass := Smalltalk at: properties superclassName.	ClassBuilder new		name: element theClassName 		inEnvironment: superClass environment 		subclassOf: superClass		type: properties format 		instanceVariableNames: self instanceVariablesString 		classVariableNames: self classVariablesString 		poolDictionaries: self sharedPoolsString		category: properties category! !!MDSqueakClassAdaptor methodsFor: 'accessing' stamp: 'cwp 2/5/2005 23:02'!propertyNames	^ #(category format superclassName)! !!MDSqueakClassAdaptor methodsFor: 'public' stamp: 'cwp 2/6/2005 12:39'!remove	self elementClass ifNotNilDo: [:class | class removeFromSystem]! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 2/6/2005 12:39'!send: aSelector toClassIfNil: aBlock	| class |	class := self elementClass.	^ class 		ifNotNil: [class perform: aSelector]		ifNil: aBlock! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 2/5/2005 22:31'!sharedPoolsString	^ self send: #sharedPoolsString toClassIfNil: ['']! !!MDSqueakClassAdaptor methodsFor: 'private' stamp: 'cwp 5/22/2008 00:13'!superclassFrom: properties ifAbsent: absentBlock 	| global |	global := system 				at: properties superclassName 				ifAbsent: [^ absentBlock value].	^ (global isBehavior)		ifTrue: [global]		ifFalse: absentBlock! !!MDSqueakClassAdaptor methodsFor: 'accessing' stamp: 'cwp 2/6/2005 12:40'!superclassName	^ self elementClass superclass name! !MDAdaptorTest subclass: #MDSqueakClassAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakClassAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 14:42'!adaptorClass	^ MDSqueakClassAdaptor ! !!MDSqueakClassAdaptorTest methodsFor: 'asserting' stamp: 'cwp 2/6/2005 11:55'!assertObjectHasDefaultProperties	| class |	class := Smalltalk 			at: self bogusClassName 			ifAbsent: [self signalFailure: 'Class doesn''t exist'].	self assert: class superclass name = self superclassName.	self assert: class category = self category.	self assert: class typeOfClass = self format! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/6/2005 12:02'!bogusClassName	^ #MDBogusB! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/6/2005 12:03'!category	^ #'Monticello2-Fakes'! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/12/2005 15:05'!changedValue	^ #temp! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:16'!classInstVars	^ 'aleph beth'! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/6/2005 12:07'!classVariablesString	^ 'Alpha Beta'! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:12'!classVars	^ 'Alpha Beta'! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:13'!comment	^ 'A politician''s comment: it fills the space, while saying nothing.'! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:14'!commentAuthor	^ self commentStamp copyUpTo: $ ! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:15'!commentStamp	^ 'abc 11/29/2004 01:44' ! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 4/9/2005 04:48'!commentTimeStamp	^ MDTimestamp fromSqueakMethodStamp: self commentStamp! !!MDSqueakClassAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 12:08'!createObject	Object 		subclass: self bogusClassName		instanceVariableNames: self instanceVariablesString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!MDSqueakClassAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 11:56'!destroyObject	(Smalltalk at: self bogusClassName ifAbsent: [^ self]) removeFromSystem! !!MDSqueakClassAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 11:58'!element	^ MDClassElement className: self bogusClassName! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 21:36'!format	^ #normal! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/6/2005 12:07'!instanceVariablesString	^'one two'! !!MDSqueakClassAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:06'!objectIsPresent	^ Smalltalk hasClassNamed: self bogusClassName asString! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 22:18'!properties	^ MDPropertyDictionary new		category: self category;		format: self format;		superclassName: self superclassName;		yourself! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/12/2005 14:45'!propertyToChange	^ #category! !!MDSqueakClassAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/6/2005 23:52'!sharedPoolsString	^ 'MDBogusPoolA'! !!MDSqueakClassAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 21:36'!superclassName	^ #Object! !!MDSqueakClassAdaptorTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 13:48'!testIsUnloadable	| properties |	properties := self properties.	properties superclassName: #MDNonExistentClass.	self deny: (self adaptor isLoadable: properties)! !!MDSqueakClassAdaptorTest methodsFor: 'tests' stamp: 'cwp 2/6/2005 12:05'!testLoadingPreservesVars	| class |	self createObject.	self adaptor load: self properties.	class := Smalltalk at: self bogusClassName ifAbsent: [self assert: false].	self assert: class instanceVariablesString = 'one two'.	self assert: class classVariablesString = 'Alpha Beta'.	self assert: class sharedPoolsString = self sharedPoolsString.! !!MDSqueakClassAdaptorTest methodsFor: 'tests' stamp: 'cwp 6/14/2008 13:54'!testUnloadableNotPresent	! !MDSqueakElementAdaptor subclass: #MDSqueakClassCommentAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakClassCommentAdaptor methodsFor: 'public' stamp: 'cwp 6/14/2008 13:56'!isPresent	| class |	class := self elementClass.	^ class notNil and: [class hasComment]! !!MDSqueakClassCommentAdaptor methodsFor: 'public' stamp: 'cwp 2/12/2005 14:55'!load: properties	self elementClass		classComment: properties text		stamp: (self stampFromProperties: properties)! !!MDSqueakClassCommentAdaptor methodsFor: 'properties' stamp: 'cwp 11/17/2007 01:22'!propertyNames	^ #(text initials timeStamp)! !!MDSqueakClassCommentAdaptor methodsFor: 'public' stamp: 'cwp 2/12/2005 14:59'!remove	self elementClass organization classComment: nil stamp: nil.! !!MDSqueakClassCommentAdaptor methodsFor: 'properties' stamp: 'cwp 2/12/2005 14:34'!stamp	^ self elementClass organization commentStamp! !!MDSqueakClassCommentAdaptor methodsFor: 'properties' stamp: 'cwp 3/11/2005 21:02'!text	^ self elementClass comment asString! !MDAdaptorTest subclass: #MDSqueakClassCommentAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakClassCommentAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 15:39'!adaptorClass	^ MDSqueakClassCommentAdaptor! !!MDSqueakClassCommentAdaptorTest methodsFor: 'asserting' stamp: 'cwp 2/12/2005 14:57'!assertObjectHasDefaultProperties	self assert: self bogusClass comment = self text.	self assert: self bogusClass organization commentStamp = self stamp.! !!MDSqueakClassCommentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 2/12/2005 14:51'!changedValue	^ 'A different comment for MDBogusA.'! !!MDSqueakClassCommentAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/12/2005 14:27'!createObject	self bogusClass classComment: self text stamp: self stamp! !!MDSqueakClassCommentAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/12/2005 15:00'!destroyObject	self bogusClass organization classComment: nil stamp: nil! !!MDSqueakClassCommentAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 14:20'!element	^ MDClassCommentElement className: self bogusClass name! !!MDSqueakClassCommentAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/12/2005 14:59'!objectIsPresent	^ self bogusClass hasComment! !!MDSqueakClassCommentAdaptorTest methodsFor: 'constructing' stamp: 'cwp 11/17/2007 01:23'!properties	^ MDPropertyDictionary new		at: #text put: self text;		at: #initials put: self initials;		at: #timeStamp put: self timeStamp;		yourself! !!MDSqueakClassCommentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 2/12/2005 14:45'!propertyToChange	^ #text! !!MDSqueakClassCommentAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/12/2005 14:18'!stamp	^ 'abc 11/29/2004 01:44' ! !!MDSqueakClassCommentAdaptorTest methodsFor: 'tests' stamp: 'cwp 3/11/2005 20:54'!testTextAsString	| properties |	self createObject.	properties := MDPropertyDictionary new.	self adaptor update: properties.	self assert: (properties text isKindOf: String)! !!MDSqueakClassCommentAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/12/2005 14:26'!text	^ 'A comment for MDBogusA'! !!MDSqueakClassCommentAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:06'!unloadableElement	^MDClassCommentElement className: #MDNonExistentClass! !MDSqueakElementAdaptor subclass: #MDSqueakClassVarAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakClassVarAdaptor methodsFor: 'public' stamp: 'cwp 6/14/2008 13:57'!isPresent	| class |	class := self elementClass.	^ class notNil and: [class classVarNames includes: element name]! !!MDSqueakClassVarAdaptor methodsFor: 'public' stamp: 'cwp 2/6/2005 14:00'!load: properties	self isPresent ifFalse: [self elementClass addClassVarName: element name]! !!MDSqueakClassVarAdaptor methodsFor: 'public' stamp: 'cwp 2/6/2005 13:59'!remove	self isPresent ifTrue: [self elementClass removeClassVarName: element name]! !MDAdaptorTest subclass: #MDSqueakClassVarAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:00'!adaptorClass	^ MDSqueakClassVarAdaptor! !!MDSqueakClassVarAdaptorTest methodsFor: 'asserting' stamp: 'cwp 2/6/2005 14:04'!assertObjectHasDefaultProperties	self assert: self objectIsPresent! !!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 13:32'!classVarName	^ 'Beta'! !!MDSqueakClassVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 13:31'!createObject	self bogusClass addClassVarName: self classVarName! !!MDSqueakClassVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:04'!destroyObject	self objectIsPresent 		ifTrue: [self bogusClass removeClassVarName: self classVarName]! !!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 13:46'!element	^ MDClassVarElement 		className: self bogusClass name 		name: self classVarName! !!MDSqueakClassVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:04'!objectIsPresent	^self bogusClass classVarNames includes: self classVarName! !!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 13:32'!properties	^ MDPropertyDictionary new! !!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 14:46'!propertyToChange	"Class variables have no properties and thus can never by out of date."	^ nil 	! !!MDSqueakClassVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:01'!unloadableElement	^ MDClassVarElement className: #MDNonExistentClass name: #Foo! !MDAdaptionTest subclass: #MDSqueakDefinitionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Tests'!!MDSqueakDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 12/16/2007 23:59'!adaptorSelectors	^ #(text selection accept:notifying:)! !!MDSqueakDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!setUp	proxy := MDVariantDefinition! !MDDomain subclass: #MDSqueakDomain	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!(MDSqueakDomain instVarNames includes: 'editor') ifFalse:	[MDSqueakDomain addInstVarName: 'editor']!!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:46'!adaptorForClassCommentElement: anElement	^ MDSqueakClassCommentAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:43'!adaptorForClassElement: anElement	^ MDSqueakClassAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:49'!adaptorForClassInstVarElement: anElement	^ MDSqueakClassInstVarAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:48'!adaptorForClassVarElement: anElement	^ MDSqueakClassVarAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:50'!adaptorForInstVarElement: anElement	^ MDSqueakInstVarAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:53'!adaptorForMethodElement: anElement	^ MDSqueakMethodAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'adaptors' stamp: 'cwp 3/2/2006 20:54'!adaptorForPoolImportElement: anElement	^ MDSqueakPoolImportAdaptor forElement: anElement inSystem: editor! !!MDSqueakDomain methodsFor: 'initialize-release' stamp: 'cwp 5/7/2008 07:53'!initialize	editor := Smalltalk! !!MDSqueakDomain methodsFor: 'public' stamp: 'cwp 5/26/2008 22:04'!name	^ #smalltalk! !!MDSqueakDomain methodsFor: 'public' stamp: 'cwp 5/22/2008 00:13'!transaction: aBlock	|  result tmp |	tmp := editor.	[editor := MDPlatform current systemEditor.	result := aBlock value.	editor commit]		ensure: [editor := tmp].	^ result! !(MDSqueakDomain class instVarNames includes: 'default') ifFalse:	[MDSqueakDomain class addInstVarName: 'default']!!MDSqueakDomain class methodsFor: 'accessing' stamp: 'cwp 6/15/2008 20:35'!default	^ default ifNil: [default := self new]! !!MDSqueakDomain class methodsFor: 'instance creation' stamp: 'cwp 11/20/2008 18:53'!new	^ self basicNew initialize! !!MDSqueakDomain class methodsFor: 'accessing' stamp: 'cwp 6/15/2008 20:32'!type	^ #smalltalk! !MDSqueakElementAdaptor subclass: #MDSqueakInstVarAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 07:51'!assignNamesToEmptySlots: names 	1 		to: names size		do: 			[ :i | 			(names at: i) ifNil: 				[ names 					at: i					put: 'instVarAtSlot' , i asString ] ]! !!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 07:10'!basicLoad: properties 	| names instVarNames index |	names := self elementClass instVarNames.	index := properties index.	instVarNames := self installAt: index in: names.	self installInstVarNames: instVarNames! !!MDSqueakInstVarAdaptor methodsFor: 'properties' stamp: 'cwp 5/19/2008 13:26'!index	^ (self elementClassIfAbsent: [^ 0])		instVarNames indexOf: element name! !!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 07:58'!installAt: index in: aCollection 	| names |	names := self resize: aCollection for: index.	self moveInterloperAt: index in: names.	names at: index put: element name.	self assignNamesToEmptySlots: names.	^ names! !!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 20:05'!installInstVarNames: names 	| nameString |	nameString := String streamContents: 		[ :s | 		names 			do: [ :ea | s nextPutAll: ea ]			separatedBy: [ s space ] ].	self elementClass instanceVariableNames: nameString! !!MDSqueakInstVarAdaptor methodsFor: 'public' stamp: 'cwp 8/20/2005 18:21'!isPresent	^ (self elementClassIfAbsent: [^ false])		instVarNames includes: element name! !!MDSqueakInstVarAdaptor methodsFor: 'public' stamp: 'cwp 5/19/2008 19:34'!load: properties 	self isPresent ifFalse: [ self basicLoad: properties ]! !!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 07:58'!moveInterloperAt: index in: aCollection	| current |	current := aCollection indexOf: element name.	current = 0 ifTrue: [current := aCollection size].	aCollection at: current put: (aCollection at: index).! !!MDSqueakInstVarAdaptor methodsFor: 'properties' stamp: 'cwp 5/19/2008 13:25'!propertyNames	^ #(index)! !!MDSqueakInstVarAdaptor methodsFor: 'public' stamp: 'cwp 2/6/2005 23:56'!remove	self isPresent ifTrue: [self elementClass removeInstVarName: element name]! !!MDSqueakInstVarAdaptor methodsFor: 'private' stamp: 'cwp 5/20/2008 07:50'!resize: aCollection for: index 	| names size |	size := (aCollection includes: element name) 		ifTrue: [ aCollection size ]		ifFalse: [ aCollection size + 1 ].	names := Array new: (size max: index).	aCollection doWithIndex: 		[ :name :i | 		names 			at: i			put: name ].	^ names! !MDAdaptorTest subclass: #MDSqueakInstVarAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:02'!adaptorClass	^ MDSqueakInstVarAdaptor! !!MDSqueakInstVarAdaptorTest methodsFor: 'asserting' stamp: 'cwp 5/19/2008 13:19'!assertObjectHasDefaultProperties	self assert: (self bogusClass instVarNames indexOf: self instVarName) = 2! !!MDSqueakInstVarAdaptorTest methodsFor: 'constants' stamp: 'cwp 5/19/2008 13:23'!changedValue	^ 3! !!MDSqueakInstVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 12:24'!createObject	self bogusClass addInstVarName: self instVarName! !!MDSqueakInstVarAdaptorTest methodsFor: 'asserting' stamp: 'cwp 2/6/2005 14:07'!denyObjectIsPresent	self deny: self objectIsPresent! !!MDSqueakInstVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:05'!destroyObject	self objectIsPresent 		ifTrue: [self bogusClass removeInstVarName: self instVarName]! !!MDSqueakInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 12:26'!element	^ MDInstVarElement 		className: self bogusClass name 		name: self instVarName! !!MDSqueakInstVarAdaptorTest methodsFor: 'running' stamp: 'cwp 5/20/2008 20:10'!firstInstVarName	^ 'one'! !!MDSqueakInstVarAdaptorTest methodsFor: 'constants' stamp: 'cwp 2/6/2005 12:21'!instVarName	^'two'! !!MDSqueakInstVarAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:05'!objectIsPresent	^self bogusClass instVarNames includes: self instVarName! !!MDSqueakInstVarAdaptorTest methodsFor: 'properties' stamp: 'cwp 5/19/2008 13:21'!properties	^ MDPropertyDictionary new		index: 2;		yourself! !!MDSqueakInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/19/2008 13:20'!propertyToChange	"An instance variable has no properties, thus it is always up-to-date"	^ #index! !!MDSqueakInstVarAdaptorTest methodsFor: 'running' stamp: 'cwp 5/20/2008 20:10'!tearDown	super tearDown.	(self bogusClass instVarNames copyWithout: self firstInstVarName) do: [ :ea | self bogusClass removeInstVarName: ea ]! !!MDSqueakInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:02'!unloadableElement	^ MDInstVarElement 		className: #MDNonExistentClass		name: self instVarName! !MDSqueakElementAdaptor subclass: #MDSqueakMethodAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakMethodAdaptor methodsFor: 'accessing' stamp: 'cwp 2/3/2005 23:06'!category	^ self elementClass organization categoryOfElement: element selector! !!MDSqueakMethodAdaptor methodsFor: 'private' stamp: 'cwp 2/6/2005 12:44'!compiledMethod 	^ self elementClass compiledMethodAt: element selector! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'avi 3/22/2006 19:49'!display: properties	^ properties source! !!MDSqueakMethodAdaptor methodsFor: 'accessing' stamp: 'cwp 2/12/2005 15:24'!elementClassIfAbsent: aBlock	| nonMetaClass |	nonMetaClass := super elementClassIfAbsent: aBlock.	^ element classIsMeta		ifTrue: [nonMetaClass class]		ifFalse: [nonMetaClass]! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'cwp 6/14/2008 13:56'!isPresent	| class |	class := self elementClass.	^ class notNil and: [class includesSelector: element selector]! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'avi 3/14/2005 18:36'!isUpToDate: aPropertyDictionary	aPropertyDictionary localReference ifNotNilDo:		[:compiledMethod |		compiledMethod = self compiledMethod ifTrue: [^ true]].	^ super isUpToDate: aPropertyDictionary! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'cwp 5/22/2008 00:13'!load: properties	| selector |	selector := self elementClass					compile: (properties at: #source ifAbsent: [self source])					classified: (properties at: #category ifAbsent: [self category])					withStamp: (self stampFromProperties: properties)					notifying: nil					logSource: true.! !!MDSqueakMethodAdaptor methodsFor: 'accessing' stamp: 'cwp 11/17/2007 01:24'!propertyNames	^ #(initials timeStamp category source)! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'cwp 8/14/2005 19:57'!remove	(self elementClassIfAbsent: [^ self])		removeSelector: element selector! !!MDSqueakMethodAdaptor methodsFor: 'accessing' stamp: 'cwp 3/11/2005 20:44'!source	^ (self elementClass sourceCodeAt: (element selector)) asString.! !!MDSqueakMethodAdaptor methodsFor: 'accessing' stamp: 'cwp 2/12/2005 14:30'!stamp	^self compiledMethod timeStamp! !!MDSqueakMethodAdaptor methodsFor: 'public' stamp: 'avi 3/14/2005 18:32'!update: aPropertyDictionary	super update: aPropertyDictionary.	aPropertyDictionary localReference: self compiledMethod! !MDAdaptorTest subclass: #MDSqueakMethodAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:00'!adaptorClass	^ MDSqueakMethodAdaptor! !!MDSqueakMethodAdaptorTest methodsFor: 'asserting' stamp: 'cwp 8/20/2005 19:10'!assertObjectHasDefaultProperties	self assert: (self bogusClass includesSelector: self theSelector).	self assert: (self bogusClass organization categoryOfElement: self theSelector) = self category.	self assert: (self bogusClass sourceCodeAt: self theSelector) = self source.	self assert: (self bogusClass compiledMethodAt: self theSelector) timeStamp = self stamp.! !!MDSqueakMethodAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 17:24'!category	^ #temporary! !!MDSqueakMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 15:06'!changedValue	^ #temp! !!MDSqueakMethodAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 11:52'!createObject	self bogusClass		compile: self source		classified: self category		withStamp: self stamp		notifying: nil		logSource: true! !!MDSqueakMethodAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 12:15'!destroyObject	self bogusClass removeSelector: self theSelector! !!MDSqueakMethodAdaptorTest methodsFor: 'configuration' stamp: 'cwp 10/23/2006 10:26'!displayString	^ self properties source! !!MDSqueakMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/6/2005 12:16'!element	^ MDMethodElement className: self bogusClass name selector: self theSelector! !!MDSqueakMethodAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 14:07'!objectIsPresent	^self bogusClass includesSelector: self theSelector! !!MDSqueakMethodAdaptorTest methodsFor: 'properties' stamp: 'cwp 11/17/2007 01:24'!properties	^ MDPropertyDictionary new		initials: self initials;		category: self category;		source: self source;		timeStamp: self timeStamp;		yourself! !!MDSqueakMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 14:49'!propertyToChange	^ #category! !!MDSqueakMethodAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/5/2005 17:23'!source	^ 'method1	^ 1'! !!MDSqueakMethodAdaptorTest methodsFor: 'properties' stamp: 'cwp 8/20/2005 19:09'!stamp	^ 'abc 11/29/2004 14:44' ! !!MDSqueakMethodAdaptorTest methodsFor: 'tests' stamp: 'cwp 3/11/2005 20:43'!testSourceAsString	| properties |	self createObject.	properties := MDPropertyDictionary new.	self adaptor update: properties.	self assert: (properties source isKindOf: String)! !!MDSqueakMethodAdaptorTest methodsFor: 'asserting' stamp: 'cwp 2/6/2005 12:14'!theSelector	^#method1! !!MDSqueakMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 15:58'!unloadableElement	^ MDMethodElement className: #MDNonExistentClass selector: #foo! !MDSqueakElementAdaptor subclass: #MDSqueakPoolImportAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakPoolImportAdaptor methodsFor: 'private' stamp: 'cwp 5/18/2008 21:44'!importedPool	^ system at: element name ifAbsent: [nil]! !!MDSqueakPoolImportAdaptor methodsFor: 'public' stamp: 'cwp 5/18/2008 21:59'!isLoadable: properties	^ (super isLoadable: properties) and: [self importedPool notNil]! !!MDSqueakPoolImportAdaptor methodsFor: 'public' stamp: 'cwp 10/13/2008 12:49'!isPresent	| class |	class := self elementClass.	^ class notNil and: 		[class sharedPools anySatisfy: 			[:ea | (system keyAtValue: ea ifAbsent: [nil]) = element name ]]! !!MDSqueakPoolImportAdaptor methodsFor: 'public' stamp: 'cwp 5/22/2008 00:13'!load: properties	| class pool |	class := self elementClass.	pool := self importedPool.	(class sharedPools includes: pool)		ifFalse: [class addSharedPool: pool]! !!MDSqueakPoolImportAdaptor methodsFor: 'public' stamp: 'cwp 2/6/2005 23:44'!remove	"Work around a bug in Class>>removeSharedPool:"		self elementClass sharedPools remove: self importedPool ifAbsent: []! !MDAdaptorTest subclass: #MDSqueakPoolImportAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakPoolImportAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/15/2005 16:04'!adaptorClass	^ MDSqueakPoolImportAdaptor! !!MDSqueakPoolImportAdaptorTest methodsFor: 'asserting' stamp: 'cwp 4/28/2008 21:41'!assertObjectHasDefaultProperties	self assert: (self bogusClass sharedPools anySatisfy: [ :ea | ea name = self poolName ])! !!MDSqueakPoolImportAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 22:56'!createObject	self bogusClass addSharedPool: self pool! !!MDSqueakPoolImportAdaptorTest methodsFor: 'image access' stamp: 'cwp 2/6/2005 23:09'!destroyObject	self bogusClass sharedPools remove: self pool ifAbsent: []! !!MDSqueakPoolImportAdaptorTest methodsFor: 'constructing' stamp: 'cwp 4/28/2008 22:04'!element	^ MDPoolImportElement 		className: self bogusClass name		name: self poolName! !!MDSqueakPoolImportAdaptorTest methodsFor: 'image access' stamp: 'cwp 4/28/2008 21:31'!objectIsPresent	^ self bogusClass sharedPools anySatisfy: [ :ea | ea name = self name ]! !!MDSqueakPoolImportAdaptorTest methodsFor: 'accessing' stamp: 'cwp 4/28/2008 21:35'!pool	^ Smalltalk at: self poolName! !!MDSqueakPoolImportAdaptorTest methodsFor: 'accessing' stamp: 'cwp 2/6/2005 22:59'!poolName	^ #MDBogusPoolB! !!MDSqueakPoolImportAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/6/2005 23:37'!properties	^ MDPropertyDictionary new! !!MDSqueakPoolImportAdaptorTest methodsFor: 'properties' stamp: 'cwp 2/12/2005 14:49'!propertyToChange	"A pool import has no properties and is thus always up-to-date."	^ nil! !!MDSqueakPoolImportAdaptorTest methodsFor: 'tests' stamp: 'cwp 10/13/2008 12:45'!testDictionaryPoolPresence	| element adaptor |	element := MDPoolImportElement className: #MDBogusA name: #TextConstants.	adaptor := self adaptorForElement: element.	self assert: adaptor isPresent.! !!MDSqueakPoolImportAdaptorTest methodsFor: 'tests' stamp: 'cwp 5/18/2008 21:57'!testPoolMissing	| adaptor element |	self canBeUnloadable ifTrue: 		[ element := MDPoolImportElement 			className: self bogusClass name			name: #MDNonExistentPool.		adaptor := self adaptorForElement: element.		self deny: (adaptor isLoadable: self properties) ]! !!MDSqueakPoolImportAdaptorTest methodsFor: 'constructing' stamp: 'cwp 4/28/2008 22:04'!unloadableElement	^ MDPoolImportElement 		className: #MDNonExistentClass		name: #Foo! !MDSqueakElementAdaptor subclass: #MDSqueakSliceAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 1/18/2007 22:01'!isLoadable: properties	^ true! !!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 1/18/2007 22:57'!isPresent	^ system includesId: element id! !!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 12/29/2007 22:35'!isUpToDate: properties	^ self properties = properties	! !!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 5/28/2008 23:00'!load: properties	(system objectWithId: element id satisfies: [:slice | slice properties = properties])		ifFalse: [system register: (MDSlice withProperties: properties)]! !!MDSqueakSliceAdaptor methodsFor: 'private' stamp: 'cwp 12/29/2007 22:35'!properties	^ (system objectWithId: element id) properties.! !!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 11/9/2007 22:25'!remove	system unregisterId: element id! !!MDSqueakSliceAdaptor methodsFor: 'public' stamp: 'cwp 5/22/2008 00:13'!update: properties	| props |	props := self properties.	properties keys do: 		[:ea | 		(props includesKey: ea) 			ifFalse: [properties removeKey: ea]].	props keysAndValuesDo:		[:k :v | properties at: k put: v]! !MDRepositoryTest subclass: #MDStoreTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDStoreTest methodsFor: 'construction' stamp: 'cwp 3/13/2005 00:33'!newRepository	^ MDStore new		addRepository: MDMemoryRepository new;		addRepository: MDMemoryRepository new;		yourself! !!MDStoreTest methodsFor: 'tests' stamp: 'cwp 5/31/2008 22:50'!testLoad	self 		shouldnt:[repository properties: MDPropertyDictionary new]		raise: Error! !!MDStoreTest methodsFor: 'tests' stamp: 'cwp 3/10/2008 20:17'!testMemoDuplication	| store griffle plonk memo1 memo2 |	store := MDStore new.	griffle := MDMemoryRepository new.	plonk := MDMemoryRepository new.	store		addRepository: griffle;		addRepository: plonk.			memo1 := MDMemo				snapshot: (MDSnapshot withVersions: #())				slice: (MDExplicitSlice named: 'test')				parents: #()				properties: MDPropertyDictionary new.	memo2 := MDMarshal materialize: (MDMarshal serialize: memo1).		griffle put: memo1.	plonk put: memo2.		self assert: store memos size = 1! !!MDStoreTest methodsFor: 'tests' stamp: 'cwp 5/31/2008 22:48'!testProperties	| properties |	properties := repository properties.	self assert: properties name = 'store'.	self assert: properties type = #Store! !!MDStoreTest methodsFor: 'tests' stamp: 'cwp 3/12/2005 22:56'!testSingleton	self assert: MDStore default == MDStore default! !MDNetMessage subclass: #MDThankYou	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDThankYou instVarNames includes: 'count') ifFalse:	[MDThankYou addInstVarName: 'count']!!MDThankYou methodsFor: 'comparing' stamp: 'cwp 1/3/2008 23:52'!= other	^ self species = other species and: [self count = other count]! !!MDThankYou methodsFor: 'accessing' stamp: 'cwp 1/3/2008 23:52'!count	^ count! !!MDThankYou methodsFor: 'comparing' stamp: 'cwp 1/3/2008 23:52'!hash	^ count hash! !!MDThankYou methodsFor: 'writing' stamp: 'cwp 1/4/2008 20:58'!isThankYou	^ true! !!MDThankYou methodsFor: 'intialize-release' stamp: 'cwp 5/22/2008 00:11'!setContents: anInteger	count := anInteger! !!MDThankYou methodsFor: 'writing' stamp: 'cwp 1/3/2008 23:51'!writeContentsOn: aStream	MDMarshal serialize: count on: aStream! !!MDThankYou class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:44'!id	^ 130! !MDDefinition subclass: #MDUndefinedDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDUndefinedDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 21:43'!callback: aBlock! !MDSerializerTest subclass: #MDUtf16SerializerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDUtf16SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:19'!serialize: anObject on: aStream	| serializer |	serializer := MDSerializer on: aStream.	serializer serializeUtf16String: anObject.! !!MDUtf16SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 12:10'!serializer	^ MDUtf16Serializer type: 16! !!MDUtf16SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/23/2008 08:57'!testAboriginal	self 		assert: MDPlatform current aboriginalAbc		yields: #(16 9 3 20 1 20 2 20 3)! !!MDUtf16SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 12:05'!testAscii	self 		assert: 'abc' 		yields: #(16 9 3 0 97 0 98 0 99)! !!MDUtf16SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/17/2008 01:07'!testLatin	self 		assert: 'bc' 		yields: #(16 9 3 0 225 0 98 0 99)	! !MDMaterializerTest subclass: #MDUtf8MaterializerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDUtf8MaterializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:53'!assert: aByteArray yields: expected	| actual |	actual := MDMaterializer materialize: aByteArray.	self assert: actual = expected! !!MDUtf8MaterializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/23/2008 08:57'!testAboriginal	self		assert: #(15 9 3 225 144 129 225 144 130 225 144 131)		yields: MDPlatform current aboriginalAbc! !!MDUtf8MaterializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 14:36'!testAscii	self		assert: #(15 9 3 97 98 99)		yields: 'abc'! !!MDUtf8MaterializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/17/2008 01:07'!testLatin	self		assert: #(15 9 3 195 161 98 99)		yields: 'bc'! !MDSerializerTest subclass: #MDUtf8SerializerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDUtf8SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/15/2008 12:20'!serialize: anObject on: aStream	| serializer |	serializer := MDSerializer on: aStream.	serializer serializeUtf8String: anObject.! !!MDUtf8SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 12:09'!serializer	^ MDUtf8Serializer type: 15! !!MDUtf8SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/23/2008 08:57'!testAboriginal	self 		assert: MDPlatform current aboriginalAbc		yields: #(15 9 3 225 144 129 225 144 130 225 144 131)! !!MDUtf8SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/19/2008 12:06'!testAscii	self assert: 'abc' yields: #(15 9 3 97 98 99)! !!MDUtf8SerializerTest methodsFor: 'as yet unclassified' stamp: 'cwp 11/17/2008 01:07'!testLatin	self assert: 'bc' yields: #(15 9 3 195 161 98 99)! !MDChunk subclass: #MDVariableChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!(MDVariableChunk instVarNames includes: 'independent') ifFalse:	[MDVariableChunk addInstVarName: 'independent']!!MDVariableChunk methodsFor: 'accessing' stamp: 'cwp 4/3/2008 22:26'!beDependent	independent := false! !!MDVariableChunk methodsFor: 'accessing' stamp: 'cwp 4/3/2008 22:26'!beIndependent	independent := true! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:31'!classReference	^ element theClassName! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!conditional	^ properties		ifNil: ['ifTrue:']		ifNotNil: ['ifFalse:']! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:24'!definitionSelector	self subclassResponsibility! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:24'!listSelector	self subclassResponsibility! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!quote	^ ''''! !!MDVariableChunk methodsFor: 'accessing' stamp: 'cwp 4/27/2008 00:40'!reactToClass: aChunk	element theClassName = aChunk name ifTrue: 		[aChunk isRemoval			ifTrue: [self beInvisible]			ifFalse: [self beDependent]].	^ aChunk! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:24'!removalSelector	self subclassResponsibility! !!MDVariableChunk methodsFor: 'initialize-release' stamp: 'cwp 4/3/2008 22:28'!setElement: anElement	super setElement: anElement.	independent := true! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:24'!typeChar	self subclassResponsibility! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!writeBasicDefinitionOn: aStream 	aStream		nextPutAll: element theClassName;		space;		nextPutAll: self definitionSelector;		space;		nextPutAll: self quote;		nextPutAll: element name;		nextPutAll: self quote! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!writeBasicRemovalOn: aStream 	aStream		nextPutAll: element theClassName;		space;		nextPutAll: self removalSelector;		space;		nextPutAll: self quote;		nextPutAll: element name;		nextPutAll: self quote! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!writeClassCheckOn: aStream with: aBlock	independent ifFalse: aBlock ifTrue: 		[aStream			nextPutAll: '(Smalltalk hasClassNamed: #';			nextPutAll: element theClassName;			nextPutAll: ') ifTrue:';			crtab;			nextPut: $[.		aBlock value.		aStream			nextPut: $]].	aStream 		nextPut: $!!; 		cr! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!writeDefinitionOn: aStream 	self 		writeClassCheckOn: aStream		with: 			[ self 				writeGuardOn: aStream				with: [ self writeBasicDefinitionOn: aStream ] ]! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:30'!writeGuardOn: aStream with: aBlock	aStream		nextPut: $(;		nextPutAll: self classReference;		space;		nextPutAll: self listSelector;		nextPutAll: ' includes: ';		nextPutAll: self quote;		nextPutAll: element name;		nextPutAll: self quote;		nextPutAll: ') ';		nextPutAll: self conditional;		crtab.	independent ifTrue: [aStream tab].	aStream nextPut: $[.	aBlock value.	aStream nextPut: $]! !!MDVariableChunk methodsFor: 'writing' stamp: 'cwp 4/3/2008 22:29'!writeRemovalOn: aStream 	self 		writeClassCheckOn: aStream		with: 			[ self 				writeGuardOn: aStream				with: [ self writeBasicRemovalOn: aStream ] ]! !MDChunkTest subclass: #MDVariableChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!(MDVariableChunkTest instVarNames includes: 'chunk') ifFalse:	[MDVariableChunkTest addInstVarName: 'chunk']!!MDVariableChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/27/2008 00:38'!testClassIsRemoved	| actual class |	class := MDClassChunk forElement: (MDClassElement className: #BogusB).	class remove.	chunk reactToClass: class.	chunk load: MDPropertyDictionary new.	actual := self write: chunk.	self assert: actual isEmpty! !!MDVariableChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:20'!testIndependentDefinition	| actual expected |	chunk load: MDPropertyDictionary new.	actual := self write: chunk.	expected := self expectedIndependentDefinition.	self assert: actual = expected! !!MDVariableChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:20'!testIndependentRemoval	| actual expected |	chunk remove.	actual := self write: chunk.	expected := self expectedIndependentRemoval.	self assert: actual = expected! !!MDVariableChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:20'!testSimpleDefinition	| actual expected |	chunk load: MDPropertyDictionary new.	chunk beDependent.	actual := self write: chunk.	expected := self expectedSimpleDefinition.	self assert: actual = expected! !!MDVariableChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:21'!testSimpleRemoval	| actual expected |	chunk remove.	chunk beDependent.	actual := self write: chunk.	expected := self expectedSimpleRemoval.	self assert: actual = expected! !!MDVariableChunkTest class methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:30'!isAbstract	^ self name = #MDVariableChunkTest! !!MDVariableChunkTest class methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:30'!shouldInheritSelectors	^ true! !MDHashedObject subclass: #MDVersion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!!MDVersion commentStamp: 'dc 6/14/2007 07:54' prior: 0!This is the central class of MC2. It represents the state of an element at a particular point in the evolution of the system. It combines a variant with list of versions that have come before it. Each version has what we call a Hashstamp - combination of SHA1 hash and timestamp which uniquely identifies the version. A version's ancestry is a set of hashstamps specifying which versions are part of this version's history.!!MDVersion methodsFor: 'comparing' stamp: 'dc 6/14/2007 07:55'!conflictsWith: other	^ ((self precedes: other)			or: [self succeeds: other]) not! !!MDVersion methodsFor: 'comparing' stamp: 'cwp 2/28/2005 21:47'!succeeds: anElementVersion 	^anElementVersion precedes: self! !!MDVersion methodsFor: 'comparing' stamp: 'avi 3/21/2006 00:13'!successor: other 	(self = other) ifTrue: [^ self].	(self succeeds: other) ifTrue: [^ self].	(other succeeds: self) ifTrue: [^ other].	^ nil! !!MDVersion methodsFor: 'comparing' stamp: 'dc 6/14/2007 08:01'!successor: other onConflict: aBlock 	^ (self successor: other)		ifNil: [MDElementVersion					variant: aBlock value					ancestry: self fullAncestry , other fullAncestry]! !!MDVersion class methodsFor: 'serialization' stamp: 'avi 3/12/2005 02:53'!extension	^ 'vers'! !MDHashstampMessage subclass: #MDAllHashstamps	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDAllHashstamps class methodsFor: 'as yet unclassified' stamp: 'cwp 1/8/2008 18:36'!id	^ 132! !MDErrorMessage subclass: #MDAuthenticationFailed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDAuthenticationFailed class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:30'!id	^ 193! !MDSlice subclass: #MDChangeSetSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Slices'!(MDChangeSetSlice instVarNames includes: 'changeSet') ifFalse:	[MDChangeSetSlice addInstVarName: 'changeSet']!!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 2/7/2008 21:52'!addNameOfPool: anObject to: aSet	aSet add: (Smalltalk keyAtIdentityValue: anObject ifAbsent: [^ self])! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 5/22/2008 00:10'!class: name do: aBlock	| changes |	changes := changeSet classChangeAt: name.	changes isEmpty ifFalse: [aBlock value: (MDClassElement className: name)].	(changes includes: #comment) ifTrue: [self commentFor: name do: aBlock].	(changes includes: #change) ifTrue: [self instVarsFor: name do: aBlock].	self classVarsFor: name do: aBlock.	self poolImportsFor: name do: aBlock.	self methodsFor: name do: aBlock.		changes := changeSet classChangeAt: name, ' class'.	(changes includes: #change) ifTrue: [self classInstVarsFor: name do: aBlock].	self classMethodsFor: name do: aBlock.! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/6/2008 21:07'!classInstVarsFor: name do: aBlock		(self instVarsFor: name, ' class') do:		[:ivar | aBlock value: (MDClassInstVarElement className: name name: ivar)]! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/6/2008 20:22'!classMethodsFor: className do: aBlock	(changeSet methodChangesAtClass: className, ' class') keys do: 		[:ea | 		aBlock value: (MDMethodElement 						className: className 						selector: ea 						classIsMeta: true)]! !!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 6/14/2008 12:44'!classVarsFor: className 	| classVars class |	class := self currentClass: className.	classVars := class ifNil: [Set new] ifNotNil: [class classVarNames].	classVars addAll: (self oldClassVarsFor: className).	^ classVars! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/6/2008 22:26'!classVarsFor: name do: aBlock		(self classVarsFor: name) do:		[:cvar | aBlock value: (MDClassVarElement 								className: name 								name: cvar)]! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/5/2008 22:34'!commentFor: className do: aBlock	aBlock value: (MDClassCommentElement className: className)! !!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 2/5/2008 22:31'!currentClass: className	^ Smalltalk classNamed: className! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/6/2008 22:41'!elementsDo: aBlock	(changeSet changedClassNames reject: [:ea | ea includes: $ ])		do: [:ea | self class: ea do: aBlock]! !!MDChangeSetSlice methodsFor: 'testing' stamp: 'cwp 2/4/2008 23:03'!includes: anElement	^ anElement isIncludedInSlice: self! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/5/2008 00:28'!includesClass: anElement	^ (changeSet classChangeAt: anElement theClassName) isEmpty not! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/5/2008 00:13'!includesClassComment: anElement	^ (changeSet classChangeAt: anElement theClassName) includes: #comment! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/6/2008 21:20'!includesClassInstVar: anElement 	^ (self instVarsFor: anElement theClassName, ' class') includes: anElement name! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/6/2008 23:00'!includesClassVar: anElement 	^ (self classVarsFor: anElement theClassName) includes: anElement name! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/5/2008 22:17'!includesInstVar: anElement 	^ (self instVarsFor: anElement theClassName) includes: anElement name! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 5/22/2008 00:10'!includesMethod: anElement	| name |	name := anElement classIsMeta				ifTrue: [anElement theClassName, ' class']				ifFalse: [anElement theClassName].	^ (changeSet methodChangesAtClass: name)		keys includes: anElement selector! !!MDChangeSetSlice methodsFor: 'dispatching' stamp: 'cwp 2/7/2008 22:16'!includesPoolImport: anElement 	^ (self poolImportsFor: anElement theClassName) includes: anElement name! !!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 6/14/2008 12:50'!instVarsFor: className 	| instVars class |	instVars := Set new.	(changeSet structures at: className ifAbsent: [#(first)]) allButFirst 		collect: [:ea | instVars add: ea].	class := self currentClass: className.	class ifNotNil: [class instVarNames do: [:ea | instVars add: ea]].	^ instVars! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/5/2008 22:24'!instVarsFor: name do: aBlock		(self instVarsFor: name) do:		[:ivar | aBlock value: (MDInstVarElement className: name name: ivar)]! !!MDChangeSetSlice methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:21'!load: properties 	changeSet := (ChangeSet named: properties name) ifNil: [ ChangeSet basicNewChangeSet: properties name ]! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/5/2008 23:41'!methodsFor: className do: aBlock	(changeSet methodChangesAtClass: className) keys do: 		[:ea | aBlock value: (MDMethodElement className: className selector: ea)]! !!MDChangeSetSlice methodsFor: 'accessing' stamp: 'cwp 5/28/2008 21:50'!name	^ changeSet name! !!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 5/22/2008 00:10'!oldClassVarsFor: className	| definition tokens |	definition := (changeSet changeRecorderFor: className) priorDefinition.	definition ifNil: [^ #()].	tokens := Scanner new scanTokens: definition.	^ ((tokens at: 7) findTokens: $ ) collect: [:ea | ea asSymbol]! !!MDChangeSetSlice methodsFor: 'private' stamp: 'cwp 6/14/2008 12:58'!poolImportsFor: className 	| names class |	names := Set new.	class := self currentClass: className.	class ifNotNil: 		[class sharedPools do: 			[:each | 			self 				addNameOfPool: each				to: names]].	^ names! !!MDChangeSetSlice methodsFor: 'enumerating' stamp: 'cwp 2/7/2008 22:13'!poolImportsFor: className do: aBlock	(self poolImportsFor: className) do:		[:ea | aBlock value: (MDPoolImportElement className: className name: ea)]! !!MDChangeSetSlice methodsFor: 'initializing' stamp: 'cwp 5/22/2008 00:10'!setChangeSet: aChangeSet	changeSet := aChangeSet.	self initId! !!MDChangeSetSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 2/4/2008 23:01'!on: aChangeSet	^ self new setChangeSet: aChangeSet! !!MDChangeSetSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2008 01:11'!type	^ #ChangeSet! !MDSmalltalkSliceTest subclass: #MDChangeSetSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDChangeSetSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:10'!createSlice	| changeset |	changeset := ChangeSet basicNewNamed: 'test'.	changeset		atClass: #MDBogusA add: #comment;		atClass: #MDSliceTest add: #comment;		changeClass: MDBogusA from: MDBogusA;		changeClass: MDBogusA class from: MDBogusA class;		noteNewMethod: nil forClass: MDSliceTest selector: #classes priorMethod: nil;		noteNewMethod: nil forClass: MDSliceTest selector: #methods priorMethod: nil;		noteNewMethod: nil forClass: MDSliceTest class selector: #bogusMethodA priorMethod: nil;		noteNewMethod: nil forClass: MDSliceTest class selector: #bogusMethodB priorMethod: nil.	^ MDChangeSetSlice on: changeset! !!MDChangeSetSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 14:21'!testLoad	| properties |	properties := MDPropertyDictionary new		name: 'SliceByAnotherName';		yourself.	slice load: properties.	self assert: slice name = 'SliceByAnotherName'! !!MDChangeSetSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 21:49'!testName	self assert: slice name = 'test'! !!MDChangeSetSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 22:14'!testProperties	| properties |	properties := slice properties.	self assert: properties name = 'test'.	self assert: properties type = #ChangeSet! !MDProxyTest subclass: #MDChangeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDChangeTest instVarNames includes: 'wc') ifFalse:	[MDChangeTest addInstVarName: 'wc']!!MDChangeTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/27/2008 06:58'!setUp	super setUp.	wc := MDWorkingCopy forDomain: proxy! !!MDChangeTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 16:29'!testAddition	| change element |	element := self element.	self atProperty: #one put: 'beta'.	change := wc changeForElement: element do: [:v | v].	self assert: (change version isKindOf: MDNullVersion).	self assert: change variant element = element.	self assert: change variant properties one = 'beta'! !!MDChangeTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 16:29'!testModification	| version change |	version := self versionWith: 'alpha'.	wc loadVersion: version.	self atProperty: #one put: 'beta'.	change := wc changeForElement: version element do: [:v | v].	self assert: change version = version.	self assert: change variant element = version element.	self assert: change variant properties one = 'beta'! !!MDChangeTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 16:30'!testNoChange	| version change |	version := self versionWith: 'alpha'.	wc loadVersion: version.	change := wc changeForElement: version element do: [:v | self fail].	self assert: change isNil! !!MDChangeTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 16:32'!testRemoval	| version change |	version := self versionWith: 'alpha'.	wc loadVersion: version.	proxy removeElement: version element.	change := wc changeForElement: version element do: [:v | v].	self assert: change version = version.	self assert: change variant isRemoval! !MDClassAwareElement subclass: #MDClassAwareNamedElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!(MDClassAwareNamedElement instVarNames includes: 'name') ifFalse:	[MDClassAwareNamedElement addInstVarName: 'name']!!MDClassAwareNamedElement methodsFor: 'comparing' stamp: 'dc 6/14/2007 05:43'!= other	^ super = other		and: [self name = other name]! !!MDClassAwareNamedElement methodsFor: 'comparing' stamp: 'dc 6/14/2007 05:43'!hash	^ super hash bitXor: name hash! !!MDClassAwareNamedElement methodsFor: 'accessing' stamp: 'dc 6/14/2007 05:43'!name	^ name! !!MDClassAwareNamedElement methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 05:44'!setClassName: aSymbol name: aString	theClassName := aSymbol.	name := aString! !!MDClassAwareNamedElement class methodsFor: 'intance creation' stamp: 'dc 6/14/2007 05:42'!className: aSymbol name: aString	^ self new		setClassName: aSymbol name: aString;		yourself! !MDClassAwareElement subclass: #MDClassCommentElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDClassCommentElement commentStamp: 'cwp 5/7/2006 22:32' prior: 0!I am a reference to the comment of a particular class.theClassName - the name of the class to whose comment I refer!!MDClassCommentElement methodsFor: 'adapting' stamp: 'cwp 2/12/2005 14:03'!adaptedFor: anImageProxy	^ anImageProxy adaptorForClassCommentElement: self! !!MDClassCommentElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:07'!isIncludedInSlice: aSlice	^ aSlice includesClassComment: self! !!MDClassCommentElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:54'!printOn: aStream	aStream		nextPutAll: theClassName;		space;		nextPutAll: 'comment'! !MDClassAwareElement subclass: #MDClassElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDClassElement commentStamp: 'cwp 5/7/2006 22:34' prior: 0!I am a reference to a class.theClassName - the name of the class!!MDClassElement methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:20'!adaptedFor: anImageProxy	^ anImageProxy adaptorForClassElement: self! !!MDClassElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:10'!isIncludedInSlice: aSlice	^ aSlice includesClass: self! !!MDClassElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:52'!printOn: aStream	aStream nextPutAll: theClassName! !MDVariableChunk subclass: #MDClassInstVarChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 00:20'!classReference	^ element theClassName, ' class'! !!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:29'!definitionSelector	^ 'class addInstVarName:'! !!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 00:15'!listSelector	^ 'instVarNames'! !!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:35'!removalSelector	^ 'class removeInstVarName:'! !!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 23:02'!sortOrdinal	^ properties index printString! !!MDClassInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:52'!typeChar	^ $g! !MDVariableChunkTest subclass: #MDClassInstVarChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDClassInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:30'!expectedIndependentDefinition	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB class instVarNames includes: ''first'') ifFalse:		[BogusB class addInstVarName: ''first'']]!!'! !!MDClassInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 20:36'!expectedIndependentRemoval	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB class instVarNames includes: ''first'') ifTrue:		[BogusB class removeInstVarName: ''first'']]!!'! !!MDClassInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:28'!expectedSimpleDefinition	^ '(BogusB class instVarNames includes: ''first'') ifFalse:	[BogusB class addInstVarName: ''first'']!!'! !!MDClassInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 20:36'!expectedSimpleRemoval	^ '(BogusB class instVarNames includes: ''first'') ifTrue:	[BogusB class removeInstVarName: ''first'']!!'! !!MDClassInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:13'!setUp	chunk := MDClassInstVarChunk forElement: 				(MDClassInstVarElement className: #BogusB name: #first)! !MDVariableChunk subclass: #MDClassVarChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDClassVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:14'!definitionSelector	^ 'addClassVarName:'! !!MDClassVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 00:21'!listSelector	^ 'classVarNames'! !!MDClassVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:15'!removalSelector	^ 'removeClassVarName:'! !!MDClassVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:51'!typeChar	^ $d! !MDVariableChunkTest subclass: #MDClassVarChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDClassVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 22:23'!expectedIndependentDefinition	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB classVarNames includes: ''First'') ifFalse:		[BogusB addClassVarName: ''First'']]!!'! !!MDClassVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:23'!expectedIndependentRemoval	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB classVarNames includes: ''First'') ifTrue:		[BogusB removeClassVarName: ''First'']]!!'! !!MDClassVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 22:55'!expectedSimpleDefinition	^ '(BogusB classVarNames includes: ''First'') ifFalse:	[BogusB addClassVarName: ''First'']!!'! !!MDClassVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:22'!expectedSimpleRemoval	^ '(BogusB classVarNames includes: ''First'') ifTrue:	[BogusB removeClassVarName: ''First'']!!'! !!MDClassVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:13'!setUp	chunk := MDClassVarChunk forElement: 				(MDClassVarElement className: #BogusB name: #First)! !MDRepository subclass: #MDDirectoryRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Directory'!(MDDirectoryRepository instVarNames includes: 'name') ifFalse:	[MDDirectoryRepository addInstVarName: 'name']!(MDDirectoryRepository instVarNames includes: 'directory') ifFalse:	[MDDirectoryRepository addInstVarName: 'directory']!(MDDirectoryRepository instVarNames includes: 'primary') ifFalse:	[MDDirectoryRepository addInstVarName: 'primary']!(MDDirectoryRepository instVarNames includes: 'secondary') ifFalse:	[MDDirectoryRepository addInstVarName: 'secondary']!(MDDirectoryRepository instVarNames includes: 'primaryName') ifFalse:	[MDDirectoryRepository addInstVarName: 'primaryName']!!MDDirectoryRepository methodsFor: 'private' stamp: 'cwp 8/21/2008 20:25'!addFileNamed: aString	| stream |	stream := directory oldFileNamed: aString.	secondary add: (MDFileRepository on: stream)! !!MDDirectoryRepository methodsFor: 'synchronization' stamp: 'cwp 8/21/2008 20:13'!allHashstamps	| hashstamps |	self scanDirectory.	hashstamps := primary allHashstamps asSet.	secondary do: [:ea | hashstamps addAll: ea allHashstamps].	^ hashstamps! !!MDDirectoryRepository methodsFor: 'public' stamp: 'jf 10/25/2008 13:30'!close	super close.	primary isNil ifFalse: [primary close].	secondary isNil ifFalse: [secondary do: [:each | each close]]! !!MDDirectoryRepository methodsFor: 'initialize-release' stamp: 'cwp 10/25/2008 14:55'!createDirectory	directory assureExistence.	self setPrimary: (MDFileRepository on: (directory newFileNamed: self primaryName)).! !!MDDirectoryRepository methodsFor: 'private' stamp: 'cwp 8/21/2008 20:10'!entryIsSecondary: entry 	^ entry isDirectory not 		and: [ (entry name endsWith: '.mcr') 			and: [ entry name ~= primary name ] ]! !!MDDirectoryRepository methodsFor: 'private' stamp: 'cwp 8/21/2008 20:19'!fileNames	^ directory entries 		inject: Set new		into: 			[ :set :entry | 			(self entryIsSecondary: entry) ifTrue: [set add: entry name].			set ].	! !!MDDirectoryRepository methodsFor: 'public' stamp: 'cwp 8/21/2008 20:12'!get: aHashstamp	^ (primary get: aHashstamp) ifNil:		[self scanDirectory.		secondary do: [:ea | (ea get: aHashstamp) ifNotNilDo: [:obj | ^ obj]].		nil]! !!MDDirectoryRepository methodsFor: 'synchronization' stamp: 'cwp 8/21/2008 20:13'!includes: aHashstamp	^ (primary includes: aHashstamp) or: 		[self scanDirectory.		secondary anySatisfy: [:ea | ea includes: aHashstamp]]! !!MDDirectoryRepository methodsFor: 'initialize-release' stamp: 'cwp 10/21/2008 07:42'!initFiles	primaryName := MDVolatileValue new.	secondary := Set new.	directory exists 		ifTrue: 			[self openPrimary. 			self scanDirectory]		ifFalse: 			[self createDirectory]! !!MDDirectoryRepository methodsFor: 'public' stamp: 'cwp 8/21/2008 20:12'!memos	| memos |	memos := primary memos.	self scanDirectory.	secondary do: [:ea | memos addAll: ea memos].	^ memos! !!MDDirectoryRepository methodsFor: 'accessing' stamp: 'cwp 8/17/2008 21:43'!name	^ name! !!MDDirectoryRepository methodsFor: 'private' stamp: 'cwp 10/25/2008 14:54'!openPrimary	| filename |	filename := self primaryName.	self setPrimary: (MDFileRepository on: (directory fileNamed: filename)). ! !!MDDirectoryRepository methodsFor: 'accessing' stamp: 'cwp 10/21/2008 07:41'!primaryName	^ primaryName value ifNil:		[primaryName value: UUID new printString, '.mcr']! !!MDDirectoryRepository methodsFor: 'accessing' stamp: 'cwp 10/27/2008 23:37'!properties: properties	| newName parent |	newName := properties name.	directory 		ifNil: [parent := FileDirectory default]		ifNotNil: 			[self close.			parent := directory containingDirectory.			parent rename: name toBe: newName].	name := newName.	directory := parent directoryNamed: name.	self initFiles.	! !!MDDirectoryRepository methodsFor: 'public' stamp: 'cwp 8/17/2008 22:41'!put: anObject	primary put: anObject! !!MDDirectoryRepository methodsFor: 'private' stamp: 'cwp 8/20/2008 22:19'!scanDirectory	| filenames reponames |	filenames := self fileNames.	reponames := secondary collect: [ :ea | ea name ].	filenames do: [ :ea | (reponames includes: ea) ifFalse: [ self addFileNamed: ea ] ].	secondary removeAllSuchThat: [ :ea | (filenames includes: ea name) not ]! !!MDDirectoryRepository methodsFor: 'initialize-release' stamp: 'cwp 8/21/2008 20:23'!setDirectory: aDirectory 	directory := aDirectory.	name := aDirectory localName.	self initFiles.	self initId! !!MDDirectoryRepository methodsFor: 'initialize-release' stamp: 'cwp 8/20/2008 20:52'!setName: aString 	name := aString.	directory := FileDirectory default directoryNamed: aString.	self initFiles.	self initId! !!MDDirectoryRepository methodsFor: 'initialize-release' stamp: 'jf 10/25/2008 13:28'!setPrimary: aFileRepository	primary isNil ifFalse: [primary close].	primary := aFileRepository! !!MDDirectoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 8/17/2008 21:42'!named: aString	^ self new setName: aString! !!MDDirectoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 8/18/2008 20:00'!on: aDirectory	^ self new setDirectory: aDirectory! !!MDDirectoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 10/27/2008 22:36'!type	^ #McrDirectory! !MDElementChange subclass: #MDElementAdded	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!MDElementChange subclass: #MDElementModified	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!MDElementChange subclass: #MDElementRemoved	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!MDVersion subclass: #MDElementVersion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!(MDElementVersion instVarNames includes: 'variant') ifFalse:	[MDElementVersion addInstVarName: 'variant']!(MDElementVersion instVarNames includes: 'ancestry') ifFalse:	[MDElementVersion addInstVarName: 'ancestry']!!MDElementVersion methodsFor: 'accessing' stamp: 'avi 11/29/2004 13:53'!ancestry	^ ancestry! !!MDElementVersion methodsFor: 'accessing' stamp: 'cwp 10/16/2005 13:50'!element	^variant element! !!MDElementVersion methodsFor: 'accessing' stamp: 'cwp 3/23/2005 23:15'!fullAncestry	^ancestry copyWith: self hashstamp! !!MDElementVersion methodsFor: 'comparing' stamp: 'cwp 3/23/2005 23:15'!precedes: aVersion 	^aVersion ancestry includes: self hashstamp! !!MDElementVersion methodsFor: 'conflicts' stamp: 'cwp 10/16/2005 14:07'!resolveConflictWith: aVersion in: anImageProxy using: twoArgBlock 	(self variant autoMergeWith: aVersion variant in: anImageProxy) 		ifNotNilDo: [:snap | ^snap].	^twoArgBlock value: self value: aVersion! !!MDElementVersion methodsFor: 'initialize-release' stamp: 'cwp 10/16/2005 14:15'!setVariant: aVariant ancestry: aCollection timestamp: aTimestamp 	variant := aVariant.	ancestry := aCollection.	cache := aTimestamp.	self initHashstamp! !!MDElementVersion methodsFor: 'accessing' stamp: 'cwp 10/16/2005 13:50'!variant	^variant! !!MDElementVersion class methodsFor: 'instance creation' stamp: 'cwp 10/16/2005 14:19'!variant: aVariant 	^self variant: aVariant ancestry: Set new! !!MDElementVersion class methodsFor: 'instance creation' stamp: 'cwp 10/16/2005 14:18'!variant: aVariant ancestry: aSet 	^self 		variant: aVariant		ancestry: aSet		timestamp: MDTimestamp now! !!MDElementVersion class methodsFor: 'instance creation' stamp: 'cwp 10/16/2005 14:18'!variant: aVariant ancestry: aSet timestamp: aTimeStamp 	^self basicNew 		setVariant: aVariant		ancestry: aSet		timestamp: aTimeStamp! !MDSlice subclass: #MDExplicitSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Slices'!(MDExplicitSlice instVarNames includes: 'name') ifFalse:	[MDExplicitSlice addInstVarName: 'name']!(MDExplicitSlice instVarNames includes: 'elements') ifFalse:	[MDExplicitSlice addInstVarName: 'elements']!!MDExplicitSlice methodsFor: 'accessing' stamp: 'cwp 2/27/2005 18:54'!addElement: anElement	elements add: anElement! !!MDExplicitSlice methodsFor: 'enumerating' stamp: 'cwp 1/18/2007 23:59'!elementsDo: aBlock	elements do: aBlock.! !!MDExplicitSlice methodsFor: 'testing' stamp: 'cwp 8/28/2005 23:34'!includes: anElement	^ elements includes: anElement! !!MDExplicitSlice methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:21'!load: properties 	name := properties name.	elements := properties elements ifNil: [ Set new ]! !!MDExplicitSlice methodsFor: 'accessing' stamp: 'cwp 3/15/2005 22:26'!name	^ name! !!MDExplicitSlice methodsFor: 'initialize-release' stamp: 'cwp 12/29/2006 17:53'!setName: aString	^ self setName: aString elements: Set new! !!MDExplicitSlice methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 07:48'!setName: aString elements: aSet	name := aString.	elements := aSet.	self initId.! !!MDExplicitSlice methodsFor: 'accessing' stamp: 'cwp 5/29/2008 07:57'!update: properties	super update: properties.	properties elements: elements.	^ properties! !!MDExplicitSlice class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 07:39'!basedOn: aSlice	^ self new 			setName: aSlice name 			elements: aSlice elements;		yourself! !!MDExplicitSlice class methodsFor: 'instance creation' stamp: 'cwp 12/31/2006 18:32'!forDefinition: properties	^ self named: properties name! !!MDExplicitSlice class methodsFor: 'instance creation' stamp: 'cwp 6/7/2008 13:46'!forTesting	^ self named: 'TestSlice'! !!MDExplicitSlice class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 07:38'!named: aString	^ self new		setName: aString;		yourself! !!MDExplicitSlice class methodsFor: 'accessing' stamp: 'cwp 3/15/2005 22:33'!type	^ #Explicit! !MDSmalltalkSliceTest subclass: #MDExplicitSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDExplicitSliceTest methodsFor: 'constucting' stamp: 'cwp 10/2/2008 20:24'!createSlice	^ (MDExplicitSlice named: 'TestSlice')		addElement: (MDClassElement className: #MDBogusA);		addElement: (MDClassElement className: #MDSliceTest);		addElement: (MDClassCommentElement className: #MDBogusA);		addElement: (MDClassCommentElement className: #MDSliceTest);		addElement: (MDMethodElement 				className: #MDSliceTest				selector: #classes);		addElement: (MDMethodElement 				className: #MDSliceTest				selector: #methods);		addElement: (MDMethodElement 				className: #MDSliceTest				selector: #bogusMethodA				classIsMeta: true);		addElement: (MDMethodElement 				className: #MDSliceTest				selector: #bogusMethodB				classIsMeta: true);		addElement: (MDInstVarElement 				className: #MDBogusA				name: 'one');		addElement: (MDClassVarElement 				className: #MDBogusA				name: 'MDAlpha');		addElement: (MDClassInstVarElement 				className: #MDBogusA				name: 'aleph');		addElement: (MDPoolImportElement 				className: #MDBogusA				name: 'MDBogusPoolA');		addElement: (MDPoolImportElement 				className: #MDBogusA				name: 'TextConstants');		yourself! !!MDExplicitSliceTest methodsFor: 'tests' stamp: 'cwp 5/31/2008 14:21'!testLoad	| properties |	properties := MDPropertyDictionary new		name: 'SliceByADifferentName';		elements: Set new;		yourself.	slice load: properties.	self assert: slice name = 'SliceByADifferentName'.	self assert: slice elements isEmpty! !!MDExplicitSliceTest methodsFor: 'tests' stamp: 'cwp 5/28/2008 21:19'!testProperties	| properties |	properties := slice properties.	self assert: properties name = 'TestSlice'.	self assert: properties elements = slice elements! !MDRepository subclass: #MDFileRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-File'!(MDFileRepository instVarNames includes: 'dataStream') ifFalse:	[MDFileRepository addInstVarName: 'dataStream']!(MDFileRepository instVarNames includes: 'index') ifFalse:	[MDFileRepository addInstVarName: 'index']!(MDFileRepository instVarNames includes: 'memos') ifFalse:	[MDFileRepository addInstVarName: 'memos']!(MDFileRepository instVarNames includes: 'lastPosition') ifFalse:	[MDFileRepository addInstVarName: 'lastPosition']!!MDFileRepository methodsFor: 'comparing' stamp: 'cwp 12/25/2006 15:22'!= other	^ self species = other species		and: [other dataStreamIs: dataStream]! !!MDFileRepository methodsFor: 'synchronization' stamp: 'cwp 12/23/2007 00:11'!allHashstamps	self rescanData.	^ index keys collect: [:ea | MDHashstamp fromBytes: ea]! !!MDFileRepository methodsFor: 'public' stamp: 'cwp 10/13/2005 23:01'!close	dataStream close! !!MDFileRepository methodsFor: 'private' stamp: 'cwp 12/25/2006 15:23'!dataStreamIs: aStream	^ dataStream = aStream! !!MDFileRepository methodsFor: 'private' stamp: 'cwp 10/22/2008 20:44'!flushIndex		lastPosition := 0.	index := Dictionary new.	memos := Set new.	! !!MDFileRepository methodsFor: 'public' stamp: 'cwp 10/22/2008 20:45'!get: aHashstamp 	| key bytes position |	key := aHashstamp bytes.	position := index at: key ifAbsent: [^self rescanData ifTrue: [self get: aHashstamp]].	bytes := dataStream valueAtPosition: position.	bytes ifNil:		[self flushIndex.		self rescanData.		bytes := dataStream valueAtPosition: position].	^ bytes ifNotNil: [MDMarshal materialize: bytes]! !!MDFileRepository methodsFor: 'comparing' stamp: 'cwp 12/25/2006 15:25'!hash	^ dataStream hash! !!MDFileRepository methodsFor: 'synchronization' stamp: 'cwp 12/23/2007 00:12'!includes: aHashstamp	self rescanData.	^ index includesKey: aHashstamp bytes! !!MDFileRepository methodsFor: 'initialize-release' stamp: 'cwp 7/27/2008 14:46'!initializeWithStream: aFileStream 	self setStream: aFileStream.	self initId! !!MDFileRepository methodsFor: 'public' stamp: 'cwp 1/19/2007 20:57'!memos		self rescanData.	^ memos! !!MDFileRepository methodsFor: 'public' stamp: 'cwp 5/31/2008 14:43'!name	^ dataStream stream localName! !!MDFileRepository methodsFor: 'accessing' stamp: 'jf 10/25/2008 13:45'!properties: properties 	| oldName newName |	newName := properties name.	dataStream		ifNil: [self initializeWithStream: (FileDirectory default fileNamed: newName)]		ifNotNil:			[oldName := dataStream stream localName.			oldName = properties name ifFalse: 				[ | directory |				directory := dataStream stream directory.				self close.				directory rename: oldName toBe: newName.				self initializeWithStream: (directory oldFileNamed: newName)]]! !!MDFileRepository methodsFor: 'public' stamp: 'dc 6/14/2007 07:18'!put: aHashedObject	| key value |	key := aHashedObject hashstamp bytes.	index at: key ifAbsent:		[value := MDMarshal serialize: aHashedObject.		index at: key put: dataStream nextValuePosition.		dataStream appendKey: key value: value.		dataStream flush]! !!MDFileRepository methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!rescanData	dataStream reopen.	dataStream fromPosition: lastPosition keysValuesAndPositionsDo:  		[:key :val :pos |		index at: key put: pos.		(MDMarshal isMemo:val) ifTrue:			[memos add: (MDMarshal materialize: val)]].	dataStream position = lastPosition		ifTrue: [^ false]		ifFalse: [lastPosition := dataStream position. ^ true]! !!MDFileRepository methodsFor: 'initialize-release' stamp: 'cwp 7/27/2008 14:46'!setStream: aFileStream 	dataStream := MDKeyedStream on: aFileStream.	lastPosition := 0.	index := Dictionary new.	memos := Set new.	self rescanData! !!MDFileRepository class methodsFor: 'accessing' stamp: 'cwp 10/12/2005 21:30'!extension	^ '.mcr'! !!MDFileRepository class methodsFor: 'instance creation' stamp: 'cwp 2/2/2006 22:20'!named: aString	^ self on: (FileStream fileNamed: aString, self extension)! !!MDFileRepository class methodsFor: 'instance creation' stamp: 'dc 7/19/2007 10:41'!named: aString do: aBlock	^ self		on: (FileStream fileNamed: aString, self extension)		do: aBlock! !!MDFileRepository class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 06:50'!on: aFileStream	^ self new		initializeWithStream: aFileStream;		yourself! !!MDFileRepository class methodsFor: 'instance creation' stamp: 'dc 7/19/2007 10:41'!on: aFileStream do: aBlock	|repos|	repos := self new				initializeWithStream: aFileStream;				yourself.	^ [aBlock value: repos]		ensure: [repos close]! !!MDFileRepository class methodsFor: 'class initialization' stamp: 'cwp 10/22/2008 20:47'!startUp	"Do nothing. This is implemented because old versions registered	to be notified at start up, and that registration might still be in effect."! !!MDFileRepository class methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:49'!type	^ #McrFile! !MDEmptyMessage subclass: #MDGetHashstamps	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDGetHashstamps methodsFor: 'as yet unclassified' stamp: 'cwp 1/8/2008 18:42'!handledBy: anObject	^ anObject handleGetHashstamps: self! !!MDGetHashstamps class methodsFor: 'as yet unclassified' stamp: 'cwp 1/8/2008 18:02'!id	^ 68! !MDEmptyMessage subclass: #MDGetMemos	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDGetMemos methodsFor: 'dispatch' stamp: 'cwp 1/4/2008 22:11'!handledBy: anObject	^ anObject handleGetMemos: self! !!MDGetMemos class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:44'!id	^ 67! !MDHashstampMessage subclass: #MDGetObjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDGetObjects methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 21:28'!handledBy: aService	^ aService handleGet: self! !!MDGetObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:43'!id	^ 64! !MDSalutationMessage subclass: #MDGoodbye	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDGoodbye methodsFor: 'dispatch' stamp: 'cwp 1/4/2008 22:25'!handledBy: anObject	^ anObject handleGoodbye: anObject! !!MDGoodbye methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 14:17'!isGoodbye	^ true! !!MDGoodbye class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:40'!id	^ 2! !MDSalutationMessage subclass: #MDHello	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDHello methodsFor: 'dispatch' stamp: 'cwp 1/4/2008 22:08'!handledBy: anObject	^ anObject handleHello: self! !!MDHello methodsFor: 'testing' stamp: 'cwp 1/4/2008 12:36'!isHello	^ true! !!MDHello class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:39'!id	^ 1! !MDProxyTest subclass: #MDImageProxyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:21'!testCurrentDefinition	| variant |	self 		atElement: self element		property: #one		put: 1.	variant := self definition.	proxy updateVariant: variant.	self assert: (variant properties at: #one) = 1! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testIsLoadable	| variant |	variant := self definition.	variant properties at: #one put: 1.	self assert: (proxy isLoadable: variant)! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:16'!testLoadAndUpdate	| original retrieved |	original := self definition.	(original properties)		at: #one put: 1;		at: #two put: 2;		at: #three put: 3.	proxy loadVariant: original.	retrieved := proxy updateVariant: self definition.	self assert: original properties = retrieved properties! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:16'!testLoadAndUpdateRemoval	| original retrieved |	original := self definition.	(original properties)		at: #one put: 1;		at: #two put: 2;		at: #three put: 3.	proxy loadVariant: original.	retrieved := proxy updateVariant: self removal.	self assert: retrieved properties = original properties! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:21'!testLoadDefinition	| variant |	variant := self definition.	(variant properties)		at: #one put: 1;		at: #two put: 2;		at: #three put: 3.	proxy loadVariant: variant.	self assert: (self atElement: self element property: #one) = 1.	self assert: (self atElement: self element property: #two) = 2.	self assert: (self atElement: self element property: #three) = 3! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:16'!testLoadRemoveAndUpdate	| original retrieved |	original := self definition.	(original properties)		at: #one put: 1;		at: #two put: 2;		at: #three put: 3.	proxy loadVariant: original.	proxy loadVariant: self removal.	retrieved := proxy updateVariant: self definition.	self assert: retrieved element = self element.	self assert: retrieved isRemoval! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testNotLoadable	| variant |	variant := self definition: #'Alpha/Delta'.	variant properties at: #one put: 1.	self deny: (proxy isLoadable: variant)! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:22'!testRemoval	| variant |	self 		atElement: self element		property: #one		put: '1'.	variant := self removal.	proxy loadVariant: variant.	self assert: (self atElement: self element property: #one) isNil! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testRemovalLoadable	| variant |	variant := self removal: #'Alpha/Delta'.	self assert: (proxy isLoadable: variant)! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:22'!testRemovalUpToDate	| variant removal |	variant := self definition.	removal := self removal.	variant properties one: '1'.	proxy loadVariant: variant.	self deny: (proxy isUpToDate: removal).	proxy loadVariant: removal.	self assert: (proxy isUpToDate: removal)! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:24'!testTransaction	| variant |	variant := self definition.	variant properties at: #one put: 1.	proxy transaction: [proxy loadVariant: variant].	self assert: (self atElement: self element property: #one) = 1.! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:22'!testUpToDate	| variant |	variant := self definition.	variant properties source: 'one ^ 1'.	proxy loadVariant: variant.	self assert: (proxy isUpToDate: variant).	self 		atElement: self element		property: #source		put: 'one ^ 11'.	self deny: (proxy isUpToDate: variant)! !!MDImageProxyTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 18:22'!testUpdateDoesntChangeElement	| variant original |	variant := self definition.	original := variant element.	proxy updateVariant: variant.	self assert: variant element = original! !MDVariableChunk subclass: #MDInstVarChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:15'!definitionSelector	^ 'addInstVarName:'! !!MDInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 00:22'!listSelector	^ 'instVarNames'! !!MDInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/29/2008 22:16'!removalSelector	^ 'removeInstVarName:'! !!MDInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 5/20/2008 22:50'!sortOrdinal	^ properties index printString! !!MDInstVarChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:48'!typeChar	^ $c! !MDVariableChunkTest subclass: #MDInstVarChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:40'!expectedIndependentDefinition	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB instVarNames includes: ''first'') ifFalse:		[BogusB addInstVarName: ''first'']]!!'! !!MDInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 20:38'!expectedIndependentRemoval	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB instVarNames includes: ''first'') ifTrue:		[BogusB removeInstVarName: ''first'']]!!'! !!MDInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:41'!expectedSimpleDefinition	^ '(BogusB instVarNames includes: ''first'') ifFalse:	[BogusB addInstVarName: ''first'']!!'! !!MDInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 20:31'!expectedSimpleRemoval	^ '(BogusB instVarNames includes: ''first'') ifTrue:	[BogusB removeInstVarName: ''first'']!!'! !!MDInstVarChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:15'!setUp	chunk := MDInstVarChunk forElement: (MDInstVarElement 			className: #BogusB			name: #first)! !MDPropertiesDefintion subclass: #MDMemoDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDMemoDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 15:31'!properties	^ object properties copy		removeKey: #initials ifAbsent: [];		removeKey: #ordinal ifAbsent: [];		removeKey: #comment ifAbsent: [];		removeKey: #sliceName ifAbsent: [];		yourself! !!MDMemoDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 15:31'!text	^ String streamContents: 		[:stream |		self printPropertiesOn: stream.		stream cr.		object properties comment ifNotNilDo: [:c | stream nextPutAll: c]]! !MDRepository subclass: #MDMemoryRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Repositories'!(MDMemoryRepository instVarNames includes: 'name') ifFalse:	[MDMemoryRepository addInstVarName: 'name']!(MDMemoryRepository instVarNames includes: 'versions') ifFalse:	[MDMemoryRepository addInstVarName: 'versions']!!MDMemoryRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:46'!allHashstamps	^ versions keys! !!MDMemoryRepository methodsFor: 'public' stamp: 'cwp 5/23/2006 20:16'!get: aHashstamp	^ versions at: aHashstamp ifAbsent: [nil]! !!MDMemoryRepository methodsFor: 'synchronization' stamp: 'cwp 12/22/2007 23:48'!includes: aHashstamp	^ versions includesKey: aHashstamp! !!MDMemoryRepository methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 07:03'!initialize	versions := Dictionary new.! !!MDMemoryRepository methodsFor: 'public' stamp: 'cwp 1/19/2007 20:51'!memos	^ versions values select: [:ea | ea isMemo]		! !!MDMemoryRepository methodsFor: 'initialize-release' stamp: 'cwp 5/31/2008 14:41'!name	^ name! !!MDMemoryRepository methodsFor: 'accessing' stamp: 'cwp 5/31/2008 18:00'!properties: properties	name := properties name! !!MDMemoryRepository methodsFor: 'public' stamp: 'cwp 3/10/2005 20:20'!put: anElementVersion	versions at: anElementVersion hashstamp put: anElementVersion! !!MDMemoryRepository methodsFor: 'initialize-release' stamp: 'cwp 5/24/2008 12:47'!setName: aString	name := aString.	self initId! !!MDMemoryRepository methodsFor: 'accessing' stamp: 'cwp 8/7/2005 21:57'!versions	^ versions! !!MDMemoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 7/28/2008 21:10'!forTesting	^ self named: 'forTesting'! !!MDMemoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:47'!named: aString	^ self new setName: aString! !!MDMemoryRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 14:49'!type	^ #Memory! !MDObjectsMessage subclass: #MDMemos	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDMemos methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 14:24'!isMemos	^ true! !!MDMemos class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:45'!id	^ 131! !MDProxyTest subclass: #MDMergeTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDMergeTest instVarNames includes: 'wc') ifFalse:	[MDMergeTest addInstVarName: 'wc']!(MDMergeTest instVarNames includes: 'merge') ifFalse:	[MDMergeTest addInstVarName: 'merge']!(MDMergeTest instVarNames includes: 'local') ifFalse:	[MDMergeTest addInstVarName: 'local']!(MDMergeTest instVarNames includes: 'remote') ifFalse:	[MDMergeTest addInstVarName: 'remote']!!MDMergeTest methodsFor: 'running' stamp: 'cwp 3/25/2005 22:26'!local: localVersion remote: remoteVersion	local := localVersion.	wc loadVersion: local.	remote := remoteVersion.	merge := MDMerge toInclude: remote in: wc.! !!MDMergeTest methodsFor: 'running' stamp: 'cwp 5/27/2008 06:58'!setUp	super setUp.	wc := MDWorkingCopy forDomain: proxy! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 12/12/2007 10:17'!testApplyLocal	self 		local: (self versionWith: 'local')		remote: (self versionWith: 'remote').	merge chooseLocal.	merge applyTo: wc.	self assertElementHasValue: 'local'! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 12/12/2007 10:11'!testApplyRemote	self 		local: (self versionWith: 'local')		remote: (self versionWith: 'remote').	merge chooseRemote.	merge applyTo: wc.	self assertElementHasValue: 'remote'! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:05'!testChooseLocal	self local: self version remote: self version.	self assert: merge isConflict.	merge chooseLocal.	self assert: merge isLocal.	self assert: merge resolution == local! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:06'!testChooseRemote	self local: self version remote: self version.	self assert: merge isConflict.	merge chooseRemote.	self assert: merge isRemote.	self assert: merge resolution == remote! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 5/26/2006 16:36'!testIsConflict	self local: self version remote: self version.	self assert: merge isConflict.	self assert: merge isLocal.	self deny: merge isRemote.! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testIsLocal	remote := self version.	local := self updateVersion: remote property: #one put: 'alpha2'.	self local: local remote: remote.	self assert: merge isLocal.	self deny: merge isRemote.	self deny: merge isConflict.! !!MDMergeTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testIsRemote	local := self version.	remote := self updateVersion: local property: #one put: 'alpha2'.	self local: local remote: remote.	self assert: merge isRemote.	self deny: merge isLocal.	self deny: merge isConflict.! !MDClassAwareElement subclass: #MDMethodElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!(MDMethodElement instVarNames includes: 'selector') ifFalse:	[MDMethodElement addInstVarName: 'selector']!(MDMethodElement instVarNames includes: 'classIsMeta') ifFalse:	[MDMethodElement addInstVarName: 'classIsMeta']!!MDMethodElement methodsFor: 'comparing' stamp: 'cwp 3/16/2008 21:42'!= other 	^ super = other		and: [self selector = other selector]		and: [self classIsMeta = other classIsMeta]! !!MDMethodElement methodsFor: 'adapting' stamp: 'cwp 2/3/2005 22:09'!adaptedFor: anImageProxy	^ anImageProxy adaptorForMethodElement: self! !!MDMethodElement methodsFor: 'accessing' stamp: 'cwp 2/12/2005 15:25'!classIsMeta	^ classIsMeta! !!MDMethodElement methodsFor: 'comparing' stamp: 'cwp 3/16/2008 21:59'!hash	^ self printString hash! !!MDMethodElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:18'!isIncludedInSlice: aSlice	^ aSlice includesMethod: self! !!MDMethodElement methodsFor: 'accessing' stamp: 'cwp 8/28/2005 17:15'!name	^ selector! !!MDMethodElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:59'!printOn: aStream	aStream nextPutAll: self theClassName.	self classIsMeta ifTrue: [aStream nextPutAll: ' class'].	aStream 		nextPutAll: '>>';		nextPutAll: self selector! !!MDMethodElement methodsFor: 'accessing' stamp: 'avi 11/28/2004 16:26'!selector	^ selector! !!MDMethodElement methodsFor: 'initialize-release' stamp: 'cwp 2/12/2005 15:15'!setClassName: aString selector: aSymbol classIsMeta: aBoolean	theClassName := aString.	selector := aSymbol.	classIsMeta := aBoolean! !!MDMethodElement class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 05:50'!className: aString selector: aSymbol 	^ self className: aString selector: aSymbol classIsMeta: false! !!MDMethodElement class methodsFor: 'instance creation' stamp: 'dc 6/14/2007 05:50'!className: aString selector: aSymbol classIsMeta: aBoolean	^ self new		setClassName: aString selector: aSymbol classIsMeta: aBoolean;		yourself! !MDSlice subclass: #MDMonticelloSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Slices'!(MDMonticelloSlice instVarNames includes: 'project') ifFalse:	[MDMonticelloSlice addInstVarName: 'project']!!MDMonticelloSlice methodsFor: 'as yet unclassified' stamp: 'cwp 11/10/2008 06:23'!includes: anElement	^ anElement isIncludedInSlice: self! !!MDMonticelloSlice methodsFor: 'as yet unclassified' stamp: 'cwp 11/10/2008 06:22'!name	self subclassResponsibility! !!MDMonticelloSlice methodsFor: 'as yet unclassified' stamp: 'cwp 11/10/2008 06:19'!setProject: aProject	project := aProject.	self initId! !!MDMonticelloSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 11/10/2008 06:26'!on: aProject	^ self new setProject: aProject! !MDRepository subclass: #MDNetRepository	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!(MDNetRepository instVarNames includes: 'link') ifFalse:	[MDNetRepository addInstVarName: 'link']!!MDNetRepository methodsFor: 'synchronization' stamp: 'cwp 5/22/2008 00:11'!allHashstamps	| result |	result := self send: MDGetHashstamps new.	result assertMessageIs: MDAllHashstamps.	^ result hashstamps! !!MDNetRepository methodsFor: 'public' stamp: 'jf 10/25/2008 13:39'!close	| bye |	link isOpen ifTrue: [		bye := link send: MDGoodbye new.		link close.		bye assertMessageIs: MDGoodbye ]! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!get: aHashstamp	| objects |	objects := self getAll: (Set with: aHashstamp).	^ objects isEmpty ifFalse: [objects anyOne]! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!getAll: aCollection	| result |	result := self send: (MDGetObjects with: aCollection).	result assertMessageIs: MDObjects.	^ result objects! !!MDNetRepository methodsFor: 'synchronization' stamp: 'cwp 1/8/2008 18:45'!includes: aHashstamp	^ (self get: aHashstamp) notNil! !!MDNetRepository methodsFor: 'accessing' stamp: 'cwp 1/21/2008 20:41'!locator	^ link locator! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!memos	| result |	result := self send: MDGetMemos new.	result assertMessageIs: MDMemos.	^ result objects! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/31/2008 14:44'!name	^ link description! !!MDNetRepository methodsFor: 'accessing' stamp: 'cwp 6/1/2008 01:24'!properties: properties	link := MDNetLink host: properties host port: properties port! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!put: anObject	| result |	result := self send: (MDPutObjects with: {anObject}). 	result assertMessageIs: MDThankYou! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!putAll: aCollection	| request |	request := self send: (MDOfferObjects withObjects: aCollection).	request assertMessageIs: MDRequestObjects.	request 		filter: aCollection		in: [:put | (self send: put) assertMessageIs: MDThankYou]! !!MDNetRepository methodsFor: 'public' stamp: 'cwp 5/22/2008 00:11'!selectFrom: aCollection	| request |	request := self send: (MDOfferObjects with: aCollection).	request assertMessageIs: MDRequestObjects.	^ request hashstamps! !!MDNetRepository methodsFor: 'private' stamp: 'cwp 5/22/2008 00:11'!send: aMessage	| result |	link isOpen ifFalse:		[link open.		result := link send: MDHello new.		result assertMessageIs: MDHello].	result := link send: aMessage.	result checkForError.	^ result! !!MDNetRepository methodsFor: 'private' stamp: 'cwp 5/24/2008 13:19'!setLink: aLink	link := aLink.	self initId! !!MDNetRepository methodsFor: 'accessing' stamp: 'cwp 6/5/2008 21:46'!update: properties	super update: properties.	^ self locator update: properties! !!MDNetRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 13:09'!host: aString	^ self link: (MDNetLink host: aString)! !!MDNetRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 1/20/2008 12:27'!host: aString port: anInteger	^ self link: (MDNetLink host: aString port: anInteger)! !!MDNetRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 12:23'!link: aLink	^ self new setLink: aLink! !!MDNetRepository class methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 14:51'!type	^ #Mnrp! !MDVersion subclass: #MDNullVersion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Versions'!(MDNullVersion instVarNames includes: 'element') ifFalse:	[MDNullVersion addInstVarName: 'element']!!MDNullVersion methodsFor: 'accessing' stamp: 'cwp 2/27/2005 22:24'!ancestry	^ Set new! !!MDNullVersion methodsFor: 'accessing' stamp: 'cwp 2/27/2005 21:36'!element	^ element! !!MDNullVersion methodsFor: 'accessing' stamp: 'cwp 2/27/2005 22:24'!fullAncestry	^ Set new! !!MDNullVersion methodsFor: 'comparing' stamp: 'cwp 2/28/2005 21:47'!precedes: anElementVersion 	^true! !!MDNullVersion methodsFor: 'initialize-release' stamp: 'dc 6/14/2007 08:10'!setElement: anElement	element := anElement.	self initHashstamp! !!MDNullVersion methodsFor: 'accessing' stamp: 'cwp 10/16/2005 14:17'!variant	^ MDRemovalVariant forElement: element! !!MDNullVersion class methodsFor: 'instance creation' stamp: 'cwp 2/27/2005 21:31'!forElement: anElement	^ self new setElement: anElement! !MDErrorMessage subclass: #MDObjectNotFound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDObjectNotFound class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:34'!id	^ 195! !MDObjectsMessage subclass: #MDObjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDObjects methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 12:39'!isObjects	^ true! !!MDObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:45'!id	^ 128! !MDHashstampMessage subclass: #MDOfferObjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDOfferObjects methodsFor: 'dispatch' stamp: 'cwp 1/4/2008 22:19'!handledBy: anObject	^ anObject handleOfferObjects: self! !!MDOfferObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:43'!id	^ 65! !!MDOfferObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:14'!withObjects: aCollection	^ self with: (aCollection collect: [:ea | ea hashstamp])! !MDSlice subclass: #MDPackageInfoSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Slices'!(MDPackageInfoSlice instVarNames includes: 'package') ifFalse:	[MDPackageInfoSlice addInstVarName: 'package']!!MDPackageInfoSlice methodsFor: 'private' stamp: 'cwp 5/21/2008 19:09'!class: aClass do: aBlock 	aBlock value: (MDClassElement className: aClass name).	aClass hasComment ifTrue: [ aBlock value: (MDClassCommentElement className: aClass name) ].	self 		names: aClass instVarNames		collect: 			[ :name | 			MDInstVarElement 				className: aClass name				name: name ]		into: aBlock.	self 		names: aClass classVarNames		collect: 			[ :name | 			MDClassVarElement 				className: aClass name				name: name ]		into: aBlock.	self 		names: aClass class instVarNames		collect: 			[ :name | 			MDClassInstVarElement 				className: aClass name				name: name ]		into: aBlock.	self 		names: aClass poolImportNames		collect: 			[ :name | 			MDPoolImportElement 				className: aClass name				name: name ]		into: aBlock! !!MDPackageInfoSlice methodsFor: 'private' stamp: 'cwp 3/3/2006 11:15'!classForElement: anElement	^ (Smalltalk classNamed: anElement theClassName)! !!MDPackageInfoSlice methodsFor: 'enumerating' stamp: 'cwp 1/18/2007 23:59'!elementsDo: aBlock	package classes do: [:class | self class: class do: aBlock].	package methods do: [:ea | aBlock value: ea asElement].! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 8/29/2005 01:06'!includes: anElement	^ anElement isIncludedInSlice: self! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 8/29/2005 01:10'!includesClass: anElement	^ package includesClassNamed: anElement theClassName! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 8/29/2005 01:09'!includesClassComment: anElement	^ package includesClassNamed: anElement theClassName! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 11/7/2007 00:33'!includesClassInstVar: anElement	^ (package includesClassNamed: anElement theClassName) and: 		[(self classForElement: anElement) class instVarNames includes: anElement name]! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 11/7/2007 00:36'!includesClassVar: anElement	^ (package includesClassNamed: anElement theClassName)		and: [(self classForElement: anElement) classVarNames includes: anElement name]! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 11/7/2007 00:35'!includesInstVar: anElement	^ (package includesClassNamed: anElement theClassName)		and: [(self classForElement: anElement) instVarNames includes: anElement name]! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 5/22/2008 00:13'!includesMethod: anElement	| ref |	ref := MethodReference new.	ref 		setClassSymbol: anElement theClassName		classIsMeta: anElement classIsMeta		methodSymbol: anElement selector		stringVersion: ''.	^ package includesMethodReference: ref! !!MDPackageInfoSlice methodsFor: 'testing' stamp: 'cwp 5/22/2008 00:13'!includesPoolImport: anElement	| pool |	^ (package includesClassNamed: anElement theClassName) and: 		[pool := Smalltalk at: anElement name ifAbsent: [0].		(self classForElement: anElement) sharedPools anySatisfy: 				[:ea | ea == pool]]! !!MDPackageInfoSlice methodsFor: 'accessing' stamp: 'cwp 6/15/2008 21:44'!load: properties	package := PackageInfo named: properties name! !!MDPackageInfoSlice methodsFor: 'accessing' stamp: 'cwp 3/15/2005 22:26'!name	^ package packageName! !!MDPackageInfoSlice methodsFor: 'private' stamp: 'cwp 3/3/2005 01:48'!names: aCollection collect: mapBlock into: doBlock	| elements |	elements := aCollection collect: mapBlock.	elements do: doBlock. 		! !!MDPackageInfoSlice methodsFor: 'initialize-release' stamp: 'cwp 5/22/2008 00:13'!setPackage: aPackage	package := aPackage.	self initId.! !!MDPackageInfoSlice class methodsFor: 'instance creation' stamp: 'abc 1/1/2007 01:03'!forDefinition: properties	^ self named: properties name! !!MDPackageInfoSlice class methodsFor: 'instance creation' stamp: 'cwp 3/3/2005 00:49'!forPackage: aPackage	^ self basicNew setPackage: aPackage! !!MDPackageInfoSlice class methodsFor: 'instance creation' stamp: 'cwp 8/28/2005 18:02'!named: aString	^ self forPackage: (PackageInfo named: aString)! !!MDPackageInfoSlice class methodsFor: 'accessing' stamp: 'cwp 3/15/2005 22:34'!type	^ #Package! !MDSmalltalkSliceTest subclass: #MDPackageSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDPackageSliceTest commentStamp: 'cwp 3/3/2005 02:10' prior: 0!This comment needs to be here, or #testComment won't pass.!!MDPackageSliceTest methodsFor: 'package info' stamp: 'cwp 8/29/2005 00:33'!classes	^ Array with: MDBogusA with: MDSliceTest! !!MDPackageSliceTest methodsFor: 'constructing' stamp: 'cwp 3/3/2006 14:23'!createSlice	^MDPackageInfoSlice forPackage: self! !!MDPackageSliceTest methodsFor: 'package info' stamp: 'cwp 8/29/2005 01:13'!includesClassNamed: aSymbol	^ self classes anySatisfy: [:ea | ea name = aSymbol]! !!MDPackageSliceTest methodsFor: 'package info' stamp: 'cwp 8/29/2005 01:30'!includesMethodReference: aMethodReference 	^ self methods includes: aMethodReference! !!MDPackageSliceTest methodsFor: 'package info' stamp: 'cwp 8/29/2005 00:43'!methods	^ Array		with: (MethodReference class: MDSliceTest selector: #classes)		with: (MethodReference class: MDSliceTest selector: #methods)		with: (MethodReference class: MDSliceTest class selector: #bogusMethodA)		with: (MethodReference class: MDSliceTest class selector: #bogusMethodB)! !!MDPackageSliceTest methodsFor: 'package info' stamp: 'cwp 3/16/2005 01:09'!packageName	^ 'TestPackage'! !!MDPackageSliceTest methodsFor: 'tests' stamp: 'cwp 6/15/2008 21:43'!testLoad	| properties old info |	properties := MDPropertyDictionary new		name: 'SomePackage';		yourself.	old := slice instVarNamed: 'package'.	slice load: properties.	info := slice instVarNamed: 'package'.	self assert: slice name = 'SomePackage'.	self assert: (info isKindOf: PackageInfo).	self deny: info == old.! !!MDPackageSliceTest class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2005 02:14'!bogusMethodA	"This method needs to be here for #testClassMethods to pass"! !!MDPackageSliceTest class methodsFor: 'as yet unclassified' stamp: 'cwp 3/3/2005 02:14'!bogusMethodB	"This method needs to be here for #testClassMethods to pass"! !MDProjectPartElement subclass: #MDParentAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!!MDParentAdaptor methodsFor: 'private' stamp: 'cwp 6/1/2008 12:05'!historian	^ self project historianForSliceId: element sliceId! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/1/2008 12:02'!isLoadable: properties	^ self project slices anySatisfy: [:ea | ea id = element sliceId]! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/14/2008 13:26'!isPresent	^ (self project 		historianForSliceId: element sliceId 		ifAbsent: [^ false]) 			parents isEmpty not! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/1/2008 20:32'!isUpToDate: properties	^ self historian parents first = properties memoref! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/1/2008 21:30'!load: properties	| project memo |	project := self project.	memo := project store get: properties memoref.	project load: memo! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/1/2008 20:30'!remove	self historian clearParents! !!MDParentAdaptor methodsFor: 'public' stamp: 'cwp 6/1/2008 12:05'!update: properties	^ properties 		memoref: self historian parents first;		yourself! !MDMonticelloAdaptorTest subclass: #MDParentAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDParentAdaptorTest methodsFor: 'constructing' stamp: 'cwp 6/1/2008 11:09'!adaptorClass	^ MDParentAdaptor! !!MDParentAdaptorTest methodsFor: 'asserting' stamp: 'cwp 6/1/2008 11:53'!assertObjectHasDefaultProperties	| parents |	parents := self historian parents.	^ parents isEmpty		ifTrue: [false]		ifFalse: [parents first = self memo hashstamp]! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:36'!changedValue	^ MDHashstamp new! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:25'!createObject	self historian noteLoad: self memo! !!MDParentAdaptorTest methodsFor: 'running' stamp: 'cwp 6/1/2008 21:21'!createRepository	| repository |	repository := MDMemoryRepository named: 'testing'.	self repositoryContents do: [:object | repository put: object].	^ repository! !!MDParentAdaptorTest methodsFor: 'running' stamp: 'cwp 6/1/2008 20:52'!createSlice	| slice |	slice := MDExplicitSlice named: self sliceName.	slice addElement: (MDFakeElement named: #Alpha).	slice addElement: (MDFakeElement named: #Beta).	^ slice! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:53'!destroyObject	self project addSlice: self slice! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:44'!element	^ MDParentElement projectId: self projectId sliceId: self sliceId! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:20'!historian	^ self project historianForSliceId: self sliceId! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 21:26'!memo	^ self project store get: self memoHashstamp! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 21:16'!memoHashstamp	^ MDHashstamp fromString: 'BGJFP0Dn9CYghccRplcRdbvNZwwbWksk'! !!MDParentAdaptorTest methodsFor: 'asserting' stamp: 'cwp 6/1/2008 11:40'!objectIsPresent	^ self historian parents isEmpty not! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 21:32'!properties	^ MDPropertyDictionary new		memoref: self memoHashstamp;		yourself! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 21:33'!propertyToChange	^ #memoref! !!MDParentAdaptorTest methodsFor: 'running' stamp: 'cwp 6/1/2008 21:19'!repositoryContents	^ MDMarshal materialize:  '		5%Ql			Alpha		one	alpha	 	5%Ql	5%Ql^/hLYO=5%QllM[U+*e	5%Ql			Beta		one	beta	 	5%Ql5%Ql{N(3Hn.	 		initials	cwp	ordinal			sliceName		TestSlice    ,!!tscF%Iyw' asByteArray! !!MDParentAdaptorTest methodsFor: 'running' stamp: 'cwp 6/1/2008 21:23'!setUp	| project |	registry := MDRegistry new.	project := MDProject forTesting.	registry register: project.	project addSlice: self createSlice.	project addRepository: self createRepository! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:57'!slice	| id |	id := self sliceId.	^ self project slices detect: [:ea | ea id = id] ifNone: [nil].! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:58'!sliceId	^ MDHashstamp fromString: '+++++-5I97XP6S5wR+lnMxW0FWJ71LZr'! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:58'!sliceName	^ 'TestSlice'! !!MDParentAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:55'!unloadableElement	^ MDParentElement projectId: self projectId sliceId: MDHashstamp new! !MDVariableChunk subclass: #MDPoolImportChunk	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-FileOut'!!MDPoolImportChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:48'!definitionSelector	^ 'addSharedPool:'! !!MDPoolImportChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:48'!listSelector	^ 'sharedPools'! !!MDPoolImportChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:55'!quote	^ ''! !!MDPoolImportChunk methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:28'!removalSelector	^ 'removeSharedPool:'! !!MDPoolImportChunk methodsFor: 'as yet unclassified' stamp: 'cwp 3/30/2008 23:52'!typeChar	^ $e! !MDVariableChunkTest subclass: #MDPoolImportChunkTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Tests'!!MDPoolImportChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/2/2008 23:45'!expectedIndependentDefinition	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB sharedPools includes: BogusPool) ifFalse:		[BogusB addSharedPool: BogusPool]]!!'! !!MDPoolImportChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:29'!expectedIndependentRemoval	^ '(Smalltalk hasClassNamed: #BogusB) ifTrue:	[(BogusB sharedPools includes: BogusPool) ifTrue:		[BogusB removeSharedPool: BogusPool]]!!'! !!MDPoolImportChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:27'!expectedSimpleDefinition	^ '(BogusB sharedPools includes: BogusPool) ifFalse:	[BogusB addSharedPool: BogusPool]!!'! !!MDPoolImportChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:29'!expectedSimpleRemoval	^ '(BogusB sharedPools includes: BogusPool) ifTrue:	[BogusB removeSharedPool: BogusPool]!!'! !!MDPoolImportChunkTest methodsFor: 'as yet unclassified' stamp: 'cwp 4/3/2008 21:18'!setUp	chunk := MDPoolImportChunk forElement: (MDPoolImportElement 			className: #BogusB			name: #BogusPool)! !MDErrorMessage subclass: #MDProcessingError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!MDMonticelloAdaptorTest subclass: #MDProjectAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDProjectAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/27/2008 22:21'!adaptorClass	^ MDProjectAdaptor! !!MDProjectAdaptorTest methodsFor: 'asserting' stamp: 'cwp 5/27/2008 22:12'!assertObjectHasDefaultProperties	self assert: (registry objectWithId: self projectId) name = self projectName! !!MDProjectAdaptorTest methodsFor: 'configuration' stamp: 'cwp 5/27/2008 21:43'!canBeUnloadable 	^ false! !!MDProjectAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 21:53'!changedValue	^ 'RenamedProject'! !!MDProjectAdaptorTest methodsFor: 'effects' stamp: 'cwp 8/3/2008 23:07'!createObject	| project |	project := MDProject id: self projectId.	project name: self projectName.	registry register: project.	project subscribe! !!MDProjectAdaptorTest methodsFor: 'effects' stamp: 'cwp 6/1/2008 11:43'!destroyObject	registry unregisterId: self objectId! !!MDProjectAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/27/2008 22:12'!element	^ MDProjectElement id: self projectId! !!MDProjectAdaptorTest methodsFor: 'effects' stamp: 'cwp 5/27/2008 22:24'!objectId	^ self projectId! !!MDProjectAdaptorTest methodsFor: 'asserting' stamp: 'cwp 5/27/2008 22:12'!objectIsPresent	^ registry includesId: self projectId! !!MDProjectAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 21:46'!projectName	^ 'TestProject'! !!MDProjectAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 21:46'!properties	^ MDPropertyDictionary new		name: self projectName;		yourself! !!MDProjectAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 21:53'!propertyToChange	^ #name! !!MDProjectAdaptorTest methodsFor: 'tests' stamp: 'cwp 8/3/2008 23:05'!testProjectSubscribesWhenAdded		self editDuring: [self adaptor load: self properties].	self assert: (MDAnnouncer default subscribers includes: self project)! !!MDProjectAdaptorTest methodsFor: 'tests' stamp: 'cwp 8/3/2008 23:12'!testProjectUnsubscribesWhenRemoved		| project |	self createObject.		"The removal below unregisters the project, so grab a reference now."	project := registry objectWithId: self projectId.		self editDuring: [self adaptor remove].	self deny: (MDAnnouncer default subscribers includes: project)		! !MDAbstractProjectBrowser subclass: #MDProjectBrowser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Browsers'!!MDProjectBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:33'!initialExtent	^ 400@300! !!MDProjectBrowser methodsFor: 'as yet unclassified' stamp: 'cwp 7/26/2008 18:11'!projects	^ Array with: self root project! !!MDProjectBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:26'!defaultMetaNode	^ self projectMetanode! !!MDProjectBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:25'!defaultRootNode	^ MDProjectNode on: MDProject new! !!MDProjectBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:27'!openOn: aProject	^ self openRoot: (MDProjectNode on: aProject)! !!MDProjectBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:27'!paneCount	^ 2! !!MDProjectBrowser class methodsFor: 'as yet unclassified' stamp: 'cwp 12/13/2007 20:27'!titleForRoot: aProjectNode	^ 'Project - ', aProjectNode name! !MDMonticelloSliceTest subclass: #MDProjectConfigSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDProjectConfigSliceTest methodsFor: 'running' stamp: 'cwp 11/10/2008 06:18'!createSlice	^ MDProjectConfigSlice on: project! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testFirstRepository	self assertIncludesRepositoryNamed: 'FirstRepository'! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testFirstSlice	self assertIncludesSliceNamed: 'FirstSlice'! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 09:45'!testLoad	| properties |	properties := MDPropertyDictionary new		projectId: project id;		yourself.	slice load: properties.	self assert: (slice instVarNamed: 'project') = project! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 09:45'!testParents	slice elements do: [:ea | self deny: (ea isKindOf: MDParentElement)]! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 17:04'!testProject	| element |	element := MDProjectElement id: project id.	self assert: (slice elements includes: element).	self assert: (slice includes: element)! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testSecondRepository	self assertIncludesRepositoryNamed: 'SecondRepository'! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testSecondSlice	self assertIncludesSliceNamed: 'SecondSlice'! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testThirdRepository	| element |	element := MDRepositoryElement 		projectId: project id		repositoryId: MDHashstamp new.	self deny: (slice elements includes: element).	self assert: (slice includes: element)! !!MDProjectConfigSliceTest methodsFor: 'tests' stamp: 'cwp 6/19/2008 16:55'!testThirdSlice	| element |	element := MDSliceElement 		projectId: project id		sliceId: MDHashstamp new.	self deny: (slice elements includes: element).	self assert: (slice includes: element)! !MDPropertiesDefintion subclass: #MDProjectDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDProjectDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 16:02'!timestamp	^ nil! !MDMonticelloElement subclass: #MDProjectElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!(MDProjectElement instVarNames includes: 'id') ifFalse:	[MDProjectElement addInstVarName: 'id']!!MDProjectElement methodsFor: 'comparing' stamp: 'cwp 6/1/2008 23:46'!= other	^ self species = other species and: [id = other id]! !!MDProjectElement methodsFor: 'adapting' stamp: 'cwp 3/4/2008 22:21'!adaptedFor: aProxy	^ aProxy adaptorForProjectElement: self! !!MDProjectElement methodsFor: 'comparing' stamp: 'cwp 6/1/2008 23:09'!hash	^ id hash! !!MDProjectElement methodsFor: 'accessing' stamp: 'cwp 3/4/2008 23:00'!id	^ id! !!MDProjectElement methodsFor: 'testing' stamp: 'cwp 6/1/2008 23:17'!isIncludedInSlice: aSlice	^ aSlice includesProjectElement: self! !!MDProjectElement methodsFor: 'initialize-release' stamp: 'cwp 3/4/2008 22:58'!setId: aHashstamp	id := aHashstamp! !!MDProjectElement class methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 22:56'!for: aProject	^ self id: aProject id! !!MDProjectElement class methodsFor: 'as yet unclassified' stamp: 'cwp 3/4/2008 22:55'!id: aHashstamp	^ self new setId: aHashstamp! !MDMonticelloSliceTest subclass: #MDProjectSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDProjectSliceTest methodsFor: 'running' stamp: 'cwp 11/10/2008 06:19'!createSlice	^ MDProjectSlice on: project! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/10/2008 06:15'!testFirstRepository	self denyIncludesRepositoryNamed: 'FirstRepository'! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/10/2008 06:15'!testFirstSlice	self assertIncludesSliceNamed: 'FirstSlice'! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 19:22'!testLoad	| properties |	properties := MDPropertyDictionary new		projectId: project id;		yourself.	slice load: properties.	self assert: (slice instVarNamed: 'project') = project! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 19:21'!testParents	slice elements do: [:ea | self deny: (ea isKindOf: MDParentElement)]! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/10/2008 06:16'!testProject	| element |	element := MDProjectElement id: project id.	self assert: (slice elements includes: element).	self assert: (slice includes: element)! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 14:53'!testSecondRepository	self denyIncludesRepositoryNamed: 'SecondRepository'! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 14:54'!testSecondSlice	self assertIncludesSliceNamed: 'SecondSlice'! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 14:55'!testThirdRepository	| element |	element := MDRepositoryElement 		projectId: project id		repositoryId: MDHashstamp new.	self deny: (slice elements includes: element).	self deny: (slice includes: element)! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 14:55'!testThirdSlice	| element |	element := MDSliceElement 		projectId: project id		sliceId: MDHashstamp new.	self deny: (slice elements includes: element).	self assert: (slice includes: element)! !!MDProjectSliceTest methodsFor: 'tests' stamp: 'cwp 11/11/2008 19:32'!testUpdate	| properties |	properties := slice properties.	self assert: properties name = 'project'.	self assert: properties type = #Project.	self assert: properties projectId = (MDHashstamp fromString: '+++++6tCHw7ghiWz05AunY6i-a4LPqBg')! !MDObjectsMessage subclass: #MDPutObjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDPutObjects methodsFor: 'dispatch' stamp: 'cwp 1/4/2008 22:16'!handledBy: anObject	^ anObject handlePutObjects: self! !!MDPutObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:44'!id	^ 66! !MDProjectPartElement subclass: #MDRepositoryAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 5/31/2008 18:06'!createRepository: type	| repository |	repository := (MDRepository classForType: type) id: element repositoryId.	self project addRepository: repository.	^ repository! !!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 6/14/2008 13:33'!isPresent	| project |	project := self project.	^ project 		ifNil: [false]		ifNotNil: [project repositories anySatisfy: [:ea | ea id = element repositoryId]]! !!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 5/31/2008 18:15'!isUpToDate: properties	| repository |	repository := self repositoryIfAbsent: [^ false].	^ repository properties = properties! !!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 5/31/2008 18:01'!load: properties	| repository |	repository := self repositoryIfAbsent: [self createRepository: properties type].	repository properties: properties! !!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 5/31/2008 18:11'!remove	self project removeRepository: (self repositoryIfAbsent: [^ self])! !!MDRepositoryAdaptor methodsFor: 'private' stamp: 'cwp 5/31/2008 17:54'!repositoryIfAbsent: aBlock	^ self project store repositories 		detect: [:ea | ea id = element repositoryId]		ifNone: aBlock! !!MDRepositoryAdaptor methodsFor: 'public' stamp: 'cwp 5/31/2008 18:10'!update: properties	^ (self repositoryIfAbsent: [^ properties]) update: properties! !MDMonticelloAdaptorTest subclass: #MDRepositoryAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 15:05'!adaptorClass	^ MDRepositoryAdaptor! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:50'!assertObjectHasDefaultProperties	self assert: self repository name = self repositoryName! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 18:08'!changedValue	^ 'RepositoryWithAnotherName'! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:41'!createObject	self project addRepository: (MDMemoryRepository named: self repositoryName)! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 11:48'!destroyObject	self repository ifNotNilDo: [:repo | self project removeRepository: repo]! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:34'!element	^ MDRepositoryElement projectId: self projectId repositoryId: self objectId! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:30'!objectId	^ MDHashstamp fromString: '+++++449pYEbmIMUWJrr81Kms4gzvAne'! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 18:14'!objectIsPresent	| id |	id := self objectId.	^ self project store repositories anySatisfy: [:ea | ea id = id]! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 18:02'!properties	^ MDPropertyDictionary new		type: MDMemoryRepository type;		name: self repositoryName;		yourself! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 18:06'!propertyToChange	^ #name! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 11:48'!repository	| id |	id := self objectId.	^ self project repositories detect: [:ea | ea id = id] ifNone: [nil]! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:42'!repositoryName	^ 'TestRepository'! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:33'!setUp	super setUp.	registry register: MDProject forTesting! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:46'!system	^ registry! !!MDRepositoryAdaptorTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:45'!unloadableElement	^ MDRepositoryElement projectId: MDHashstamp new repositoryId: self objectId! !MDMonticelloElement subclass: #MDRepositoryElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!(MDRepositoryElement instVarNames includes: 'projectId') ifFalse:	[MDRepositoryElement addInstVarName: 'projectId']!(MDRepositoryElement instVarNames includes: 'repositoryId') ifFalse:	[MDRepositoryElement addInstVarName: 'repositoryId']!!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 23:45'!= other 	^ self species = other species 		and: [repositoryId = other repositoryId] 		and: [projectId = other projectId]! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:55'!adaptedFor: aProxy	^ aProxy adaptorForRepositoryElement: self! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 23:45'!hash	^ ByteArray 		hashBytes: repositoryId 		startingWith: (ByteArray 						hashBytes: projectId 						startingWith: self species hash)! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 23:50'!isIncludedInSlice: aSlice	^ aSlice includesRepositoryElement: self! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:40'!projectId	^ projectId! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:38'!repositoryId	^ repositoryId! !!MDRepositoryElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:52'!setProjectId: pHashstamp repositoryId: rHashstamp	projectId := pHashstamp.	repositoryId := rHashstamp.! !!MDRepositoryElement class methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:32'!forRepository: aRepository inProject: aProject	^ self projectId: aProject id repositoryId: aRepository id! !!MDRepositoryElement class methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 17:32'!projectId: pHashstamp repositoryId: rHashstamp	^ self new setProjectId: pHashstamp repositoryId: rHashstamp! !MDHashstampMessage subclass: #MDRequestObjects	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDRequestObjects methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 00:11'!filter: aCollection in: aBlock	| selected |	selected := aCollection select: [:ea | hashstamps includes: ea hashstamp].	selected isEmpty ifFalse: [aBlock value: (MDPutObjects with: selected)]! !!MDRequestObjects methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 21:00'!isRequestObjects	^ true! !!MDRequestObjects class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 19:43'!id	^ 129! !MDProjectPartElement subclass: #MDSliceAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Adaptors'!!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 8/6/2008 00:22'!createSlice: type	| slice |	slice := (MDSlice classForType: type) id: element sliceId.	^ slice! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 6/14/2008 13:34'!isPresent	| project |	project := self project.	^ project		ifNil: [false]		ifNotNil: [project slices anySatisfy: [:ea | ea id = element sliceId]]! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 00:06'!isUpToDate: properties	| slice |	slice := self sliceIfAbsent: [^ false].	^ slice properties = properties! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 8/6/2008 00:22'!load: properties	| slice |	slice := self sliceIfAbsent: [self createSlice: properties type].	slice load: properties.	self project addSlice: slice.! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 00:02'!remove	| slice |	slice := self sliceIfAbsent: [^ self].	self project removeSlice: slice! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 00:00'!sliceIfAbsent: aBlock	^ self project slices 		detect: [:ea | ea id = element sliceId] 		ifNone: aBlock! !!MDSliceAdaptor methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 00:00'!update: properties	| slice |	slice := self sliceIfAbsent: [^ properties].	slice properties keysAndValuesDo:		[:key :value | properties at: key put: value].	^ properties! !MDMonticelloAdaptorTest subclass: #MDSliceAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Tests'!!MDSliceAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/27/2008 22:22'!adaptorClass	^ MDSliceAdaptor! !!MDSliceAdaptorTest methodsFor: 'asserting' stamp: 'cwp 5/27/2008 23:38'!assertObjectHasDefaultProperties	| slice |	slice := self slice.	self assert: slice name = self sliceName.	self assert: slice elements isEmpty! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/28/2008 00:06'!changedValue	^ 'SliceForTesting'! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 23:45'!createObject	self project addSlice: (MDExplicitSlice named: self sliceName)! !!MDSliceAdaptorTest methodsFor: 'constructing' stamp: 'cwp 6/1/2008 11:49'!destroyObject	self slice ifNotNilDo: [:slice | self project removeSlice: slice]! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 22:39'!element	^ MDSliceElement projectId: self projectId sliceId: self sliceId! !!MDSliceAdaptorTest methodsFor: 'asserting' stamp: 'cwp 5/28/2008 00:03'!objectIsPresent	| id |	id := self sliceId.	^ self project slices anySatisfy: [:ea | ea id = id].! !!MDSliceAdaptorTest methodsFor: 'constructing' stamp: 'cwp 5/29/2008 08:05'!properties	^ MDPropertyDictionary new		name: 'TestSlice';		type: #Explicit;		elements: Set new;		yourself! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/28/2008 00:06'!propertyToChange	^ #name! !!MDSliceAdaptorTest methodsFor: 'running' stamp: 'cwp 5/27/2008 22:08'!setUp	super setUp.	registry register: MDProject forTesting! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 6/1/2008 11:47'!slice	| id |	id := self sliceId.	^ self project slices detect: [:ea | ea id = id] ifNone: [nil].! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/29/2008 08:03'!sliceId	^ MDHashstamp fromString: '+++++-5I97XP6S5wR+lnMxW0FWJ71LZr'! !!MDSliceAdaptorTest methodsFor: 'accessing' stamp: 'cwp 5/27/2008 23:45'!sliceName	^ 'TestSlice'! !!MDSliceAdaptorTest methodsFor: 'constructing' stamp: 'cwp 6/1/2008 11:43'!unloadableElement	^ MDSliceElement projectId: MDHashstamp new sliceId: self sliceId! !MDSliceTouched subclass: #MDSliceClean	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!MDPropertiesDefintion subclass: #MDSliceDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!MDSliceTouched subclass: #MDSliceDirty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Announcements'!MDMonticelloElement subclass: #MDSliceElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!(MDSliceElement instVarNames includes: 'projectId') ifFalse:	[MDSliceElement addInstVarName: 'projectId']!(MDSliceElement instVarNames includes: 'sliceId') ifFalse:	[MDSliceElement addInstVarName: 'sliceId']!!MDSliceElement methodsFor: 'comparing' stamp: 'cwp 5/24/2008 11:29'!= other 	^ self species = other species 		and: [sliceId = other sliceId] 		and: [projectId = other projectId]! !!MDSliceElement methodsFor: 'adapting' stamp: 'cwp 1/18/2007 21:31'!adaptedFor: anImageProxy	^ anImageProxy adaptorForSliceElement: self! !!MDSliceElement methodsFor: 'printing' stamp: 'cwp 8/28/2005 17:44'!displayClassName	^ self className allButFirst: 2! !!MDSliceElement methodsFor: 'comparing' stamp: 'cwp 5/24/2008 11:43'!hash	^ ByteArray 		hashBytes: sliceId 		startingWith: (ByteArray 						hashBytes: projectId 						startingWith: self species hash)! !!MDSliceElement methodsFor: 'testing' stamp: 'cwp 6/1/2008 23:32'!isIncludedInSlice: aSlice	^ aSlice includesSliceElement: self! !!MDSliceElement methodsFor: 'accessing' stamp: 'cwp 5/24/2008 11:30'!projectId	^ projectId! !!MDSliceElement methodsFor: 'initialize-release' stamp: 'cwp 5/24/2008 11:46'!setProjectId: pHashstamp sliceId: sHashstamp	projectId := pHashstamp.	sliceId := sHashstamp! !!MDSliceElement methodsFor: 'accessing' stamp: 'cwp 5/24/2008 11:27'!sliceId	^ sliceId! !!MDSliceElement class methodsFor: 'instance creation' stamp: 'cwp 5/27/2008 22:17'!forSlice: aSlice inProject: aProject 	^ self 		projectId: aProject id		sliceId: aSlice id! !!MDSliceElement class methodsFor: 'instance creation' stamp: 'cwp 5/27/2008 22:17'!projectId: projectId sliceId: sliceId 	^ self new		setProjectId: projectId sliceId: sliceId;		yourself! !MDProxyTest subclass: #MDSliceOpsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDSliceOpsTest instVarNames includes: 'wc') ifFalse:	[MDSliceOpsTest addInstVarName: 'wc']!(MDSliceOpsTest instVarNames includes: 'repository') ifFalse:	[MDSliceOpsTest addInstVarName: 'repository']!(MDSliceOpsTest instVarNames includes: 'snapshot') ifFalse:	[MDSliceOpsTest addInstVarName: 'snapshot']!!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:26'!addToBoth: aVersion	snapshot add: aVersion.	repository add: aVersion! !!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:25'!addToRepository: aVersion	repository add: aVersion! !!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:25'!addToSnapshot: aVersion	snapshot add: aVersion! !!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 3/10/2005 23:28'!prepare	self prepare: 		[self addToBoth: (self versionFor: #Alpha with: 'alpha').		self addToBoth: (self versionFor: #Beta with: 'beta')].! !!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 5/22/2008 00:10'!prepare: aBlock	| repositoryVersions |	repository := Set new.	snapshot := Set new.	aBlock value.	repositoryVersions := repository.	repository := MDMemoryRepository new.	repositoryVersions do: [:ea | repository put: ea].	snapshot := MDSnapshot withVersions: snapshot		! !!MDSliceOpsTest methodsFor: 'running' stamp: 'cwp 5/27/2008 06:58'!setUp	super setUp.	wc := MDWorkingCopy forDomain: proxy! !!MDSliceOpsTest methodsFor: 'constructing' stamp: 'cwp 3/16/2005 00:24'!slice	^ (MDExplicitSlice named: 'TestSlice')		addElement: (self element: #Alpha);		addElement: (self element: #Beta);		yourself	! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testAsExplicitSlice	| original copy |	original := self slice.	copy := original asExplicitSlice.	self assert: (copy isKindOf: MDExplicitSlice).	self assert: copy elements = original elements! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 3/2/2006 15:01'!testIncludeSnapshot	self prepare.	[self slice include: snapshot from: repository in: wc]		on: MDMergeRequest		do: [:ex | ex merges do: [:ea | ea applyTo: wc]].				self assertElementHasDefaultValue: #Alpha.	self assertElementHasDefaultValue: #Beta.! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:49'!testLoadEqualSnapshot	self prepare.	self slice load: snapshot from: repository to: wc.	self assertElementHasDefaultValue: #Alpha.	self assertElementHasDefaultValue: #Beta.! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 5/7/2008 07:43'!testLoadLargerSnapshot	| slice alpha beta |	self prepare.	alpha := self element: #Alpha.	beta := self element: #Beta.	slice := MDExplicitSlice named: 'TestSlice'.	slice addElement: alpha.	slice load: snapshot from: repository to: wc.	self assert: (self atElement: alpha property: #one) = 'alpha'.	self assert: (self atElement: beta property: #one) = 'beta'.	self assert: slice elements size = 1! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:52'!testLoadSmallerSnapshot	self prepare: [self addToBoth: (self versionFor: #Alpha with: 'alpha')].	self slice load: snapshot from: repository to: wc.	self assertElementHasDefaultValue: #Alpha.	self assertElement: #Beta property: #one hasValue: nil! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:55'!testLoadWithDepenencies	self prepare:		[self addToBoth: (self versionFor: #Alpha).		self addToBoth: (self versionFor: #Beta).		self addToBoth: (self versionFor: #'Alpha/Delta' with: 'ad')].	self slice load: snapshot from: repository to: wc.	self		assertElementHasDefaultValue: #Alpha;		assertElementHasDefaultValue: #Beta;		assertElement: #'Alpha/Delta' property: #one hasValue: 'ad'.! !!MDSliceOpsTest methodsFor: 'tests' stamp: 'cwp 5/22/2008 00:10'!testSaveWithMemo	| slice versions memo |	self prepare: [].	slice := self slice.	memo := self memo.	snapshot := slice saveFrom: wc to: repository memo: memo.	versions := snapshot getVersionsFrom: repository.	slice do: 		[:element |		self assert: (versions anySatisfy: [:version | version element = element])].	self deny: (repository get: snapshot hashstamp) isNil.	self deny: (repository get: memo hashstamp) isNil.! !MDSqueakInstVarAdaptor subclass: #MDSqueakClassInstVarAdaptor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Adaptors'!!MDSqueakClassInstVarAdaptor methodsFor: 'accessing' stamp: 'cwp 3/4/2005 15:04'!elementClassIfAbsent: aBlock	^ (super elementClassIfAbsent: aBlock) class! !MDSqueakInstVarAdaptorTest subclass: #MDSqueakClassInstVarAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakClassInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 3/4/2005 15:05'!adaptor	^ MDSqueakClassInstVarAdaptor forElement: self element! !!MDSqueakClassInstVarAdaptorTest methodsFor: 'accessing' stamp: 'cwp 3/4/2005 14:54'!bogusClass	^ super bogusClass class! !!MDSqueakClassInstVarAdaptorTest methodsFor: 'constructing' stamp: 'cwp 3/4/2005 15:13'!element	^ MDClassInstVarElement 		className: self bogusClass theNonMetaClass name 		name: self instVarName! !!MDSqueakClassInstVarAdaptorTest methodsFor: 'constants' stamp: 'cwp 5/20/2008 20:10'!firstInstVarName	^ 'aleph'! !!MDSqueakClassInstVarAdaptorTest methodsFor: 'constants' stamp: 'cwp 3/4/2005 14:54'!instVarName	^ 'beth'! !MDSqueakMethodAdaptorTest subclass: #MDSqueakClassMethodAdaptorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Squeak-Tests'!!MDSqueakClassMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 15:14'!bogusClass	^ super bogusClass class! !!MDSqueakClassMethodAdaptorTest methodsFor: 'constructing' stamp: 'cwp 2/12/2005 15:21'!element	^ MDMethodElement 		className: super bogusClass name		selector: self theSelector		classIsMeta: true! !MDErrorMessage subclass: #MDStorageFailed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDStorageFailed class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:34'!id	^ 196! !MDRepository subclass: #MDStore	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Repositories'!!MDStore commentStamp: 'dc 6/14/2007 07:22' prior: 0!A store is a Composite of repositories.!(MDStore instVarNames includes: 'repositories') ifFalse:	[MDStore addInstVarName: 'repositories']!!MDStore methodsFor: 'actions' stamp: 'cwp 3/13/2005 00:26'!addRepository: aRepository	repositories add: aRepository! !!MDStore methodsFor: 'synchronization' stamp: 'cwp 5/22/2008 00:10'!allHashstamps	| all |	all := Set new.	repositories do: [:ea | all addAll: ea allHashstamps].	^ all! !!MDStore methodsFor: 'actions' stamp: 'cwp 12/23/2006 20:59'!ensureRepository: aRepository	(repositories includes: aRepository)		ifFalse: [repositories add: aRepository]! !!MDStore methodsFor: 'accessing' stamp: 'dc 6/14/2007 07:28'!firstRepository	^ repositories first! !!MDStore methodsFor: 'public' stamp: 'cwp 5/23/2006 20:17'!get: aHashstamp	repositories do: [:ea | (ea get: aHashstamp) ifNotNilDo: [:object | ^ object]].	^ nil! !!MDStore methodsFor: 'synchronization' stamp: 'cwp 12/23/2007 00:14'!includes: aHashstamp	^ repositories anySatisfy: [:ea | ea includes: aHashstamp]! !!MDStore methodsFor: 'initialize-release' stamp: 'cwp 5/24/2008 13:09'!initialize	repositories := OrderedCollection new.	self initId! !!MDStore methodsFor: 'public' stamp: 'dc 6/14/2007 07:20'!memos	| memos |	memos := Set new.	repositories do: [:ea | memos addAll: ea memos].	^ memos asArray! !!MDStore methodsFor: 'public' stamp: 'cwp 5/31/2008 14:42'!name	^ 'store'! !!MDStore methodsFor: 'accessing' stamp: 'cwp 5/31/2008 22:52'!properties: aPropertyDictionary	"Ignore"! !!MDStore methodsFor: 'public' stamp: 'cwp 3/13/2005 00:26'!put: anObject	repositories do: [:ea | ea put: anObject]! !!MDStore methodsFor: 'actions' stamp: 'cwp 12/29/2006 16:58'!removeRepository: aRepository	repositories remove: aRepository! !!MDStore methodsFor: 'accessing' stamp: 'cwp 11/11/2007 21:55'!repositories	^ repositories! !(MDStore class instVarNames includes: 'default') ifFalse:	[MDStore class addInstVarName: 'default']!!MDStore class methodsFor: 'private' stamp: 'dc 7/19/2007 12:55'!createDefault	^ self new		addRepository: (MDMemoryRepository new);		yourself! !!MDStore class methodsFor: 'accessing' stamp: 'dc 6/14/2007 07:09'!default	^ default ifNil: [default := self createDefault]! !!MDStore class methodsFor: 'instance creation' stamp: 'cwp 11/20/2008 18:54'!new	^ self basicNew initialize! !!MDStore class methodsFor: 'accessing' stamp: 'dc 6/14/2007 07:09'!resetDefault	default := nil! !!MDStore class methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:52'!type	^ #Store! !MDErrorMessage subclass: #MDUnauthorized	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDUnauthorized class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:32'!id	^ 194! !MDSlice subclass: #MDUnionSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Slices'!(MDUnionSlice instVarNames includes: 'name') ifFalse:	[MDUnionSlice addInstVarName: 'name']!(MDUnionSlice instVarNames includes: 'slices') ifFalse:	[MDUnionSlice addInstVarName: 'slices']!!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 6/14/2008 17:46'!addSlice: aSlice	(slices includes: aSlice) ifFalse: [slices := slices copyWith: aSlice]! !!MDUnionSlice methodsFor: 'enumerating' stamp: 'cwp 5/22/2008 00:10'!elementsDo: aBlock	| done |	done := Set new.	slices do:		[:slice |		slice elementsDo:			[:element |			(done includes: element) ifFalse:				[aBlock value: element.				done add: element]]]! !!MDUnionSlice methodsFor: 'testing' stamp: 'cwp 2/3/2008 20:47'!includes: anElement	^ slices anySatisfy: [:ea | ea includes: anElement]! !!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 6/14/2008 17:47'!includesSlice: aSlice	^ slices includes: aSlice! !!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 5/31/2008 14:21'!load: properties 	name := properties name.	slices := properties slices collect: [ :ea | MDSlice withProperties: ea ]! !!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 5/29/2008 08:00'!name	^ name! !!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 6/14/2008 17:46'!removeSlice: aSlice	slices := slices copyWithout: aSlice! !!MDUnionSlice methodsFor: 'initialize-release' stamp: 'cwp 5/29/2008 07:59'!setName: aString slices: aCollection	name := aString.	slices := aCollection asArray.	self initId! !!MDUnionSlice methodsFor: 'accessing' stamp: 'cwp 5/29/2008 07:58'!update: properties	super update: properties.	properties slices: (slices collect: [:ea | ea properties]).	^ properties! !!MDUnionSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 5/29/2008 08:00'!name: aString	^ self name: aString slices: Set new! !!MDUnionSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 5/29/2008 07:59'!name: aString slices: aCollection	^ self new setName: aString slices: aCollection! !!MDUnionSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 3/1/2008 01:12'!type	^ #Composite! !MDSmalltalkSliceTest subclass: #MDUnionSliceTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 18:56'!createSlice	^ MDUnionSlice 		name: 'TestSlice'		slices: {  (self createSliceA). (self createSliceB)  }! !!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 2/3/2008 20:43'!createSliceA	^ (MDExplicitSlice named: 'TestSlice')		addElement: (MDClassElement className: #MDBogusA);		addElement: (MDClassElement className: #MDSliceTest);		addElement: (MDClassCommentElement className: #MDBogusA);		addElement: (MDClassCommentElement className: #MDSliceTest);		addElement: (MDMethodElement className: #MDSliceTest selector: #classes);		addElement: (MDMethodElement className: #MDSliceTest selector: #methods);		addElement: (MDMethodElement 						className: #MDSliceTest 						selector: #bogusMethodA 						classIsMeta: true);		yourself! !!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 10/2/2008 20:25'!createSliceB	^ (MDExplicitSlice named: 'TestSlice2')		addElement: (MDMethodElement 				className: #MDSliceTest				selector: #bogusMethodB				classIsMeta: true);		addElement: (MDInstVarElement 				className: #MDBogusA				name: 'one');		addElement: (MDClassVarElement 				className: #MDBogusA				name: 'MDAlpha');		addElement: (MDClassInstVarElement 				className: #MDBogusA				name: 'aleph');		addElement: (MDPoolImportElement 				className: #MDBogusA				name: 'MDBogusPoolA');		addElement: (MDPoolImportElement 				className: #MDBogusA				name: 'TextConstants');		yourself! !!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 6/14/2008 16:55'!testIntersectingSlices	| a b |	a := (MDExplicitSlice named: 'A')		addElement: (MDFakeElement named: #x);		yourself.	b := (MDExplicitSlice named: 'B')		addElement: (MDFakeElement named: #x);		yourself.	slice := MDUnionSlice 		name: 'Intersection'		slices: {  a. b  }.	elements := Array streamContents: [ :stream | slice elementsDo: [ :ea | stream nextPut: ea ] ].	self assert: elements size = 1.	self assert: elements first name = #x! !!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/31/2008 14:21'!testLoad	| properties |	properties := MDPropertyDictionary new		slices: {  (self createSliceA)  };		yourself.	slice load: properties.	self deny: (slice includes: (MDClassVarElement 				className: #MDBogusA				name: 'Alpha'))! !!MDUnionSliceTest methodsFor: 'as yet unclassified' stamp: 'cwp 5/28/2008 21:55'!testProperties	| properties |	properties := slice properties.	self assert: properties slices isCollection.	properties slices do: [:ea | self assert: ea type = #Explicit]! !MDErrorMessage subclass: #MDUnrecognizedMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Repositories-Net'!!MDUnrecognizedMessage class methodsFor: 'as yet unclassified' stamp: 'cwp 1/4/2008 00:27'!id	^ 192! !MDPropertiesDefintion subclass: #MDVariantDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!(MDVariantDefinition instVarNames includes: 'callback') ifFalse:	[MDVariantDefinition addInstVarName: 'callback']!!MDVariantDefinition methodsFor: 'editing' stamp: 'cwp 5/22/2008 21:15'!accept: aText notifying: aRequestor		self verify: aText notifying: aRequestor ifFail: [^ false].	object := callback value: (self variantWithSource: aText).	^ true! !!MDVariantDefinition methodsFor: 'editing' stamp: 'cwp 5/22/2008 21:15'!callback: aBlock	callback := aBlock! !!MDVariantDefinition methodsFor: 'editing' stamp: 'cwp 12/31/2007 16:31'!elementClass	^ Smalltalk at: self variant element theClassName ifAbsent: [Object]! !!MDVariantDefinition methodsFor: 'testing' stamp: 'cwp 12/31/2007 16:31'!isEditable	^ callback notNil! !!MDVariantDefinition methodsFor: 'accessing' stamp: 'cwp 12/31/2007 16:17'!timestamp	^ nil! !!MDVariantDefinition methodsFor: 'accessing' stamp: 'cwp 12/31/2007 15:32'!variant	^ object! !!MDVariantDefinition methodsFor: 'accessing' stamp: 'cwp 5/22/2008 21:15'!variant: aVariant	object := aVariant! !!MDVariantDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 7/23/2008 07:30'!variantWithSource: aString 	^ object! !!MDVariantDefinition methodsFor: 'editing' stamp: 'cwp 12/31/2007 16:32'!verify: aText notifying: aRequestor ifFail: aBlock! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForClassCommentElement: anElement	^ self new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/31/2007 16:27'!adaptorForClassElement: anElement	^ MDClassDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForClassInstVarElement: anElement	^ MDEmptyDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForClassVarElement: anElement	^ MDEmptyDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForInstVarElement: anElement	^ MDEmptyDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForMethodElement: anElement	^ MDMethodDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 7/24/2008 07:13'!adaptorForParentElement: anElement	^ self new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 12/17/2007 22:03'!adaptorForPoolImportElement: anElement	^ MDEmptyDefinition new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 7/24/2008 07:12'!adaptorForProjectElement: anElement	^ self new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 7/24/2008 07:12'!adaptorForRepositoryElement: anElement	^ self new! !!MDVariantDefinition class methodsFor: 'adapting' stamp: 'cwp 7/23/2008 06:57'!adaptorForSliceElement: anElement	^ self new! !MDProxyTest subclass: #MDWorkingCopyTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Tests'!(MDWorkingCopyTest instVarNames includes: 'wc') ifFalse:	[MDWorkingCopyTest addInstVarName: 'wc']!!MDWorkingCopyTest methodsFor: 'asserting' stamp: 'cwp 3/2/2005 23:49'!assertConflictIncluding: anElementVersion	wc includeVersion: anElementVersion onConflict: [:a :b | ^ self].	self assert: false! !!MDWorkingCopyTest methodsFor: 'asserting' stamp: 'cwp 3/2/2005 23:49'!assertNoConflictIncluding: anElementVersion	wc includeVersion: anElementVersion onConflict: [:a :b | self assert: false. ^self]! !!MDWorkingCopyTest methodsFor: 'running' stamp: 'cwp 5/27/2008 06:58'!setUp	super setUp.	wc := MDWorkingCopy forDomain: proxy! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 6/17/2008 00:10'!testImplicitDomainCreation	| domain |	domain := wc domainForElement: (MDClassElement className: #MDBogusA).	self assert: domain class type = #smalltalk! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testIncludeAbsentVersion	| version |	version := self version.	version variant properties one: 'bar'.	self assertNoConflictIncluding: version.	self assert: (self atProperty: #one) = 'bar'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testIncludeConflictingVersion	| version newVersion newVersion2 |	version := self version.	version variant properties source: 'one'.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	newVersion2 := self 				updateVersion: version				property: #source				put: 'three'.	wc loadVersion: newVersion.	self assertConflictIncluding: newVersion2! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testIncludeNewVersion	| version newVersion |	version := self version.	version variant properties source: 'one'.	wc loadVersion: version.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	self assertNoConflictIncluding: newVersion.	self assert: (self atProperty: #source) = 'two'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testIncludeOldVersion	| version newVersion |	version := self version.	version variant properties source: 'one'.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	wc loadVersion: newVersion.	self assert: (self atProperty: #source) = 'two'.	self assertNoConflictIncluding: version.	self assert: (self atProperty: #source) = 'two'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testLoad	| version |	version := self version.	version variant properties one: '1'.	wc loadVersion: version.	self assert: (self atProperty: #one) = '1'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testLoadAndSave	| version |	version := self version.	version variant properties one: '1'.	wc loadVersion: version.	self assert: (wc versionForElement: version element) == version! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 5/11/2008 22:06'!testLoadDeleteAndSave	| version newVersion |	version := self version.	version variant properties source: 'one'.	wc loadVersion: version.	proxy removeElement: version element.	newVersion := wc versionForElement: version element.	wc loadVersion: newVersion.	self deny: (proxy includesElement: version element)! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testLoadModifyAndSave	| version newVersion |	version := self version.	version variant properties source: 'one'.	wc loadVersion: version.	self assert: (wc versionForElement: version element) == version.	self atProperty: #source put: 'two'.	newVersion := wc versionForElement: version element.	self deny: newVersion == version.	self assert: (newVersion succeeds: version)! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testLoadModifySaveAndSave	| version newVersion newVersion2 |	version := self version.	version variant properties source: 'one'.	wc loadVersion: version.	self assert: (wc versionForElement: version element) == version.	self atProperty: #source put: 'two'.	newVersion := wc versionForElement: version element.	newVersion2 := wc versionForElement: version element.	self assert: newVersion == newVersion2! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testLoadOldVersion	| version newVersion |	version := self version.	version variant properties source: 'one'.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	wc loadVersion: newVersion.	self assert: (self atProperty: #source) = 'two'.	wc loadVersion: version.	self assert: (self atProperty: #source) = 'one'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testModifyAndIncludeConflictingVersion	| version newVersion |	version := self version.	version variant properties source: 'one'.	wc loadVersion: version.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	self atProperty: #source put: 'three'.	self assertConflictIncluding: newVersion! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testResolveConflict	| version newVersion newVersion2 mergedVersion |	version := self version.	version variant properties source: 'one'.	newVersion := self 				updateVersion: version				property: #source				put: 'two'.	newVersion2 := self 				updateVersion: version				property: #source				put: 'three'.	wc loadVersion: newVersion.	wc includeVersion: newVersion2		onConflict: 			[:a :b | 			self assert: a variant properties source = 'two'.			b variant].	self assert: (self atProperty: #source) = 'three'.	mergedVersion := wc versionForElement: version element.	self assert: mergedVersion variant = newVersion2 variant.	self assert: (mergedVersion succeeds: newVersion).	self assert: (mergedVersion succeeds: newVersion2)! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 3/25/2005 22:59'!testSaveAbsentVersion	| saved constructed |	saved := wc versionForElement: self element.	constructed := self versionFor: #Alpha.	self assert: saved ancestry isEmpty.	self assert: (constructed succeeds: saved)! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 10/16/2005 14:20'!testSaveFirstVersion	| version |	self 		atElement: self element		property: #one		put: 'one'.	version := wc versionForElement: self element.	self assert: version ancestry isEmpty.	self assert: version variant properties one = 'one'! !!MDWorkingCopyTest methodsFor: 'tests' stamp: 'cwp 5/11/2008 22:00'!testTransaction	| version |	version := self version.	version variant properties one: '1'.	wc transaction: 		[wc loadVersion: version.		self deny: (proxy includesElement: version element)].	self assert: (self atProperty: #one) = '1'! !MDVariantDefinition subclass: #MDClassDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!accept: aText notifying: aRequestor		| variant |	variant := self parse: aText notifying: aRequestor.	variant ifNil: [^ false].	object := callback value: variant.	^ true! !!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 1/1/2008 23:48'!formatFromSelector: aSelector	aSelector = #weakSubclass: ifTrue: [^ #weak].	aSelector = #variableSubclass: ifTrue: [^ #variable].	aSelector = #variableByteSubclass: ifTrue: [^ #bytes].	aSelector = #variableWordSubclass: ifTrue: [^ #words].	^ #normal! !!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!formatSelector	| format |	format := self properties format.	format = #weak ifTrue: [^ 'weakSubclass:' ].	format = #variable ifTrue: [^ 'variableSubclass:'].	format = #bytes ifTrue: [^ 'variableByteSubclass:'].	format = #words ifTrue: [^ 'variableWordSubclass:'].	^ 'subclass:'! !!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!parse: aText notifying: aRequestor	| tokens element variant |	tokens := Scanner new scanTokens: aText.	self verify: tokens notifying: aRequestor ifFail: [^ nil].	element := MDClassElement className: tokens third.	variant := MDDefinitionVariant forElement: element.	variant properties superclassName: tokens first.	variant properties category: tokens fifth.	variant properties format: (self formatFromSelector: tokens second).	^ variant! !!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!text	| properties |	properties := self properties.	^ String streamContents:		[:stream |		stream 			nextPutAll: properties superclassName;			space;			nextPutAll: self formatSelector;			space;			nextPutAll: self variant element theClassName;			crtab;			nextPutAll: 'category: ''';			nextPutAll: properties category;			nextPut: $']! !!MDClassDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 1/1/2008 23:15'!verify: tokens notifying: aRequestor ifFail: aBlock	tokens size = 5 ifFalse: aBlock.	tokens first isSymbol ifFalse: aBlock.	(#(subclass: weakSubclass: variableSubclass: variableByteSubclass: variableWordSubclass:) 		includes: tokens second) ifFalse: aBlock.	tokens third isSymbol ifFalse: aBlock.	tokens fourth = #category: ifFalse: aBlock.	tokens fifth isString ifFalse: aBlock.! !MDClassAwareNamedElement subclass: #MDClassInstVarElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDClassInstVarElement methodsFor: 'adapting' stamp: 'cwp 3/4/2005 14:48'!adaptedFor: anImageProxy	^ anImageProxy adaptorForClassInstVarElement: self! !!MDClassInstVarElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:17'!isIncludedInSlice: aSlice	^ aSlice includesClassInstVar: self! !!MDClassInstVarElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:47'!printOn: aStream	self printStdIdOn: aStream with: 	'class instance variable'! !MDClassAwareNamedElement subclass: #MDClassVarElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDClassVarElement methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:31'!adaptedFor: anImageProxy	^ anImageProxy adaptorForClassVarElement: self! !!MDClassVarElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:14'!isIncludedInSlice: aSlice	^ aSlice includesClassVar: self! !!MDClassVarElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:45'!printOn: aStream	^ self printStdIdOn: aStream with: 'class variable'! !MDVariantDefinition subclass: #MDEmptyDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDEmptyDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 22:14'!callback: aBlock! !!MDEmptyDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/17/2007 00:33'!text	^ '-- present --'! !MDClassAwareNamedElement subclass: #MDInstVarElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDInstVarElement methodsFor: 'adapting' stamp: 'cwp 2/6/2005 22:28'!adaptedFor: anImageProxy	^ anImageProxy adaptorForInstVarElement: self! !!MDInstVarElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:15'!isIncludedInSlice: aSlice	^ aSlice includesInstVar: self! !!MDInstVarElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:47'!printOn: aStream	^ self printStdIdOn: aStream with: 'instance variable'! !MDVariantDefinition subclass: #MDMethodDefinition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-SqueakUI-Definitions'!!MDMethodDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 12/31/2007 15:32'!text	^ self properties source asText makeSelectorBold! !!MDMethodDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!variantWithSource: aText		| new |	new := MDDefinitionVariant forElement: self variant element.	new properties		category: self variant properties category;		initials: Utilities authorInitials;		source: aText asString;		timeStamp: MDTimestamp now.	^ new! !!MDMethodDefinition methodsFor: 'as yet unclassified' stamp: 'cwp 5/22/2008 21:15'!verify: aText notifying: aRequestor ifFail: aBlock	| class |	class := self elementClass.	class compilerClass new 		compile: aText 		in: class 		notifying: aRequestor 		ifFail: aBlock.	! !MDSliceElement subclass: #MDParentElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Elements'!!MDParentElement methodsFor: 'as yet unclassified' stamp: 'cwp 5/24/2008 12:59'!adaptedFor: anImageProxy	^ anImageProxy adaptorForParentElement: self! !!MDParentElement methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:13'!isIncludedInSlice: aSlice	^ aSlice includesParentElement: self! !MDMonticelloSlice subclass: #MDParentsSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Slices'!!MDParentsSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 06:59'!elementsDo: aBlock	project slices do: 		[:slice | aBlock value: (MDParentElement projectId: project id sliceId: slice id)]! !!MDParentsSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/5/2008 07:09'!includesParentElement: anElement	anElement projectId = project id ifFalse: [^ false].	^ project slices anySatisfy: [:slice | slice id = anElement sliceId]! !!MDParentsSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/7/2008 00:42'!name	^ project name, '/snapshots'! !!MDParentsSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 6/17/2008 00:19'!type	^ #Parents! !MDClassAwareNamedElement subclass: #MDPoolImportElement	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello2-Elements'!!MDPoolImportElement methodsFor: 'adapting' stamp: 'cwp 2/7/2005 00:01'!adaptedFor: anImageProxy	^ anImageProxy adaptorForPoolImportElement: self! !!MDPoolImportElement methodsFor: 'adapting' stamp: 'cwp 8/29/2005 01:31'!isIncludedInSlice: aSlice 	^ aSlice includesPoolImport: self! !!MDPoolImportElement methodsFor: 'printing' stamp: 'cwp 10/22/2008 21:48'!printOn: aStream	self printStdIdOn: aStream with: 'pool import'! !!MDPoolImportElement class methodsFor: 'instance creation' stamp: 'cwp 4/28/2008 22:04'!className: classNameSymbol name: poolNameSymbol 	^ self basicNew 		setClassName: classNameSymbol		name: poolNameSymbol! !MDMonticelloSlice subclass: #MDProjectConfigSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Slices'!!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 16:59'!elementsDo: aBlock	aBlock value: (MDProjectElement for: project).	project slices do: 		[:ea | aBlock value: (MDSliceElement projectId: project id sliceId: ea id)].		project repositories do: 		[:ea | aBlock value: (MDRepositoryElement projectId: project id repositoryId: ea id)].! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 17:00'!includesProjectElement: anElement	^ project id = anElement id! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 16:59'!includesRepositoryElement: anElement	^ project id = anElement projectId! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 17:05'!includesSliceElement: anElement	^ project id = anElement projectId! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 18:46'!load: properties	| projectId |	projectId := properties projectId.	project := (MDProject registry objectWithId: projectId)				ifNil: [(MDProject id: projectId) register]! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 16:57'!name	^ project name, '/config'! !!MDProjectConfigSlice methodsFor: 'as yet unclassified' stamp: 'cwp 6/1/2008 22:43'!update: properties	super update: properties.	^ properties		projectId: project id;		yourself! !!MDProjectConfigSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 6/19/2008 17:05'!type	^ #ProjectConfig! !MDMonticelloSlice subclass: #MDProjectSlice	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MC2-Monticello-Slices'!(MDProjectSlice instVarNames includes: 'name') ifFalse:	[MDProjectSlice addInstVarName: 'name']!!MDProjectSlice methodsFor: 'accessing' stamp: 'cwp 11/11/2008 14:51'!elementsDo: aBlock	aBlock value: (MDProjectElement for: project).	project slices do: 		[:ea | aBlock value: (MDSliceElement projectId: project id sliceId: ea id)].	! !!MDProjectSlice methodsFor: 'testing' stamp: 'cwp 11/11/2008 14:51'!includesProjectElement: anElement	^ project id = anElement id! !!MDProjectSlice methodsFor: 'testing' stamp: 'cwp 11/11/2008 14:52'!includesSliceElement: anElement	^ project id = anElement projectId! !!MDProjectSlice methodsFor: 'accessing' stamp: 'cwp 11/11/2008 19:24'!load: properties	| projectId |	projectId := properties projectId.	project := (MDProject registry objectWithId: projectId)				ifNil: [(MDProject id: projectId) register]! !!MDProjectSlice methodsFor: 'accessing' stamp: 'cwp 11/10/2008 07:52'!name	^ name! !!MDProjectSlice methodsFor: 'initialize-release' stamp: 'cwp 11/10/2008 06:27'!setProject: aProject	super setProject: aProject.	name := 'project'! !!MDProjectSlice methodsFor: 'accessing' stamp: 'cwp 11/11/2008 19:31'!update: properties	super update: properties.	^ properties		projectId: project id;		yourself! !!MDProjectSlice class methodsFor: 'as yet unclassified' stamp: 'cwp 11/11/2008 19:31'!type	^ #Project! !MDAuthorInfo initialize!MDHashstamp initialize!MDMaterializer initialize!MDNotificationAdaptor initialize!MDTimestamp initialize!MDTimestampPrinter initialize!MDProject initialize!MDRepositoryBrowser initialize!MDProjectRegistryBrowser initialize!